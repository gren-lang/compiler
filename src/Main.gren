port module Main exposing (main)

import Node
import ChildProcess
import Terminal.Parser as CliParser
import Terminal.PackageInstall
import Terminal.PackageUninstall
import Terminal.PackageOutdated
import Terminal.Paths
import Terminal.Init
import Compiler.Backend
import Compiler.PackageName as PackageName exposing (PackageName)
import Compiler.Paths
import Compiler.Outline as Outline exposing (Outline)
import Git
import Init
import Stream
import Stream.Log
import Task exposing (Task)
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import HttpClient
import Bytes exposing (Bytes)
import Terminal
import CLI.Parser
import CLI.PrettyPrinter as PP
import SemanticVersion exposing (SemanticVersion)
import Json.Encode as Json
import Stream.Extra


main : Node.Program Model Msg
main =
    Node.defineProgram
        { init = init
        , update = update
        , subscriptions = \_model -> Sub.none
        }


type alias Model = 
    { args : Array String
    , stdout : Stream.Writable Bytes
    , stderr : Stream.Writable Bytes
    , stdin : Stream.Readable Bytes
    , useColor : Bool
    , interactive : Bool
    , backendPath : Path
    , fsPermission : FileSystem.Permission
    , cpPermission : ChildProcess.Permission
    , httpPermission : HttpClient.Permission
    -- TODO: Remove
    , pathToString : Path -> String
    }

init : Node.Environment -> Init.Task { model : Model, command : Cmd Msg }
init env =
    Init.await FileSystem.initialize <| \fsPermission ->
    Init.await ChildProcess.initialize <| \cpPermission ->
    Init.await HttpClient.initialize <| \httpPermission ->
    Init.await Terminal.initialize <| \terminalConfig ->
    Init.awaitTask Node.getEnvironmentVariables <| \envVars ->
    Init.awaitTask (FileSystem.homeDirectory fsPermission) <| \homeDir ->
        let
            userArgs =
                Array.dropFirst 2 env.args

            interactiveTerminal =
                terminalConfig /= Nothing

            useColor =
                interactiveTerminal && not (Dict.member "NO_COLOR" envVars)

            maybePaths =
                when { platform = env.platform, override = Dict.get "GREN_BIN" envVars } is
                    { override = Just overridePath, platform = Node.Win32 } ->
                        Just <|
                            { remotePath = Nothing
                            , localPath = Path.fromWin32String overridePath
                            }
                    
                    { override = Just overridePath } ->
                        Just <|
                            { remotePath = Nothing
                            , localPath = Path.fromPosixString overridePath
                            }

                    _ ->
                        Compiler.Backend.downloadUrl env.platform env.cpuArchitecture
                            |> Result.map 
                                (\url ->
                                    { remotePath = Just url
                                    , localPath = Compiler.Backend.cachePath env.platform envVars homeDir
                                    }
                                )
                            |> Result.toMaybe

        in
        Node.startProgram
            { model =
                { args = userArgs
                , stdout = env.stdout
                , stderr = env.stderr
                , stdin = env.stdin
                , interactive = interactiveTerminal
                , useColor = useColor
                , backendPath =
                    when maybePaths is
                        Nothing ->
                            Compiler.Backend.cachePath env.platform envVars homeDir

                        Just paths ->
                            paths.localPath
                , fsPermission = fsPermission
                , cpPermission = cpPermission
                , httpPermission = httpPermission
                , pathToString =
                    if env.platform == Node.Win32 then
                        Path.toWin32String
                    else
                        Path.toPosixString
                }
            , command =
                when maybePaths is
                    Just paths ->
                        FileSystem.checkAccess fsPermission [] paths.localPath
                            |> Task.attempt 
                                (\result -> 
                                    ExistanceChecked
                                        { maybeRemotePath = paths.remotePath
                                        , localPath = paths.localPath
                                        , existanceResult = result
                                        }
                                )

                    Nothing ->
                        Stream.Log.line env.stderr "We currently don't support this platform/arch."
                            |> Task.execute
            }


type Msg
    = ExistanceChecked 
        { maybeRemotePath : Maybe String
        , localPath : Path
        , existanceResult : Result FileSystem.Error Path
        }
    | CompilerDownloaded 
        { localPath : Path
        , downloadResult : Result (HttpClient.Error Bytes) (HttpClient.Response Bytes)
        }
    | CompilerInstalled (Result FileSystem.Error Path)
    | CompilerInitialized { backendStreams : ChildProcess.StreamIO, encodedCommand : Bytes }
    | CompilerRan Int
    | CompilerRanStatic { path : String, exitCode : Int }


port completeStaticBuild : String -> Cmd msg


update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    { model = model
    , command =
        when msg is
            ExistanceChecked { maybeRemotePath, localPath, existanceResult = Err _ } ->
                when maybeRemotePath is
                    Just remotePath ->
                        Stream.Log.line model.stdout ("Compiler not found at " ++ model.pathToString localPath ++ ". Downloading...")
                            |> Task.andThen (\_ -> Compiler.Backend.download model.httpPermission remotePath)
                            |> Task.attempt (\result -> CompilerDownloaded { localPath = localPath, downloadResult = result })
            
                    Nothing ->
                        Stream.Log.line model.stderr ("Compiler not found at " ++ model.pathToString localPath)
                            |> Task.execute

            ExistanceChecked { existanceResult = Ok compilerPath } ->
                parseUserArgs model compilerPath

            CompilerDownloaded { localPath, downloadResult = Err ((HttpClient.BadStatus res) as err) } ->
                if res.statusCode == 302 then
                    when Dict.get "location" res.headers is
                        Just [ location ] ->
                            Compiler.Backend.download model.httpPermission location
                                |> Task.attempt (\result -> CompilerDownloaded { localPath = localPath, downloadResult = result })

                        _ ->
                            Stream.Log.line model.stderr "Missing, or vague, 'location' header in 302 response from server."
                                |> Task.execute

                else
                    Stream.Log.line model.stderr (HttpClient.errorToString err)
                        |> Task.execute
        
            CompilerDownloaded { downloadResult = Err err } ->
                Stream.Log.line model.stderr (HttpClient.errorToString err)
                    |> Task.execute
        
            CompilerDownloaded { localPath, downloadResult = Ok res } ->
                let
                    cacheFolder =
                        Path.parentPath localPath
                            |> Maybe.withDefault Path.empty
                in
                FileSystem.makeDirectory model.fsPermission { recursive = True } cacheFolder
                    |> Task.andThen (\_cacheFolder -> FileSystem.writeFile model.fsPermission res.data localPath)
                    |> Task.andThen 
                        (FileSystem.changeAccess
                            model.fsPermission
                            { owner = [ FileSystem.Read, FileSystem.Write, FileSystem.Execute ]
                            , group = [ FileSystem.Read, FileSystem.Execute ]
                            , others = [ FileSystem.Read, FileSystem.Execute ]
                            }
                        )
                    |> Task.andThen 
                        (\binPath -> 
                            Stream.Log.line model.stdout "Downloaded"
                                |> Task.map (\_ -> binPath)
                        )
                    |> Task.attempt CompilerInstalled
        
            CompilerInstalled (Err fsErr) ->
                Stream.Log.line model.stderr ("Failed to install binary after download, due to error: " ++ FileSystem.errorToString fsErr)
                    |> Task.execute
        
            CompilerInstalled (Ok compilerPath) ->
                parseUserArgs model compilerPath

            CompilerInitialized { backendStreams, encodedCommand } ->
                Stream.write encodedCommand backendStreams.input
                    |> Task.andThen (\_ -> Stream.closeWritable backendStreams.input)
                    |> Task.onError
                        (\streamErr ->
                            Stream.Log.line model.stderr ("Failed to send command to compiler backend due to error: " ++ Stream.errorToString streamErr)
                        )
                    |> Task.andThen
                        (\_ ->
                            backendStreams.output
                                |> Stream.awaitAndPipeThrough Stream.textDecoder
                                |> Task.andThen Stream.Extra.consumeString
                                |> Task.andThen (\str -> Stream.writeStringAsBytes str model.stdout)
                        )
                    |> Task.andThen
                        (\_ ->
                            backendStreams.error
                                |> Stream.awaitAndPipeThrough Stream.textDecoder
                                |> Task.andThen Stream.Extra.consumeString
                                |> Task.andThen (\str -> Stream.writeStringAsBytes str model.stderr)
                        )
                    |> Task.map (\_ -> {})
                    |> Task.onError
                        (\streamErr ->
                            Stream.Log.line model.stderr ("Something went wrong when reading from backend: " ++ Stream.errorToString streamErr)
                        )
                    |> Task.execute

            CompilerRan exitCode ->
                Node.exitWithCode exitCode
                    |> Task.execute
            
            CompilerRanStatic { path, exitCode } ->
                if exitCode == 0 then
                    completeStaticBuild path
                
                else
                    Node.exitWithCode exitCode
                        |> Task.execute
        }


parseUserArgs : Model -> Path -> Cmd Msg
parseUserArgs model compilerPath =
    let
        colorFilter =
            if model.useColor then
                identity

            else
                PP.stripColor

        prettyTextToTerminal doc =
            doc
                |> colorFilter
                |> PP.toStringWithOptions
                    { PP.defaultOptions | maxColumns = 80 }
    in
    when CLI.Parser.run model.args CliParser.parser is
        CLI.Parser.UnknownCommand commandName ->
            Stream.Log.line model.stderr ("I don't recognize this command: " ++ commandName)
                |> Task.execute
    
        CLI.Parser.BadFlags err ->
            err
                |> CLI.Parser.flagErrorPrettified
                |> prettyTextToTerminal
                |> Stream.Log.line model.stderr
                |> Task.execute
    
        CLI.Parser.BadArguments err ->
            err
                |> CLI.Parser.argumentErrorPrettified
                |> prettyTextToTerminal
                |> Stream.Log.line model.stderr
                |> Task.execute
    
        CLI.Parser.HelpText prettifiedText ->
            prettifiedText
                |> prettyTextToTerminal
                |> Stream.Log.line model.stdout
                |> Task.execute
    
        CLI.Parser.Success parsedCommand ->
            let
                initWithCommand backendCommand cpOpts =
                    when cpOpts.streams is
                        Nothing ->
                            -- TODO: error handling
                            Debug.todo "no stream for child process"

                        Just streams ->
                            CompilerInitialized
                                { backendStreams = streams
                                , encodedCommand =
                                    Compiler.Backend.encodeCommand
                                        { interactiveSession = model.interactive
                                        , pathToString = model.pathToString
                                        }
                                        backendCommand
                                }
            in
            when parsedCommand is
                CliParser.Init flags ->
                    Terminal.Init.run
                        { fsPermission = model.fsPermission
                        , cpPermission = model.cpPermission
                        , stdout = model.stdout
                        , stdin = model.stdin
                        , interactive = model.interactive
                        , useColor = model.useColor
                        , package = flags.package
                        , platform = flags.platform
                        }

                CliParser.Repl flags ->
                    -- TODO: DRY up package installation
                    Terminal.PackageInstall.readProjectOutline model.fsPermission
                        |> Task.mapError Debug.toString
                        |> Task.andThen
                            (\projectOutline ->
                                Terminal.PackageInstall.run
                                    { fsPermission = model.fsPermission
                                    , cpPermission = model.cpPermission
                                    , interactive = model.interactive
                                    , useColor = model.useColor
                                    , stdout = model.stdout
                                    , stdin = model.stdin
                                    }
                                    projectOutline
                                    |> Task.mapError Debug.toString
                            )
                        |> Task.map
                            (\resolved ->
                                Compiler.Backend.run
                                    model.cpPermission
                                    { useColor = model.useColor
                                    , compilerPath = compilerPath
                                    , pathToString = model.pathToString
                                    , onInit =
                                        initWithCommand <|
                                            Compiler.Backend.Repl
                                                { interpreter = flags.interpreter
                                                , projectPath = resolved.projectPath
                                                , outline = resolved.outline
                                                , rootSources = resolved.rootSources
                                                , dependencies = resolved.dependencies
                                                }
                                    , onComplete = CompilerRan
                                    }
                            )
                        |> Task.onError
                            (\err ->
                                Stream.Log.line model.stdout err
                                    |> Task.execute
                                    |> Task.succeed
                            )
                        |> Task.executeCmd

                CliParser.Make flags ->
                    Terminal.PackageInstall.readProjectOutline model.fsPermission
                        |> Task.andThen
                            (\projectOutline ->
                                Terminal.PackageInstall.run
                                    { fsPermission = model.fsPermission
                                    , cpPermission = model.cpPermission
                                    , interactive = model.interactive
                                    , useColor = model.useColor
                                    , stdout = model.stdout
                                    , stdin = model.stdin
                                    }
                                    projectOutline
                            )
                        |> Task.map
                            (\resolved ->
                                Compiler.Backend.run
                                    model.cpPermission
                                    { useColor = model.useColor
                                    , compilerPath = compilerPath
                                    , pathToString = model.pathToString
                                    , onInit = initWithCommand <|
                                        Compiler.Backend.Make
                                            { optimize = flags.optimize
                                            , sourcemaps = flags.sourcemaps
                                            , output = flags.output
                                            , report = flags.report
                                            , projectPath = resolved.projectPath
                                            , entryPoints = flags.entryPoints
                                            , outline = resolved.outline
                                            , rootSources = resolved.rootSources
                                            , dependencies = resolved.dependencies
                                            }
                                    , onComplete = CompilerRan
                                    }
                            )
                        |> Task.onError
                            (\err ->
                                Stream.Log.line model.stdout (Debug.toString err)
                                    |> Task.execute
                                    |> Task.succeed
                            )
                        |> Task.executeCmd

                CliParser.MakeStatic opts ->
                    Terminal.PackageInstall.readProjectOutline model.fsPermission
                        |> Task.mapError Debug.toString
                        |> Task.andThen
                            (\projectOutline ->
                                Terminal.PackageInstall.run
                                    { fsPermission = model.fsPermission
                                    , cpPermission = model.cpPermission
                                    , interactive = model.interactive
                                    , useColor = model.useColor
                                    , stdout = model.stdout
                                    , stdin = model.stdin
                                    }
                                    projectOutline
                                    |> Task.mapError Debug.toString
                            )
                        |> Task.map
                            (\resolved ->
                                Compiler.Backend.run
                                    model.cpPermission
                                    { useColor = model.useColor
                                    , compilerPath = compilerPath
                                    , pathToString = model.pathToString
                                    , onInit = initWithCommand <|
                                        Compiler.Backend.Make
                                            { optimize = True
                                            , sourcemaps = False
                                            , output = Just (Compiler.Backend.Exe <| model.pathToString opts.output)
                                            , report = Nothing
                                            , projectPath = resolved.projectPath
                                            , entryPoints = [ opts.source ]
                                            , outline = resolved.outline
                                            , rootSources = resolved.rootSources
                                            , dependencies = resolved.dependencies
                                            }
                                    , onComplete =
                                        (\exitCode ->
                                            CompilerRanStatic
                                                { path = model.pathToString opts.output
                                                , exitCode = exitCode
                                                }
                                        )
                                    }
                            )
                        |> Task.onError
                            (\err ->
                                Stream.Log.line model.stdout err
                                    |> Task.execute
                                    |> Task.succeed
                            )
                        |> Task.executeCmd

                CliParser.Docs flags ->
                    -- TODO: DRY up package installation
                    Terminal.PackageInstall.readProjectOutline model.fsPermission
                        |> Task.mapError Debug.toString
                        |> Task.andThen
                            (\projectOutline ->
                                Terminal.PackageInstall.run
                                    { fsPermission = model.fsPermission
                                    , cpPermission = model.cpPermission
                                    , interactive = model.interactive
                                    , useColor = model.useColor
                                    , stdout = model.stdout
                                    , stdin = model.stdin
                                    }
                                    projectOutline
                                    |> Task.mapError Debug.toString
                            )
                        |> Task.map
                            (\resolved ->
                                Compiler.Backend.run
                                    model.cpPermission
                                    { useColor = model.useColor
                                    , compilerPath = compilerPath
                                    , pathToString = model.pathToString
                                    , onInit =
                                        initWithCommand <|
                                            Compiler.Backend.Docs
                                                { output = flags.output
                                                , report = flags.report
                                                , projectPath = resolved.projectPath
                                                , outline = resolved.outline
                                                , rootSources = resolved.rootSources
                                                , dependencies = resolved.dependencies
                                                }
                                    , onComplete = CompilerRan
                                    }
                            )
                        |> Task.onError
                            (\err ->
                                Stream.Log.line model.stdout err
                                    |> Task.execute
                                    |> Task.succeed
                            )
                        |> Task.executeCmd

                CliParser.PackageInstall Nothing ->
                    Terminal.PackageInstall.readProjectOutline model.fsPermission
                        |> Task.andThen
                            (\projectOutline ->
                                Terminal.PackageInstall.run
                                    { fsPermission = model.fsPermission
                                    , cpPermission = model.cpPermission
                                    , interactive = model.interactive
                                    , useColor = model.useColor
                                    , stdout = model.stdout
                                    , stdin = model.stdin
                                    }
                                    projectOutline
                            )
                        |> Task.andThen
                            (\err ->
                                Stream.Log.line model.stdout "Done"
                            )
                        |> Task.onError
                            (\err ->
                                Stream.Log.line model.stdout (Debug.toString err)
                            )
                        |> Task.execute

                CliParser.PackageInstall (Just requestedPackage) ->
                    Terminal.PackageInstall.readProjectOutline model.fsPermission
                        |> Task.andThen
                            (\projectOutline ->
                                Terminal.PackageInstall.addPackage
                                    { fsPermission = model.fsPermission
                                    , cpPermission = model.cpPermission
                                    , interactive = model.interactive
                                    , useColor = model.useColor
                                    , stdout = model.stdout
                                    , stdin = model.stdin
                                    }
                                    projectOutline
                                    requestedPackage
                            )
                        |> Task.andThen
                            (\err ->
                                Stream.Log.line model.stdout "Done"
                            )
                        |> Task.onError
                            (\err ->
                                Stream.Log.line model.stdout (Debug.toString err)
                            )
                        |> Task.execute

                CliParser.PackageUninstall packageName ->
                    Terminal.PackageInstall.readProjectOutline model.fsPermission
                        |> Task.mapError Debug.toString
                        |> Task.andThen
                            (\projectOutline ->
                                Terminal.PackageUninstall.run
                                    { fsPermission = model.fsPermission
                                    , cpPermission = model.cpPermission
                                    , interactive = model.interactive
                                    , useColor = model.useColor
                                    , stdout = model.stdout
                                    , stdin = model.stdin
                                    }
                                    projectOutline
                                    packageName
                                    |> Task.mapError Debug.toString
                            )
                        |> Task.andThen
                            (\err ->
                                Stream.Log.line model.stdout "Done"
                            )
                        |> Task.onError
                            (\err ->
                                Stream.Log.line model.stdout (Debug.toString err)
                            )
                        |> Task.execute

                CliParser.PackageOutdated ->
                    Terminal.PackageInstall.readProjectOutline model.fsPermission
                        |> Task.mapError Debug.toString
                        |> Task.andThen
                            (\projectOutline ->
                                Terminal.PackageOutdated.run
                                    { fsPermission = model.fsPermission
                                    , cpPermission = model.cpPermission
                                    , interactive = model.interactive
                                    , useColor = model.useColor
                                    , stdout = model.stdout
                                    , stdin = model.stdin
                                    }
                                    projectOutline
                                    |> Task.mapError Debug.toString
                            )
                        |> Task.andThen
                            (\err ->
                                Stream.Log.line model.stdout "Done"
                            )
                        |> Task.onError
                            (\err ->
                                Stream.Log.line model.stdout (Debug.toString err)
                            )
                        |> Task.execute

                CliParser.PackageValidate ->
                    Terminal.PackageInstall.readProjectOutline model.fsPermission
                        |> Task.mapError Debug.toString
                        |> Task.andThen
                            (\projectOutline ->
                                Terminal.PackageInstall.run
                                    { fsPermission = model.fsPermission
                                    , cpPermission = model.cpPermission
                                    , interactive = model.interactive
                                    , useColor = model.useColor
                                    , stdout = model.stdout
                                    , stdin = model.stdin
                                    }
                                    projectOutline
                                    |> Task.mapError Debug.toString
                            )
                        |> Task.map
                            (\resolved ->
                                Compiler.Backend.run
                                    model.cpPermission
                                    { onInit =
                                        initWithCommand <|
                                            Compiler.Backend.PackageValidate
                                                { projectPath = resolved.projectPath
                                                , outline = resolved.outline
                                                , rootSources = resolved.rootSources
                                                , dependencies = resolved.dependencies
                                                }
                                    , useColor = model.useColor
                                    , compilerPath = compilerPath
                                    , pathToString = model.pathToString
                                    , onComplete = CompilerRan
                                    }
                            )
                        |> Task.onError
                            (\err ->
                                Stream.Log.line model.stdout err
                                    |> Task.execute
                                    |> Task.succeed
                            )
                        |> Task.executeCmd

                CliParser.PackageBump ->
                    Terminal.PackageInstall.readProjectOutline model.fsPermission
                        |> Task.mapError Debug.toString
                        |> Task.andThen
                            (\projectOutline ->
                                Terminal.PackageInstall.run
                                    { fsPermission = model.fsPermission
                                    , cpPermission = model.cpPermission
                                    , interactive = model.interactive
                                    , useColor = model.useColor
                                    , stdout = model.stdout
                                    , stdin = model.stdin
                                    }
                                    projectOutline
                                    |> Task.mapError Debug.toString
                            )
                        |> Task.map
                            (\resolved ->
                                Compiler.Backend.run
                                    model.cpPermission
                                    { onInit =
                                        initWithCommand <|
                                            Compiler.Backend.PackageBump
                                                { projectPath = resolved.projectPath
                                                , outline = resolved.outline
                                                , rootSources = resolved.rootSources
                                                , dependencies = resolved.dependencies
                                                }
                                    , useColor = model.useColor
                                    , compilerPath = compilerPath
                                    , pathToString = model.pathToString
                                    , onComplete = CompilerRan
                                    }
                            )
                        |> Task.onError
                            (\err ->
                                Stream.Log.line model.stdout err
                                    |> Task.execute
                                    |> Task.succeed
                            )
                        |> Task.executeCmd

                CliParser.PackageDiff args ->
                    Compiler.Backend.run
                        model.cpPermission
                        { onInit = initWithCommand <| Compiler.Backend.PackageDiff args
                        , useColor = model.useColor
                        , compilerPath = compilerPath
                        , pathToString = model.pathToString
                        , onComplete = CompilerRan
                        }

                CliParser.Paths opts ->
                    Terminal.Paths.run
                        { fsPermission = model.fsPermission
                        , stdout = model.stdout
                        , pathToString = model.pathToString
                        , backendPath = model.backendPath
                        }
                        opts

