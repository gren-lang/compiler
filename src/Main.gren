module Main exposing (main)

import Node
import ChildProcess
import Terminal.Parser as CliParser
import Terminal.PackageInstall
import Terminal.PackageUninstall
import Terminal.PackageOutdated
import Terminal.PackageBump
import Terminal.PackageDiff
import Terminal.PackageValidate
import Terminal.Paths
import Terminal.Init
import Terminal.Run
import Terminal.Help
import Compiler.Backend
import Compiler.PackageName as PackageName exposing (PackageName)
import Compiler.Paths
import Compiler.Outline as Outline exposing (Outline)
import Git
import Init
import Stream
import Stream.Log
import Task exposing (Task)
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import HttpClient
import Bytes exposing (Bytes)
import Terminal
import CLI.Parser
import CLI.PrettyPrinter as PP
import SemanticVersion exposing (SemanticVersion)
import Json.Encode as Json
import Stream.Extra
import Process


main : Node.Program Model Msg
main =
    Node.defineProgram
        { init = init
        , update = update
        , subscriptions = \_model -> Sub.none
        }


type alias Model = 
    { args : Array String
    , stdout : Stream.Writable Bytes
    , stderr : Stream.Writable Bytes
    , stdin : Stream.Readable Bytes
    , useColor : Bool
    , interactive : Bool
    , backendPath : Path
    , fsPermission : FileSystem.Permission
    , cpPermission : ChildProcess.Permission
    , httpPermission : HttpClient.Permission
    -- TODO: Remove
    , pathToString : Path -> String
    }

init : Node.Environment -> Init.Task { model : Model, command : Cmd Msg }
init env =
    Init.await FileSystem.initialize <| \fsPermission ->
    Init.await ChildProcess.initialize <| \cpPermission ->
    Init.await HttpClient.initialize <| \httpPermission ->
    Init.await Terminal.initialize <| \terminalConfig ->
    Init.awaitTask Node.getEnvironmentVariables <| \envVars ->
    Init.awaitTask (FileSystem.homeDirectory fsPermission) <| \homeDir ->
        let
            userArgs =
                Array.dropFirst 2 env.args

            interactiveTerminal =
                terminalConfig /= Nothing

            useColor =
                interactiveTerminal && not (Dict.member "NO_COLOR" envVars)

            maybePaths =
                when { platform = env.platform, override = Dict.get "GREN_BIN" envVars } is
                    { override = Just overridePath, platform = Node.Win32 } ->
                        Just <|
                            { remotePath = Nothing
                            , localPath = Path.fromWin32String overridePath
                            }
                    
                    { override = Just overridePath } ->
                        Just <|
                            { remotePath = Nothing
                            , localPath = Path.fromPosixString overridePath
                            }

                    _ ->
                        Compiler.Backend.downloadUrl env.platform env.cpuArchitecture
                            |> Result.map 
                                (\url ->
                                    { remotePath = Just url
                                    , localPath = Compiler.Backend.cachePath env.platform envVars homeDir
                                    }
                                )
                            |> Result.toMaybe

        in
        Node.startProgram
            { model =
                { args = userArgs
                , stdout = env.stdout
                , stderr = env.stderr
                , stdin = env.stdin
                , interactive = interactiveTerminal
                , useColor = useColor
                , backendPath =
                    when maybePaths is
                        Nothing ->
                            Compiler.Backend.cachePath env.platform envVars homeDir

                        Just paths ->
                            paths.localPath
                , fsPermission = fsPermission
                , cpPermission = cpPermission
                , httpPermission = httpPermission
                , pathToString =
                    if env.platform == Node.Win32 then
                        Path.toWin32String
                    else
                        Path.toPosixString
                }
            , command =
                when maybePaths is
                    Just paths ->
                        FileSystem.checkAccess fsPermission [] paths.localPath
                            |> Task.attempt 
                                (\result -> 
                                    ExistanceChecked
                                        { maybeRemotePath = paths.remotePath
                                        , localPath = paths.localPath
                                        , existanceResult = result
                                        }
                                )

                    Nothing ->
                        Stream.Log.line env.stderr "We currently don't support this platform/arch."
                            |> Task.execute
            }


type Msg
    = ExistanceChecked 
        { maybeRemotePath : Maybe String
        , localPath : Path
        , existanceResult : Result FileSystem.Error Path
        }
    | CompilerDownloaded 
        { localPath : Path
        , downloadResult : Result HttpClient.Error (HttpClient.Response Bytes)
        }
    | CompilerInstalled (Result FileSystem.Error Path)
    | CompilerInitialized { quiet : Bool, backendStreams : ChildProcess.StreamIO, encodedCommand : Bytes }
    | CompilerRan Int
    | CompiledForRun { path : String, exitCode : Int }
    | RunStarted Process.Id
    | RunExited Int
    | RedirectTerminalIO
        (Result
            { error : Stream.Error
            , source : Stream.Readable Bytes
            , target : Stream.Writable Bytes
            }
            { source : Stream.Readable Bytes
            , target : Stream.Writable Bytes
            }
        )


update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    { model = model
    , command =
        when msg is
            ExistanceChecked { maybeRemotePath, localPath, existanceResult = Err _ } ->
                when maybeRemotePath is
                    Just remotePath ->
                        Stream.Log.line model.stdout ("Compiler not found at " ++ model.pathToString localPath ++ ". Downloading...")
                            |> Task.andThen (\_ -> Compiler.Backend.download model.httpPermission remotePath)
                            |> Task.attempt (\result -> CompilerDownloaded { localPath = localPath, downloadResult = result })
            
                    Nothing ->
                        Stream.Log.line model.stderr ("Compiler not found at " ++ model.pathToString localPath)
                            |> Task.execute

            ExistanceChecked { existanceResult = Ok compilerPath } ->
                parseUserArgs model compilerPath

            CompilerDownloaded { localPath, downloadResult = Err ((HttpClient.BadStatus res) as err) } ->
                if res.statusCode == 302 then
                    when Dict.get "location" res.headers is
                        Just [ location ] ->
                            Compiler.Backend.download model.httpPermission location
                                |> Task.attempt (\result -> CompilerDownloaded { localPath = localPath, downloadResult = result })

                        _ ->
                            Stream.Log.line model.stderr "Missing, or vague, 'location' header in 302 response from server."
                                |> Task.execute

                else
                    Stream.Log.line model.stderr (HttpClient.errorToString err)
                        |> Task.execute
        
            CompilerDownloaded { downloadResult = Err err } ->
                Stream.Log.line model.stderr (HttpClient.errorToString err)
                    |> Task.execute
        
            CompilerDownloaded { localPath, downloadResult = Ok res } ->
                let
                    cacheFolder =
                        Path.parentPath localPath
                            |> Maybe.withDefault Path.empty
                in
                FileSystem.makeDirectory model.fsPermission { recursive = True } cacheFolder
                    |> Task.andThen (\_cacheFolder -> FileSystem.writeFile model.fsPermission res.data localPath)
                    |> Task.andThen 
                        (FileSystem.changeAccess
                            model.fsPermission
                            { owner = [ FileSystem.Read, FileSystem.Write, FileSystem.Execute ]
                            , group = [ FileSystem.Read, FileSystem.Execute ]
                            , others = [ FileSystem.Read, FileSystem.Execute ]
                            }
                        )
                    |> Task.andThen 
                        (\binPath -> 
                            Stream.Log.line model.stdout "Downloaded"
                                |> Task.map (\_ -> binPath)
                        )
                    |> Task.attempt CompilerInstalled
        
            CompilerInstalled (Err fsErr) ->
                Stream.Log.line model.stderr ("Failed to install binary after download, due to error: " ++ FileSystem.errorToString fsErr)
                    |> Task.execute
        
            CompilerInstalled (Ok compilerPath) ->
                parseUserArgs model compilerPath

            CompilerInitialized { backendStreams, encodedCommand, quiet } ->
                Cmd.batch
                    [ Stream.write encodedCommand backendStreams.input
                        |> Task.map (\_ -> { source = model.stdin, target = backendStreams.input })
                        |> Task.mapError
                            (\err ->
                                { error = err
                                , source = model.stdin
                                , target = backendStreams.input
                                }
                            )
                        |> Task.attempt RedirectTerminalIO
                    , if quiet then
                        Cmd.none
                      else
                        Task.succeed { source = backendStreams.output, target = model.stdout }
                            |> Task.attempt RedirectTerminalIO
                    , Task.succeed { source = backendStreams.error, target = model.stderr }
                        |> Task.attempt RedirectTerminalIO
                    ]

            CompilerRan exitCode ->
                Node.exitWithCode exitCode
            
            CompiledForRun { path, exitCode } ->
                if exitCode == 0 then
                    Terminal.Run.run 
                        { cpPermission = model.cpPermission
                        , fsPermission = model.fsPermission
                        , path = path
                        , onInit = RunStarted
                        , onExit = RunExited
                        }
                        |> Task.onError
                            (\error ->
                                -- TODO: Terminal.Run.errorToString
                                Stream.Log.line model.stderr (Debug.toString error)
                                    |> Task.map (\_ -> Node.exitWithCode 1)
                            )
                        |> Task.executeCmd

                else
                    Node.exitWithCode exitCode

            RunStarted _ ->
                Cmd.none

            RunExited exitCode ->
                Node.exitWithCode exitCode

            RedirectTerminalIO (Ok streams) ->
                Stream.read streams.source
                    |> Task.andThen (\str -> Stream.write str streams.target)
                    |> Task.map (\_ -> streams)
                    |> Task.mapError
                        (\err ->
                            { error = err
                            , source = streams.source
                            , target = streams.target
                            }
                        )
                    |> Task.attempt RedirectTerminalIO

            RedirectTerminalIO (Err { error, source, target }) ->
                when error is
                    Stream.Closed ->
                        Cmd.none

                    _ ->
                        Stream.Log.line model.stderr ("Something went wrong when communicating with compiler backend: " ++ Stream.errorToString error)
                            |> Task.execute
        }


parseUserArgs : Model -> Path -> Cmd Msg
parseUserArgs model compilerPath =
    let
        printOpts =
            { useColor = model.useColor
            }
    in
    when CLI.Parser.run model.args CliParser.parser is
        CLI.Parser.UnknownCommand commandName ->
            Stream.Log.line model.stderr ("I don't recognize this command: " ++ commandName)
                |> Task.execute
    
        CLI.Parser.BadFlags err ->
            err
                |> CLI.Parser.flagErrorPrettified
                |> Terminal.Help.prettyPrint printOpts
                |> Stream.Log.line model.stderr
                |> Task.execute
    
        CLI.Parser.BadArguments err ->
            err
                |> CLI.Parser.argumentErrorPrettified
                |> Terminal.Help.prettyPrint printOpts
                |> Stream.Log.line model.stderr
                |> Task.execute
    
        CLI.Parser.HelpText prettifiedText ->
            prettifiedText
                |> Terminal.Help.prettyPrint printOpts
                |> Stream.Log.line model.stdout
                |> Task.execute
    
        CLI.Parser.Success parsedCommand ->
            let
                initWithCommand backendCommand =
                    ChildProcess.External <| \cpOpts ->
                        CompilerInitialized
                            { backendStreams = cpOpts.streams
                            , quiet = False
                            , encodedCommand =
                                Compiler.Backend.encodeCommand
                                    { interactiveSession = model.interactive
                                    , pathToString = model.pathToString
                                    }
                                    backendCommand
                            }
            in
            when parsedCommand is
                CliParser.Init flags ->
                    Terminal.Init.run
                        { fsPermission = model.fsPermission
                        , cpPermission = model.cpPermission
                        , stdout = model.stdout
                        , stdin = model.stdin
                        , interactive = model.interactive
                        , useColor = model.useColor
                        , package = flags.package
                        , platform = flags.platform
                        }

                CliParser.Repl flags ->
                    -- TODO: create repl project when no project outline is found
                    Terminal.PackageInstall.readProjectOutline model.fsPermission
                        |> Task.mapError Terminal.PackageInstall.prettifyProjectOutlineError
                        |> Task.andThen
                            (\projectOutline ->
                                Terminal.PackageInstall.run
                                    { fsPermission = model.fsPermission
                                    , cpPermission = model.cpPermission
                                    , interactive = model.interactive
                                    , useColor = model.useColor
                                    , stdout = model.stdout
                                    , stdin = model.stdin
                                    }
                                    projectOutline
                                    |> Task.mapError Terminal.PackageInstall.prettifyError
                            )
                        |> Task.map
                            (\resolved ->
                                Compiler.Backend.run
                                    model.cpPermission
                                    { useColor = model.useColor
                                    , compilerPath = compilerPath
                                    , pathToString = model.pathToString
                                    , connection =
                                        initWithCommand <|
                                            Compiler.Backend.Repl
                                                { interpreter = flags.interpreter
                                                , projectPath = resolved.projectPath
                                                , outline = resolved.outline
                                                , rootSources = resolved.rootSources
                                                , dependencies = resolved.dependencies
                                                }
                                    , onComplete = CompilerRan
                                    }
                            )
                        |> Task.onError
                            (\err ->
                                Terminal.Help.prettyPrint printOpts err
                                    |> Stream.Log.string model.stderr
                                    |> Task.execute
                                    |> Task.succeed
                            )
                        |> Task.executeCmd

                CliParser.Make flags ->
                    -- TODO: Verify correct gren compiler version
                    resolveProject model
                        |> Task.map
                            (\resolved ->
                                Compiler.Backend.run
                                    model.cpPermission
                                    { useColor = model.useColor
                                    , compilerPath = compilerPath
                                    , pathToString = model.pathToString
                                    , connection = initWithCommand <|
                                        Compiler.Backend.Make
                                            { optimize = flags.optimize
                                            , sourcemaps = flags.sourcemaps
                                            , output = flags.output
                                            , report = flags.report
                                            , projectPath = resolved.projectPath
                                            , entryPoints = flags.entryPoints
                                            , outline = resolved.outline
                                            , rootSources = resolved.rootSources
                                            , dependencies = resolved.dependencies
                                            }
                                    , onComplete = CompilerRan
                                    }
                            )
                        |> Task.onError
                            (\err ->
                                Terminal.Help.prettyPrint printOpts err
                                    |> Stream.Log.string model.stderr
                                    |> Task.execute
                                    |> Task.succeed
                            )
                        |> Task.executeCmd

                CliParser.Run moduleName ->
                    Terminal.Run.make
                        { fsPermission = model.fsPermission
                        , cpPermission = model.cpPermission
                        , useColor = model.useColor
                        , compilerPath = compilerPath
                        , pathToString = model.pathToString
                        , moduleName = moduleName
                        , onBackendInitialized = 
                            (\{ backendStreams, encodedCommand } ->
                                CompilerInitialized
                                    { backendStreams = backendStreams
                                    , encodedCommand = encodedCommand
                                    , quiet = True
                                    }
                            )
                        , onCompiled = 
                            (\outputPath exitCode ->
                                CompiledForRun
                                    { path = model.pathToString outputPath
                                    , exitCode = exitCode
                                    }
                            )
                        }
                        |> Task.onError
                            (\err ->
                                Stream.Log.line model.stdout (Debug.toString err)
                                    |> Task.execute
                                    |> Task.succeed
                            )
                        |> Task.executeCmd

                CliParser.Docs flags ->
                    resolveProject model
                        |> Task.map
                            (\resolved ->
                                Compiler.Backend.run
                                    model.cpPermission
                                    { useColor = model.useColor
                                    , compilerPath = compilerPath
                                    , pathToString = model.pathToString
                                    , connection =
                                        initWithCommand <|
                                            Compiler.Backend.Docs
                                                { output = flags.output
                                                , report = flags.report
                                                , projectPath = resolved.projectPath
                                                , outline = resolved.outline
                                                , rootSources = resolved.rootSources
                                                , dependencies = resolved.dependencies
                                                }
                                    , onComplete = CompilerRan
                                    }
                            )
                        |> Task.onError
                            (\err ->
                                Terminal.Help.prettyPrint printOpts err
                                    |> Stream.Log.string model.stderr
                                    |> Task.execute
                                    |> Task.succeed
                            )
                        |> Task.executeCmd

                CliParser.PackageInstall Nothing ->
                    resolveProject model
                        |> Task.map (\_ -> {})
                        |> Task.onError
                            (\err ->
                                Terminal.Help.prettyPrint printOpts err
                                    |> Stream.Log.string model.stderr
                            )
                        |> Task.execute

                CliParser.PackageInstall (Just requestedPackage) ->
                    Terminal.PackageInstall.readProjectOutline model.fsPermission
                        |> Task.mapError Terminal.PackageInstall.prettifyProjectOutlineError
                        |> Task.andThen
                            (\projectOutline ->
                                Terminal.PackageInstall.addPackage
                                    { fsPermission = model.fsPermission
                                    , cpPermission = model.cpPermission
                                    , interactive = model.interactive
                                    , useColor = model.useColor
                                    , stdout = model.stdout
                                    , stdin = model.stdin
                                    }
                                    projectOutline
                                    requestedPackage
                                    |> Task.mapError Terminal.PackageInstall.prettifyAddPackageError
                                    |> Task.map (\_ -> {})
                            )
                        |> Task.onError
                            (\err ->
                                Terminal.Help.prettyPrint printOpts err
                                    |> Stream.Log.string model.stderr
                            )
                        |> Task.execute

                CliParser.PackageUninstall packageName ->
                    Terminal.PackageInstall.readProjectOutline model.fsPermission
                        |> Task.mapError Terminal.PackageInstall.prettifyProjectOutlineError
                        |> Task.andThen
                            (\projectOutline ->
                                Terminal.PackageUninstall.run
                                    { fsPermission = model.fsPermission
                                    , cpPermission = model.cpPermission
                                    , interactive = model.interactive
                                    , useColor = model.useColor
                                    , stdout = model.stdout
                                    , stdin = model.stdin
                                    }
                                    projectOutline
                                    packageName
                                    |> Task.mapError Terminal.PackageUninstall.prettifyError
                            )
                        |> Task.onError
                            (\err ->
                                Terminal.Help.prettyPrint printOpts err
                                    |> Stream.Log.string model.stderr
                            )
                        |> Task.execute

                CliParser.PackageOutdated ->
                    Terminal.PackageInstall.readProjectOutline model.fsPermission
                        |> Task.mapError Terminal.PackageInstall.prettifyProjectOutlineError
                        |> Task.andThen
                            (\projectOutline ->
                                Terminal.PackageOutdated.run
                                    { fsPermission = model.fsPermission
                                    , cpPermission = model.cpPermission
                                    , interactive = model.interactive
                                    , useColor = model.useColor
                                    , stdout = model.stdout
                                    , stdin = model.stdin
                                    }
                                    projectOutline
                                    |> Task.mapError Terminal.PackageOutdated.prettifyError
                            )
                        |> Task.onError
                            (\err ->
                                Terminal.Help.prettyPrint printOpts err
                                    |> Stream.Log.string model.stderr
                            )
                        |> Task.execute

                CliParser.PackageValidate ->
                    Terminal.PackageInstall.readProjectOutline model.fsPermission
                        |> Task.mapError Debug.toString
                        |> Task.andThen
                            (\projectOutline ->
                                Terminal.PackageValidate.run
                                    { fsPermission = model.fsPermission
                                    , cpPermission = model.cpPermission
                                    , interactive = model.interactive
                                    , useColor = model.useColor
                                    , stdout = model.stdout
                                    , stdin = model.stdin
                                    }
                                    projectOutline
                                    |> Task.mapError Debug.toString
                            )
                        |> Task.map
                            (\backendFlags ->
                                Compiler.Backend.run
                                    model.cpPermission
                                    { connection =
                                        initWithCommand <|
                                            Compiler.Backend.PackageValidate backendFlags
                                    , useColor = model.useColor
                                    , compilerPath = compilerPath
                                    , pathToString = model.pathToString
                                    , onComplete = CompilerRan
                                    }
                            )
                        |> Task.onError
                            (\err ->
                                Stream.Log.line model.stdout err
                                    |> Task.execute
                                    |> Task.succeed
                            )
                        |> Task.executeCmd

                CliParser.PackageBump ->
                    Terminal.PackageInstall.readProjectOutline model.fsPermission
                        |> Task.mapError Terminal.PackageInstall.prettifyProjectOutlineError
                        |> Task.andThen
                            (\projectOutline ->
                                Terminal.PackageBump.run
                                    { fsPermission = model.fsPermission
                                    , cpPermission = model.cpPermission
                                    , interactive = model.interactive
                                    , useColor = model.useColor
                                    , stdout = model.stdout
                                    , stdin = model.stdin
                                    }
                                    projectOutline
                                    |> Task.mapError Terminal.PackageBump.prettifyError
                            )
                        |> Task.map
                            (\backendFlags ->
                                Compiler.Backend.run
                                    model.cpPermission
                                    { connection =
                                        initWithCommand <|
                                            Compiler.Backend.PackageBump backendFlags
                                    , useColor = model.useColor
                                    , compilerPath = compilerPath
                                    , pathToString = model.pathToString
                                    , onComplete = CompilerRan
                                    }
                            )
                        |> Task.onError
                            (\err ->
                                Terminal.Help.prettyPrint printOpts err
                                    |> Stream.Log.string model.stderr
                                    |> Task.execute
                                    |> Task.succeed
                            )
                        |> Task.executeCmd

                CliParser.PackageDiff args ->
                    let
                        diffTask =
                            when args is
                                CliParser.DiffLatest ->
                                    Terminal.PackageDiff.runLocal
                                        { fsPermission = model.fsPermission
                                        , cpPermission = model.cpPermission
                                        , interactive = model.interactive
                                        , useColor = model.useColor
                                        , stdout = model.stdout
                                        , stdin = model.stdin
                                        }
                                        Nothing
                                        |> Task.mapError Debug.toString

                                CliParser.DiffVersion version ->
                                    Terminal.PackageDiff.runLocal
                                        { fsPermission = model.fsPermission
                                        , cpPermission = model.cpPermission
                                        , interactive = model.interactive
                                        , useColor = model.useColor
                                        , stdout = model.stdout
                                        , stdin = model.stdin
                                        }
                                        (Just version)
                                        |> Task.mapError Debug.toString

                                CliParser.DiffRange { lower, upper } ->
                                    Terminal.PackageInstall.readProjectOutline model.fsPermission
                                        |> Task.mapError Debug.toString
                                        |> Task.andThen
                                            (\{ outline } ->
                                                when outline is
                                                    Outline.App _ ->
                                                        -- TODO
                                                        Task.fail "Only supported on packages"

                                                    Outline.Pkg pkgOutline ->
                                                        Terminal.PackageDiff.runGlobal
                                                            { fsPermission = model.fsPermission
                                                            , cpPermission = model.cpPermission
                                                            , interactive = model.interactive
                                                            , useColor = model.useColor
                                                            , stdout = model.stdout
                                                            , stdin = model.stdin
                                                            }
                                                            pkgOutline.name
                                                            lower
                                                            upper
                                                            |> Task.mapError Debug.toString
                                            )

                                CliParser.DiffGlobal { package, lower, upper } ->
                                    Terminal.PackageDiff.runGlobal
                                        { fsPermission = model.fsPermission
                                        , cpPermission = model.cpPermission
                                        , interactive = model.interactive
                                        , useColor = model.useColor
                                        , stdout = model.stdout
                                        , stdin = model.stdin
                                        }
                                        package
                                        lower
                                        upper
                                        |> Task.mapError Debug.toString
                    in
                    diffTask
                        |> Task.map
                            (\backendFlags ->
                                Compiler.Backend.run
                                    model.cpPermission
                                    { connection =
                                        initWithCommand <|
                                            Compiler.Backend.PackageDiff backendFlags
                                    , useColor = model.useColor
                                    , compilerPath = compilerPath
                                    , pathToString = model.pathToString
                                    , onComplete = CompilerRan
                                    }
                            )
                        |> Task.onError
                            (\err ->
                                Stream.Log.line model.stdout err
                                    |> Task.execute
                                    |> Task.succeed
                            )
                        |> Task.executeCmd

                CliParser.Paths opts ->
                    Terminal.Paths.run
                        { fsPermission = model.fsPermission
                        , stdout = model.stdout
                        , pathToString = model.pathToString
                        , backendPath = model.backendPath
                        }
                        opts


resolveProject : Model -> Task PP.Document Terminal.PackageInstall.PackageResolution
resolveProject model =
    Terminal.PackageInstall.readProjectOutline model.fsPermission
        |> Task.mapError Terminal.PackageInstall.prettifyProjectOutlineError
        |> Task.andThen
            (\projectOutline ->
                Terminal.PackageInstall.run
                    { fsPermission = model.fsPermission
                    , cpPermission = model.cpPermission
                    , interactive = model.interactive
                    , useColor = model.useColor
                    , stdout = model.stdout
                    , stdin = model.stdin
                    }
                    projectOutline
                    |> Task.mapError Terminal.PackageInstall.prettifyError
            )
