port module Main exposing (main)

import Node
import ChildProcess
import Compiler.Backend
import Compiler.PackageName as PackageName exposing (PackageName)
import Compiler.Platform as Platform exposing (Platform)
import Compiler.Paths
import Compiler.Outline as Outline exposing (Outline)
import Compiler.Dependencies
import Init
import Stream
import Task exposing (Task)
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import HttpClient
import Bytes exposing (Bytes)
import Terminal
import Process
import CLI.Parser
import CLI.PrettyPrinter as PP
import SemanticVersion exposing (SemanticVersion)
import SemanticVersionRange exposing (SemanticVersionRange)
import Json.Encode as Json
import Json.Decode as Decode


main : Node.Program Model Msg
main =
    Node.defineProgram
        { init = init
        , update = update
        , subscriptions = \_model -> Sub.none
        }


type alias Model = 
    { args : Array String
    , stdout : Stream.Writable Bytes
    , stderr : Stream.Writable Bytes
    , useColor : Bool
    , interactive : Bool
    , backendPath : Path
    , fsPermission : FileSystem.Permission
    , cpPermission : ChildProcess.Permission
    , httpPermission : HttpClient.Permission
    , pathToString : Path -> String
    }


init : Node.Environment -> Init.Task { model : Model, command : Cmd Msg }
init env =
    Init.await FileSystem.initialize <| \fsPermission ->
    Init.await ChildProcess.initialize <| \cpPermission ->
    Init.await HttpClient.initialize <| \httpPermission ->
    Init.await Terminal.initialize <| \terminalConfig ->
    Init.awaitTask Node.getEnvironmentVariables <| \envVars ->
    Init.awaitTask (FileSystem.homeDirectory fsPermission) <| \homeDir ->
            let
                userArgs =
                    Array.dropFirst 2 env.args

                interactiveTerminal =
                    terminalConfig /= Nothing

                useColor =
                    interactiveTerminal && not (Dict.member "NO_COLOR" envVars)

                maybePaths =
                    when { platform = env.platform, override = Dict.get "GREN_BIN" envVars } is
                        { override = Just overridePath, platform = Node.Win32 } ->
                            Just <|
                                { remotePath = Nothing
                                , localPath = Path.fromWin32String overridePath
                                }
                        
                        { override = Just overridePath } ->
                            Just <|
                                { remotePath = Nothing
                                , localPath = Path.fromPosixString overridePath
                                }

                        _ ->
                            Compiler.Backend.downloadUrl env.platform env.cpuArchitecture
                                |> Result.map 
                                    (\url ->
                                        { remotePath = Just url
                                        , localPath = Compiler.Backend.cachePath env.platform envVars homeDir
                                        }
                                    )
                                |> Result.toMaybe

            in
            Node.startProgram
                { model =
                    { args = userArgs
                    , stdout = env.stdout
                    , stderr = env.stderr
                    , interactive = interactiveTerminal
                    , useColor = useColor
                    , backendPath =
                        when maybePaths is
                            Nothing ->
                                Compiler.Backend.cachePath env.platform envVars homeDir

                            Just paths ->
                                paths.localPath
                    , fsPermission = fsPermission
                    , cpPermission = cpPermission
                    , httpPermission = httpPermission
                    , pathToString =
                        if env.platform == Node.Win32 then
                            Path.toWin32String
                        else
                            Path.toPosixString
                    }
                , command =
                    when maybePaths is
                        Just paths ->
                            FileSystem.checkAccess fsPermission [] paths.localPath
                                |> Task.attempt 
                                    (\result -> 
                                        ExistanceChecked
                                            { maybeRemotePath = paths.remotePath
                                            , localPath = paths.localPath
                                            , existanceResult = result
                                            }
                                    )

                        Nothing ->
                            logLine env.stderr "We currently don't support this platform/arch."
                                |> Task.execute
                }


type Msg
    = NoOp
    | ExistanceChecked 
        { maybeRemotePath : Maybe String
        , localPath : Path
        , existanceResult : Result FileSystem.Error Path
        }
    | CompilerDownloaded 
        { localPath : Path
        , downloadResult : Result (HttpClient.Error Bytes) (HttpClient.Response Bytes)
        }
    | CompilerInstalled (Result FileSystem.Error Path)
    | CompilerRan Int
    | CompilerRanStatic { path : String, exitCode : Int }
    | InitiatePackageInstall (Result PackageInstallError { projectPath : Path, outline : Outline })
    | InstallPackages
        { projectPath : Path
        , outline : Outline
        , rootPackages : Array { name : PackageName, version : SemanticVersionRange }
        , loadedPackages : Dict String Outline
        , solvedPackages : Dict String Compiler.Dependencies.SimplifiedOutline
        }


type PackageInstallError
    = PackageInstallNoProject FileSystem.Error
    | PackageInstallNoGrenJson FileSystem.Error
    | PackageInstallInvalidGrenJson Decode.Error


port completeStaticBuild : String -> Cmd msg


update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    { model = model
    , command =
        when msg is
            NoOp ->
                Cmd.none

            ExistanceChecked { maybeRemotePath, localPath, existanceResult = Err _ } ->
                when maybeRemotePath is
                    Just remotePath ->
                        logLine model.stdout ("Compiler not found at " ++ model.pathToString localPath ++ ". Downloading...")
                            |> Task.andThen (\_ -> Compiler.Backend.download model.httpPermission remotePath)
                            |> Task.attempt (\result -> CompilerDownloaded { localPath = localPath, downloadResult = result })
            
                    Nothing ->
                        logLine model.stderr ("Compiler not found at " ++ model.pathToString localPath)
                            |> Task.execute

            ExistanceChecked { existanceResult = Ok compilerPath } ->
                parseUserArgs model compilerPath

            CompilerDownloaded { localPath, downloadResult = Err ((HttpClient.BadStatus res) as err) } ->
                if res.statusCode == 302 then
                    when Dict.get "location" res.headers is
                        Just [ location ] ->
                            Compiler.Backend.download model.httpPermission location
                                |> Task.attempt (\result -> CompilerDownloaded { localPath = localPath, downloadResult = result })

                        _ ->
                            logLine model.stderr "Missing, or vague, 'location' header in 302 response from server."
                                |> Task.execute

                else
                    logLine model.stderr (HttpClient.errorToString err)
                        |> Task.execute
        
            CompilerDownloaded { downloadResult = Err err } ->
                logLine model.stderr (HttpClient.errorToString err)
                    |> Task.execute
        
            CompilerDownloaded { localPath, downloadResult = Ok res } ->
                let
                    cacheFolder =
                        Path.parentPath localPath
                            |> Maybe.withDefault Path.empty
                in
                FileSystem.makeDirectory model.fsPermission { recursive = True } cacheFolder
                    |> Task.andThen (\_cacheFolder -> FileSystem.writeFile model.fsPermission res.data localPath)
                    |> Task.andThen 
                        (FileSystem.changeAccess
                            model.fsPermission
                            { owner = [ FileSystem.Read, FileSystem.Write, FileSystem.Execute ]
                            , group = [ FileSystem.Read, FileSystem.Execute ]
                            , others = [ FileSystem.Read, FileSystem.Execute ]
                            }
                        )
                    |> Task.andThen 
                        (\binPath -> 
                            logLine model.stdout "Downloaded"
                                |> Task.map (\_ -> binPath)
                        )
                    |> Task.attempt CompilerInstalled
        
            CompilerInstalled (Err fsErr) ->
                logLine model.stderr ("Failed to install binary after download, due to error: " ++ FileSystem.errorToString fsErr)
                    |> Task.execute
        
            CompilerInstalled (Ok compilerPath) ->
                parseUserArgs model compilerPath

            CompilerRan exitCode ->
                Node.exitWithCode exitCode
                    |> Task.execute
            
            CompilerRanStatic { path, exitCode } ->
                if exitCode == 0 then
                    completeStaticBuild path
                
                else
                    Node.exitWithCode exitCode
                        |> Task.execute

            InitiatePackageInstall (Err err) ->
                logLine model.stdout (Debug.toString msg)
                    |> Task.execute

            InitiatePackageInstall (Ok { projectPath, outline }) ->
                let
                    rootDeps =
                        when outline is
                            Outline.App appOutline ->
                                Dict.union
                                    appOutline.dependencies.direct
                                    appOutline.dependencies.indirect
                                    |> Dict.mapAndKeepJust extractVersion
                                    |> Dict.foldl
                                        (\key value acc ->
                                            Array.pushLast
                                                { name = PackageName.fromString key |> Maybe.withDefault PackageName.example
                                                , version = SemanticVersionRange.fromExact value
                                                }
                                                acc
                                        )
                                        []

                            Outline.Pkg pkgOutline ->
                                pkgOutline.dependencies
                                    |> Dict.mapAndKeepJust extractVersion
                                    |> Dict.foldl
                                        (\key value acc ->
                                            Array.pushLast
                                                { name = PackageName.fromString key |> Maybe.withDefault PackageName.example
                                                , version = value
                                                }
                                                acc
                                        )
                                        []
                                
                    extractVersion _name version =
                        when version is
                            Outline.Version vsn ->
                                Just vsn

                            Outline.LocalPath _ ->
                                Nothing
                in
                { projectPath = projectPath
                , outline = outline
                , rootPackages = rootDeps
                , loadedPackages = Dict.empty
                , solvedPackages = Dict.empty
                }
                    |> Task.succeed
                    |> Task.perform InstallPackages

            InstallPackages { projectPath, outline, rootPackages, loadedPackages, solvedPackages } ->
                when Compiler.Dependencies.solve rootPackages solvedPackages is
                    Compiler.Dependencies.Complete ->
                        "All done"
                            |> logLine model.stdout
                            |> Task.execute

                    Compiler.Dependencies.Missing { name, version } ->
                        let
                            lowerBound =
                                SemanticVersionRange.lowerBound version

                            bundlePath =
                                packageBundlePath name lowerBound projectPath

                            repoPath =
                                localRepoPath name lowerBound projectPath
                        in
                        gitClonePackage model.cpPermission repoPath name lowerBound
                            |> Task.mapError (\{ stderr } -> Maybe.withDefault "" <| Bytes.toString stderr)
                            |> Task.andThen (\{} ->
                                (Path.append (Path.fromPosixString "gren.json") repoPath)
                                    |> readOutline model.fsPermission
                                    |> Task.mapError FileSystem.errorToString
                                    |> Task.andThen
                                        (\decodeResult ->
                                            when decodeResult is
                                                Ok packageOutline ->
                                                    findSourceFiles model.fsPermission packageOutline repoPath
                                                        |> Task.mapError FileSystem.errorToString
                                                        |> Task.map
                                                            (\f ->
                                                                Array.map
                                                                    (\{ moduleName, source } ->
                                                                        { key = moduleName
                                                                        , value = Json.string source
                                                                        }
                                                                    )
                                                                    f
                                                                    |> Array.pushFirst
                                                                        { key = "gren.json"
                                                                        , value = Outline.toJson packageOutline
                                                                        }
                                                                    |> Json.object
                                                                    |> Json.encode 0
                                                            )

                                                Err err ->
                                                    Task.fail <| Debug.toString err
                                        )
                            )
                            |> Task.andThen
                                (\str ->
                                    let
                                        packagesDir =
                                            Path.append (Path.fromPosixString "gren_packages") projectPath
                                    in
                                    packagesDir
                                        |> FileSystem.makeDirectory model.fsPermission { recursive = False }
                                        |> Task.onError
                                            (\err ->
                                                if FileSystem.errorIsFileExists err then
                                                    Task.succeed packagesDir

                                                else
                                                    Task.fail err
                                            )
                                        |> Task.andThen (\_ -> FileSystem.writeFileStream model.fsPermission bundlePath)
                                        |> Task.mapError FileSystem.errorToString
                                        |> Task.andThen
                                            (\stream ->
                                                Stream.fromArray [ str ]
                                                    |> Task.andThen (Stream.awaitAndPipeThrough Stream.textEncoder)
                                                    |> Task.andThen (Stream.awaitAndPipeThrough Stream.gzipCompression)
                                                    |> Task.andThen (Stream.pipeTo stream)
                                                    |> Task.mapError Stream.errorToString
                                            )
                                )
                            |> Task.andThen (\_ -> logLine model.stdout "Done")
                            |> Task.onError (\err -> logLine model.stdout ("Error: " ++ err))
                            |> Task.execute

                    Compiler.Dependencies.Conflict _ ->
                        "TODO: CONFLICT"
                            |> logLine model.stdout
                            |> Task.execute
        }


packageBundlePath : PackageName -> SemanticVersion -> Path -> Path
packageBundlePath name version projectPath =
    let
        normalizedName =
            (PackageName.toString name ++ "__" ++ SemanticVersion.toString version)
                |> String.replace "-" "_"
                |> String.replace "." "_"
                |> String.replace "/" "_"
                |> String.append ".gz"
    in
    Path.join
        [ projectPath
        , Path.fromPosixString "gren_packages"
        , Path.fromPosixString normalizedName
        ]


localRepoPath : PackageName -> SemanticVersion -> Path -> Path
localRepoPath name version projectPath =
    let
        normalizedName =
            (PackageName.toString name ++ "__" ++ SemanticVersion.toString version)
                |> String.replace "-" "_"
                |> String.replace "." "_"
                |> String.replace "/" "_"
    in
    Path.join
        [ projectPath
        , Path.fromPosixString ".gren/git"
        , Path.fromPosixString normalizedName
        ]


gitClonePackage : ChildProcess.Permission -> Path -> PackageName -> SemanticVersion -> Task ChildProcess.FailedRun ChildProcess.SuccessfulRun
gitClonePackage cpPerm repo name version =
    let
        githubUrl =
            "https://github.com/" ++ PackageName.toString name ++ ".git"
    in
    ChildProcess.run
        cpPerm
        "git"
        [ "clone"
        , "--branch"
        , SemanticVersion.toString version
        , "--depth"
        , "1"
        , githubUrl
        , Path.toPosixString repo
        ]
        { shell = ChildProcess.NoShell
        , workingDirectory = ChildProcess.InheritWorkingDirectory
        , environmentVariables = ChildProcess.InheritEnvironmentVariables
        , maximumBytesWrittenToStreams = 4096
        , runDuration = ChildProcess.Milliseconds 30000
        }


findSourceFiles : FileSystem.Permission -> Outline -> Path -> Task FileSystem.Error (Array { moduleName : String, source : String })
findSourceFiles fsPerm outline outlinePath =
    let
        sourceDirs =
            when outline is
                Outline.App appOutline ->
                    appOutline.sourceDirectories

                Outline.Pkg _ ->
                    [ Path.fromPosixString "src"
                    ]
    in
    Array.map (\srcDir -> Path.append srcDir outlinePath) sourceDirs
        |> Array.map (findSourceFilesHelp fsPerm Path.empty)
        |> Task.sequence
        |> Task.map Array.flatten
        |> Task.andThen (\paths -> Task.sequence <| Array.map (readSourceFile fsPerm) paths)


findSourceFilesHelp : FileSystem.Permission -> Path -> Path -> Task FileSystem.Error (Array { absolute : Path, relative : Path })
findSourceFilesHelp fsPerm local root =
    FileSystem.listDirectory fsPerm root
        |> Task.andThen
            (\paths ->
                paths
                    |> Array.mapAndKeepJust
                        (\entry ->
                            when entry.entityType is
                                FileSystem.Directory ->
                                    Just <| findSourceFilesHelp fsPerm (Path.append entry.path local) (Path.append entry.path root)

                                FileSystem.File ->
                                    if entry.path.extension == "js" || entry.path.extension == "gren" then
                                        Just <| Task.succeed [ { absolute = Path.append entry.path root, relative = Path.append entry.path local } ]

                                    else
                                        Nothing

                                _ ->
                                    Nothing
                        )
                    |> Task.sequence
                    |> Task.map Array.flatten
            )


readSourceFile : FileSystem.Permission -> { absolute : Path, relative : Path } -> Task FileSystem.Error { moduleName : String, source : String }
readSourceFile fsPerm { absolute, relative } =
    FileSystem.readFile fsPerm absolute
        |> Task.map
            (\source ->
                { moduleName =
                    Path.toPosixString relative
                        |> String.dropLast (String.unitLength ".gren")
                        |> String.replace "/" "."
                , source =
                    -- Should be ok, as compile errors will be reported at a later stage
                    Bytes.toString source
                        |> Maybe.withDefault ""
                }
            )


parseUserArgs : Model -> Path -> Cmd Msg
parseUserArgs model compilerPath =
    let
        colorFilter =
            if model.useColor then
                identity

            else
                PP.stripColor

        prettyTextToTerminal doc =
            doc
                |> colorFilter
                |> PP.toStringWithOptions
                    { PP.defaultOptions | maxColumns = 80 }
    in
    when CLI.Parser.run model.args cliParser is
        CLI.Parser.UnknownCommand commandName ->
            logLine model.stderr ("I don't recognize this command: " ++ commandName)
                |> Task.execute
    
        CLI.Parser.BadFlags err ->
            err
                |> CLI.Parser.flagErrorPrettified
                |> prettyTextToTerminal
                |> logLine model.stderr
                |> Task.execute
    
        CLI.Parser.BadArguments err ->
            err
                |> CLI.Parser.argumentErrorPrettified
                |> prettyTextToTerminal
                |> logLine model.stderr
                |> Task.execute
    
        CLI.Parser.HelpText prettifiedText ->
            prettifiedText
                |> prettyTextToTerminal
                |> logLine model.stdout
                |> Task.execute
    
        CLI.Parser.Success parsedCommand ->
            when parsedCommand is
                PackageInstall ->
                    Compiler.Paths.projectRoot model.fsPermission
                        |> Task.mapError PackageInstallNoProject
                        |> Task.map (Path.append (Path.fromPosixString "gren.json"))
                        |> Task.andThen
                            (\grenJsonPath ->
                                readOutline model.fsPermission grenJsonPath
                                    |> Task.mapError PackageInstallNoGrenJson
                                    |> Task.andThen
                                        (\decodeResult ->
                                            when decodeResult is
                                                Ok outline ->
                                                    Task.succeed
                                                        { projectPath =
                                                            Path.parentPath grenJsonPath
                                                                |> Maybe.withDefault grenJsonPath
                                                        , outline = outline
                                                        }

                                                Err err ->
                                                    Task.fail (PackageInstallInvalidGrenJson err)
                                        )
                            )
                        |> Task.attempt InitiatePackageInstall

                Paths opts ->
                    when opts is
                        { project = False, packageCache = False, backend = False, json = False } ->
                            Compiler.Paths.projectRoot model.fsPermission
                                |> Task.andThen
                                    (\project ->
                                        [ "project: " ++ model.pathToString project
                                        , "package-cache: " ++ model.pathToString (Path.append (Path.fromPosixString "gren_packages") project)
                                        , "backend: " ++ model.pathToString model.backendPath
                                        ]
                                            |> String.join "\n"
                                            |> logLine model.stdout
                                    )
                                |> Task.onError (\_ -> logLine model.stdout "Couldn't find project!")
                                |> Task.execute

                        { project = False, packageCache = False, backend = False, json = True } ->
                            Compiler.Paths.projectRoot model.fsPermission
                                |> Task.andThen
                                    (\project ->
                                        Json.object
                                            [ { key = "project", value = Json.string (model.pathToString project) }
                                            , { key = "packageCache", value = Json.string (model.pathToString (Path.append (Path.fromPosixString "gren_packages") project)) }
                                            , { key = "backend", value = Json.string (model.pathToString model.backendPath) }
                                            ]
                                            |> Json.encode 4
                                            |> logLine model.stdout
                                    )
                                |> Task.onError (\_ -> logLine model.stdout "Couldn't find project!")
                                |> Task.execute

                        { project = True, packageCache = False, backend = False, json = False } ->
                            Compiler.Paths.projectRoot model.fsPermission
                                |> Task.andThen
                                    (\project ->
                                        logLine model.stdout (model.pathToString project)
                                    )
                                |> Task.onError (\_ -> logLine model.stdout "Couldn't find project!")
                                |> Task.execute

                        { project = True, packageCache = False, backend = False, json = True } ->
                            Compiler.Paths.projectRoot model.fsPermission
                                |> Task.andThen
                                    (\project ->
                                        Json.object
                                            [ { key = "project", value = Json.string (model.pathToString project) }
                                            ]
                                            |> Json.encode 4
                                            |> logLine model.stdout
                                    )
                                |> Task.onError (\_ -> logLine model.stdout "Couldn't find project!")
                                |> Task.execute

                        { project = False, packageCache = True, backend = False, json = False } ->
                            Compiler.Paths.projectRoot model.fsPermission
                                |> Task.andThen
                                    (\project ->
                                         model.pathToString (Path.append (Path.fromPosixString "gren_packages") project)
                                            |> logLine model.stdout
                                    )
                                |> Task.onError (\_ -> logLine model.stdout "Couldn't find project!")
                                |> Task.execute

                        { project = False, packageCache = True, backend = False, json = True } ->
                            Compiler.Paths.projectRoot model.fsPermission
                                |> Task.andThen
                                    (\project ->
                                        Json.object
                                            [ { key = "packageCache", value = Json.string (model.pathToString (Path.append (Path.fromPosixString "gren_packages") project)) }
                                            ]
                                            |> Json.encode 4
                                            |> logLine model.stdout
                                    )
                                |> Task.onError (\_ -> logLine model.stdout "Couldn't find project!")
                                |> Task.execute

                        { project = False, packageCache = False, backend = True, json = False } ->
                            logLine model.stdout (model.pathToString model.backendPath)
                                |> Task.execute

                        { project = False, packageCache = False, backend = True, json = True } ->
                            Json.object
                                [ { key = "backend", value = Json.string (model.pathToString model.backendPath) }
                                ]
                                |> Json.encode 4
                                |> logLine model.stdout
                                |> Task.execute

                        _ ->
                            logLine model.stdout "You can only use one of --project, --package-cache and --backend!"
                                |> Task.execute

                MakeStatic opts ->
                    Compiler.Backend.run
                        model.cpPermission
                        { command =
                            Compiler.Backend.Make
                                { flags =
                                    { optimize = True
                                    , sourcemaps = False
                                    , output = Just (Compiler.Backend.Exe <| model.pathToString opts.output)
                                    , report = Nothing
                                    }
                                , paths =
                                    [ opts.source ]
                                }
                        , interactiveSession = model.interactive
                        , useColor = model.useColor
                        , compilerPath = compilerPath
                        , pathToString = model.pathToString
                        , onInit = (\_ -> NoOp)
                        , onComplete =
                            (\exitCode ->
                                CompilerRanStatic
                                    { path = model.pathToString opts.output
                                    , exitCode = exitCode
                                    }
                            )
                        }

                CompilerCommand cmd ->
                    Compiler.Backend.run
                        model.cpPermission
                        { command = cmd
                        , interactiveSession = model.interactive
                        , useColor = model.useColor
                        , compilerPath = compilerPath
                        , pathToString = model.pathToString
                        , onInit = (\_ -> NoOp)
                        , onComplete = CompilerRan
                        }


readOutline : FileSystem.Permission -> Path -> Task FileSystem.Error (Result Decode.Error Outline)
readOutline fsPerm path =
    FileSystem.readFile fsPerm path
        |> Task.map (Bytes.toString >> Maybe.withDefault "")
        |> Task.map (Decode.decodeString Outline.jsonDecoder)


logLine : Stream.Writable Bytes -> String -> Task x (Stream.Writable Bytes)
logLine stream line =
    Stream.writeLineAsBytes line stream
        |> Task.onError (\_ -> Task.succeed stream)


logBytes : Stream.Writable Bytes -> Bytes -> Task x (Stream.Writable Bytes)
logBytes stream bytes =
    Stream.write bytes stream
        |> Task.onError (\_ -> Task.succeed stream)


-- CLI Parsing


type ParsedCommand
    = MakeStatic MakeStaticOpts
    | CompilerCommand Compiler.Backend.Command
    | PackageInstall
    | Paths
        { project : Bool
        , packageCache : Bool
        , backend : Bool
        , json : Bool
        }


type alias MakeStaticOpts =
    { output : Path
    , source : Path
    }


cliParser : CLI.Parser.App ParsedCommand
cliParser =
    { name = "gren"
    , version = "0.5.4"
    , intro = 
        PP.verticalBlock
            [ PP.block
                [ PP.text "Hi, thank you for trying out "
                , PP.intenseColor PP.Green <| PP.text ("Gren " ++ Compiler.Backend.version)
                , PP.text ". I hope you like it!"
                ]
            , PP.empty
            , PP.intenseColor PP.Black <|
                PP.text
                    """
                    -------------------------------------------------------------------------------
                    I highly recommend working through <https://gren-lang.org/learn> to get started
                    It teaches many important concepts, including how to use `gren` in the terminal
                    -------------------------------------------------------------------------------
                    """
            ]
    , outro = 
        PP.words
            """
            Be sure to ask on the Gren Discord (https://discord.gg/Chb9YB9Vmh) if you run into trouble!
            Folks are friendly and happy to help out. They hang out there because it is fun, so be kind
            to get the best results!
            """
    , commands =
        CLI.Parser.defineGroup
            |> CLI.Parser.withCommand
                { word = "init"
                , arguments =
                    CLI.Parser.noArgs
                , flags =
                    CLI.Parser.initFlags 
                        (\package maybePlatform ->
                            { package = package
                            , platform = 
                                if package then
                                    Maybe.withDefault Platform.Common maybePlatform

                                else
                                    Maybe.withDefault Platform.Browser maybePlatform
                            }
                        )
                        |> CLI.Parser.toggle "package" "Create a package (as opposed to an application)"
                        |> CLI.Parser.flag "platform" initPlatformParser "Which platform to target"
                , commonDescription =
                    Just "Start a Gren project. It creates a starter gren.json file."
                , summary =
                    "The `init` command helps start Gren project:"
                , example = 
                    PP.words
                        """
                        It will ask permission to create a gren.json file, the one thing
                        common to all Gren project.
                        """
                , builder =
                    \_args flags -> CompilerCommand <| Compiler.Backend.Init flags
                }
            |> CLI.Parser.withCommand
                { word = "repl"
                , arguments =
                    CLI.Parser.noArgs
                , flags =
                    CLI.Parser.initFlags
                        (\maybeInterpreter ->
                            { interpreter = maybeInterpreter
                            }
                        )
                        |> CLI.Parser.flag "interpreter" interpreterParser "Path to a alternate JS interpreter, like deno or nodejs"
                , commonDescription =
                    Just 
                        """
                        Open up an interactive programming session. Type in Gren expressions like
                        (2 + 2) or (String.length \"test\") and see if they equal four!
                        """
                , summary =
                    "The `repl` command opens up an interactive programming session:"
                , example = 
                    PP.words
                        """
                        Start working through <https://gren-lang.org/learn> to learn how to use this!
                        It has a whole chapter that uses the REPL for everything, so that is probably
                        the quickest way to get started.
                        """
                , builder =
                    \_args flags -> CompilerCommand <| Compiler.Backend.Repl flags
                }
            |> CLI.Parser.withCommand
                { word = "paths"
                , arguments =
                    CLI.Parser.noArgs
                , flags =
                    CLI.Parser.initFlags
                        (\project packageCache backend json ->
                            { project = project
                            , packageCache = packageCache
                            , backend = backend
                            , json = json
                            }
                        )
                        |> CLI.Parser.toggle "project" "Only output the path to the project"
                        |> CLI.Parser.toggle "package-cache" "Only output the path to the package cache"
                        |> CLI.Parser.toggle "backend" "Only output the path to the compiler backend"
                        |> CLI.Parser.toggle "json" "Output in JSON format"
                , commonDescription = Nothing
                , summary =
                    "Return the paths used for compiling a project."
                , example = 
                    PP.verticalBlock
                        [ PP.words "For example:"
                        , PP.empty
                        , PP.words "gren paths --backend"
                            |> PP.indent
                            |> PP.color PP.Green
                        , PP.empty
                        , PP.words
                            """
                            This will write the path to the compiler backend.
                            Executing the command without any flags will print _all_ relevant paths.
                            """
                        ]
                , builder =
                    \_args flags -> Paths flags
                }
            |> CLI.Parser.withCommand
                { word = "make"
                , arguments =
                    CLI.Parser.zeroOrMoreArgs CLI.Parser.grenFileParser
                , flags =
                    CLI.Parser.initFlags 
                        (\optimize sourcemaps output report ->
                            { optimize = optimize
                            , sourcemaps = sourcemaps
                            , output = output
                            , report = report
                            }
                        )
                        |> CLI.Parser.toggle "optimize" "Turn on optimizations to make code smaller and faster. For example, the compiler renames record fields to be as short as possible and unboxes values to reduce allocation."
                        |> CLI.Parser.toggle "sourcemaps" "Add sourcemaps to the resulting JS file. This let's you debug Gren code in a JS debugger, at the cost of longer compile times and a bigger JS file."
                        |> CLI.Parser.flag "output" outputParser "Specify the name of the resulting JS file. For example --output=assets/gren.js to generate the JS at assets/gren.js. You can also use --output=/dev/stdout to output the JS to the terminal, or --output=/dev/null to generate no output at all!"
                        |> CLI.Parser.flag "report" reportParser "You can say --report=json to get error messages as JSON. This is only really useful if you are an editor plugin. Humans should avoid it!"
                , commonDescription =
                    Nothing
                , summary =
                    "The `make` command compiles Gren code into JS or HTML:"
                , example = 
                    PP.verticalBlock
                        [ PP.words "For example:"
                        , PP.empty
                        , PP.words "gren make src/Main.gren"
                            |> PP.indent
                            |> PP.color PP.Green
                        , PP.empty
                        , PP.words
                            """
                            This tries to compile an Gren file named src/Main.gren, generating an index.html
                            file if possible.
                            """
                        ]
                , builder =
                    \args flags -> CompilerCommand <| Compiler.Backend.Make { flags = flags, paths = args }
                }
            |> CLI.Parser.withCommand
                { word = "make-static"
                , arguments =
                    CLI.Parser.twoArgs 
                        (\source output ->
                            { source = source
                            , output = output
                            }
                        )
                        CLI.Parser.grenFileParser
                        CLI.Parser.pathParser
                , flags =
                    CLI.Parser.noFlags
                , commonDescription =
                    Nothing
                , summary =
                    "The `make-static` command compiles Gren code into a self-contained executable:"
                , example = 
                    PP.verticalBlock
                        [ PP.words "For example:"
                        , PP.empty
                        , PP.words "gren make-static src/Main.gren app"
                            |> PP.indent
                            |> PP.color PP.Green
                        , PP.empty
                        , PP.words
                            """
                            This tries to compile a Gren file named `src/Main.gren`, generating an `app`
                            file if possible. `app` is a static executable that can be run even if `node` is
                            not installed on the system.
                            """
                        ]
                , builder =
                    \args _flags -> MakeStatic args
                }
            |> CLI.Parser.withCommand
                { word = "docs"
                , arguments =
                    CLI.Parser.noArgs
                , flags =
                    CLI.Parser.initFlags 
                        (\output report ->
                            { output = output
                            , report = report
                            }
                        )
                        |> CLI.Parser.flag "output" docsOutputParser "Specify the name of the resulting JSON file. For example --output=assets/docs.json to generate the JSON at assets/docs.json. You can also use --output=/dev/stdout to output the JSON to the terminal, or --output=/dev/null to verify that generating the documentation would work."
                        |> CLI.Parser.flag "report" reportParser "You can say --report=json to get error messages as JSON. This is only really useful if you are an editor plugin. Humans should avoid it!"
                , commonDescription =
                    Nothing
                , summary =
                    "The `docs` command collects all documentation for a package in a JSON file:"
                , example = 
                    PP.verticalBlock
                        [ PP.words "For example:"
                        , PP.words "gren docs"
                            |> PP.indent
                            |> PP.color PP.Green
                        , PP.words
                            """
                            This collects all documentation for the current pacage and writes it to a
                            docs.json file, if possible.
                            """
                        ]
                , builder =
                    \_args flags -> CompilerCommand <| Compiler.Backend.Docs flags
                }
            |> CLI.Parser.withPrefix "package" packageCommands
    }


packageCommands : CLI.Parser.GroupParser ParsedCommand
packageCommands =
    CLI.Parser.defineGroup
        |> CLI.Parser.withCommand
            { word = "install"
            , arguments =
                CLI.Parser.oneOfArgs
                    [ CLI.Parser.noArgs
                        |> CLI.Parser.mapArgs (\_ -> Nothing)
                    , CLI.Parser.oneArg PackageName.cliParser
                        |> CLI.Parser.mapArgs Just
                    ]
            , flags =
                CLI.Parser.noFlags 
            , commonDescription =
                Nothing
            , summary =
                "The `install` command fetches packages from github for use in your project:"
            , example = 
                PP.verticalBlock
                    [ PP.words 
                        """
                        For example, if you want to get access to Web APIs in your project,
                        you would say:
                        """
                    , PP.empty
                    , PP.text "gren package install gren-lang/browser"
                        |> PP.indent
                        |> PP.color PP.Green
                    , PP.empty
                    , PP.words
                        """
                        Notice that you must say the AUTHOR name and PROJECT name! After running those
                        commands, you could say `import Browser` in your code.
                        """
                    , PP.empty
                    , PP.words
                        """
                        You can also call this command without any arguments to download all dependencies
                        listed in gren.json. This can be helpful in Continous Integration setups where
                        you want to cache dependencies between builds.
                        """
                    ]
            , builder =
                \arg _flags ->
                    when arg is
                        Nothing ->
                            PackageInstall

                        Just _ ->
                            CompilerCommand <| Compiler.Backend.PackageInstall arg
            }
        |> CLI.Parser.withCommand
            { word = "uninstall"
            , arguments =
                CLI.Parser.oneArg PackageName.cliParser
            , flags =
                CLI.Parser.noFlags 
            , commonDescription =
                Nothing
            , summary =
                "The `uninstall` command removes packages from your project:"
            , example = 
                PP.verticalBlock
                    [ PP.words 
                        """
                        For example, if you want to get rid of the browser package in your project,
                        you would say:
                        """
                    , PP.empty
                    , PP.text "gren package uninstall gren-lang/browser"
                        |> PP.indent
                        |> PP.color PP.Green
                    , PP.empty
                    , PP.words 
                        """
                        Notice that you must say the AUTHOR name and PROJECT name!
                        """
                    , PP.empty
                    , PP.words
                        """
                        What if another package depends on the package you're trying to remove? No problem!
                        I'll let you know if that's the case, and help you resolve the situation. 
                        """
                    ]
            , builder =
                \arg _flags -> CompilerCommand <| Compiler.Backend.PackageUninstall arg
            }
        |> CLI.Parser.withCommand
            { word = "outdated"
            , arguments =
                CLI.Parser.noArgs
            , flags =
                CLI.Parser.noFlags 
            , commonDescription =
                Nothing
            , summary =
                "The `outdated` command lists the latest version of your dependencies,"
                    ++ " if you're not already up to date:"
            , example = 
                PP.text "gren package outdated"
                    |> PP.indent
                    |> PP.color PP.Green
            , builder =
                \_args _flags -> CompilerCommand Compiler.Backend.PackageOutdated
            }
        |> CLI.Parser.withCommand
            { word = "validate"
            , arguments =
                CLI.Parser.noArgs
            , flags =
                CLI.Parser.noFlags 
            , commonDescription =
                Nothing
            , summary =
                "The `validate` command checks that you've done everything necessary for"
                    ++ " others in the Gren community to use your package as a dependency:"
            , example = 
                PP.verticalBlock
                    [ PP.words 
                        """
                        Gren packages are \"just\" git repositories hosted on github. As
                        long as you've tagged your repository with semver formatted tags,
                        anyone can add your package as a dependency.
                        """
                    , PP.empty
                    , PP.words 
                        """
                        However, a package is no better than its documentation. This command
                        therefore checks that your package exposes a bare minimum of
                        prose that the users of your package can read.
                        """
                    , PP.empty
                    , PP.words
                        """
                        Keep in mind, you don't just want to tell people HOW to use
                        your package. It's equally important to tell them WHY. What
                        problem does it solve? Why should people use this particular
                        package to solve their problem?
                        """
                    , PP.empty
                    , PP.words
                        """
                        Once this command passes, you may want to add your repo to
                        <https://packages.gren-lang.org> so it becomes easier for the Gren
                        community to find your package, and its documentation.
                        """
                    ]
            , builder =
                \_args _flags -> CompilerCommand Compiler.Backend.PackageValidate
            }
        |> CLI.Parser.withCommand
            { word = "bump"
            , arguments =
                CLI.Parser.noArgs
            , flags =
                CLI.Parser.noFlags 
            , commonDescription =
                Nothing
            , summary =
                "The `bump` command figures out the next version number based on API changes:"
            , example = 
                PP.words 
                    """
                    Say you just published version 1.0.0, but then decided to remove a function.
                    I will compare the published API to what you have locally, figure out that
                    it is a MAJOR change, and bump your version number to 2.0.0. I do this with
                    all packages, so there cannot be MAJOR changes hiding in PATCH releases in Gren!
                    """
            , builder =
                \_args _flags -> CompilerCommand Compiler.Backend.PackageBump
            }
        |> CLI.Parser.withCommand
            { word = "diff"
            , arguments =
                CLI.Parser.oneOfArgs
                    [ CLI.Parser.noArgs
                        |> CLI.Parser.mapArgs (\{} -> Compiler.Backend.DiffLatest)
                    , CLI.Parser.oneArg SemanticVersion.cliParser
                        |> CLI.Parser.mapArgs Compiler.Backend.DiffVersion
                    , CLI.Parser.twoArgs
                        (\lower upper ->
                            Compiler.Backend.DiffRange
                                { lower = lower
                                , upper = upper
                                }
                        )
                        SemanticVersion.cliParser
                        SemanticVersion.cliParser
                    , CLI.Parser.threeArgs
                        (\package lower upper ->
                            Compiler.Backend.DiffGlobal
                                { package = package
                                , lower = lower
                                , upper = upper
                                }
                        )
                        PackageName.cliParser
                        SemanticVersion.cliParser
                        SemanticVersion.cliParser
                    ]
            , flags =
                CLI.Parser.noFlags 
            , commonDescription =
                Nothing
            , summary =
                "The `diff` command detects API changes:"
            , example = 
                PP.verticalBlock
                    [ PP.words 
                        """
                        For example, to see what changed in the Browser package between
                        versions 1.0.0 and 2.0.0, you can say:
                        """
                    , PP.empty
                    , PP.text "gren package diff gren-lang/browser 1.0.0 2.0.0"
                        |> PP.indent
                        |> PP.color PP.Green
                    , PP.empty
                    , PP.words 
                        """
                        Sometimes a MAJOR change is not actually very big, so
                        this can help you plan your upgrade timelines.
                        """
                    ]
            , builder =
                \args _flags -> CompilerCommand <| Compiler.Backend.PackageDiff args
            }


initPlatformParser : CLI.Parser.ValueParser Platform
initPlatformParser =
    { singular = "platform"
    , plural = "platforms"
    , fn = \str ->
        when str is
            "common" -> Just Platform.Common
            "browser" -> Just Platform.Browser
            "node" -> Just Platform.Node
            _ -> Nothing
    , examples =
        [ "common"
        , "browser"
        , "node"
        ]
    }


reportParser : CLI.Parser.ValueParser {}
reportParser =
    { singular = "report-type"
    , plural = "report-types"
    , fn = \str ->
        if str == "json" then
            Just {}

        else
            Nothing
    , examples =
        [ "json" ]
    }


interpreterParser : CLI.Parser.ValueParser String
interpreterParser =
    { singular = "interpreter"
    , plural = "interpreters"
    , fn = Just
    , examples =
        [ "node"
        , "deno"
        , "bun"
        ]
    }


outputParser : CLI.Parser.ValueParser Compiler.Backend.MakeOutput
outputParser =
    { singular = "output-file"
    , plural = "output-files"
    , fn = \str ->
        when str is
            "/dev/stdout" -> Just Compiler.Backend.StdOut
            "/dev/null" -> Just Compiler.Backend.DevNull
            "NUL" -> Just Compiler.Backend.DevNull
            "$null" -> Just Compiler.Backend.DevNull
            _ ->
                if String.endsWith ".html" str then
                    Just <| Compiler.Backend.Html str
                
                else if String.endsWith ".js" str then
                    Just <| Compiler.Backend.Js str

                else
                    Just <| Compiler.Backend.Exe str
    , examples =
        [ "/dev/stdout"
        , "/dev/null"
        , "index.html"
        , "index.js"
        , "app"
        ]
    }


docsOutputParser : CLI.Parser.ValueParser Compiler.Backend.DocsOutput
docsOutputParser =
    { singular = "output-file"
    , plural = "output-files"
    , fn = \str ->
        when str is
            "/dev/stdout" -> Just Compiler.Backend.DocsStdOut
            "/dev/null" -> Just Compiler.Backend.DocsDevNull
            "NUL" -> Just Compiler.Backend.DocsDevNull
            "$null" -> Just Compiler.Backend.DocsDevNull
            _ ->
                if String.endsWith ".json" str then
                    Just <| Compiler.Backend.DocsJson str

                else
                    Nothing
    , examples =
        [ "/dev/stdout"
        , "/dev/null"
        , "docs.json"
        ]
    }
