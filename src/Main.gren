port module Main exposing (main)

import Node
import ChildProcess
import CliParser
import Compiler.Backend
import Compiler.PackageName as PackageName exposing (PackageName)
import Compiler.Platform as Platform exposing (Platform)
import Compiler.Paths
import Compiler.Outline as Outline exposing (Outline)
import Compiler.Dependencies
import Git
import Init
import Stream
import Stream.Log
import Task exposing (Task)
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import HttpClient
import Bytes exposing (Bytes)
import Terminal
import Process
import CLI.Parser
import CLI.PrettyPrinter as PP
import SemanticVersion exposing (SemanticVersion)
import SemanticVersionRange exposing (SemanticVersionRange)
import Json.Encode as Json
import Json.Decode as Decode exposing (Decoder)


main : Node.Program Model Msg
main =
    Node.defineProgram
        { init = init
        , update = update
        , subscriptions = \_model -> Sub.none
        }


type alias Model = 
    { args : Array String
    , stdout : Stream.Writable Bytes
    , stderr : Stream.Writable Bytes
    , useColor : Bool
    , interactive : Bool
    , backendPath : Path
    , fsPermission : FileSystem.Permission
    , cpPermission : ChildProcess.Permission
    , httpPermission : HttpClient.Permission
    , pathToString : Path -> String
    }


init : Node.Environment -> Init.Task { model : Model, command : Cmd Msg }
init env =
    Init.await FileSystem.initialize <| \fsPermission ->
    Init.await ChildProcess.initialize <| \cpPermission ->
    Init.await HttpClient.initialize <| \httpPermission ->
    Init.await Terminal.initialize <| \terminalConfig ->
    Init.awaitTask Node.getEnvironmentVariables <| \envVars ->
    Init.awaitTask (FileSystem.homeDirectory fsPermission) <| \homeDir ->
            let
                userArgs =
                    Array.dropFirst 2 env.args

                interactiveTerminal =
                    terminalConfig /= Nothing

                useColor =
                    interactiveTerminal && not (Dict.member "NO_COLOR" envVars)

                maybePaths =
                    when { platform = env.platform, override = Dict.get "GREN_BIN" envVars } is
                        { override = Just overridePath, platform = Node.Win32 } ->
                            Just <|
                                { remotePath = Nothing
                                , localPath = Path.fromWin32String overridePath
                                }
                        
                        { override = Just overridePath } ->
                            Just <|
                                { remotePath = Nothing
                                , localPath = Path.fromPosixString overridePath
                                }

                        _ ->
                            Compiler.Backend.downloadUrl env.platform env.cpuArchitecture
                                |> Result.map 
                                    (\url ->
                                        { remotePath = Just url
                                        , localPath = Compiler.Backend.cachePath env.platform envVars homeDir
                                        }
                                    )
                                |> Result.toMaybe

            in
            Node.startProgram
                { model =
                    { args = userArgs
                    , stdout = env.stdout
                    , stderr = env.stderr
                    , interactive = interactiveTerminal
                    , useColor = useColor
                    , backendPath =
                        when maybePaths is
                            Nothing ->
                                Compiler.Backend.cachePath env.platform envVars homeDir

                            Just paths ->
                                paths.localPath
                    , fsPermission = fsPermission
                    , cpPermission = cpPermission
                    , httpPermission = httpPermission
                    , pathToString =
                        if env.platform == Node.Win32 then
                            Path.toWin32String
                        else
                            Path.toPosixString
                    }
                , command =
                    when maybePaths is
                        Just paths ->
                            FileSystem.checkAccess fsPermission [] paths.localPath
                                |> Task.attempt 
                                    (\result -> 
                                        ExistanceChecked
                                            { maybeRemotePath = paths.remotePath
                                            , localPath = paths.localPath
                                            , existanceResult = result
                                            }
                                    )

                        Nothing ->
                            Stream.Log.line env.stderr "We currently don't support this platform/arch."
                                |> Task.execute
                }


type Msg
    = ExistanceChecked 
        { maybeRemotePath : Maybe String
        , localPath : Path
        , existanceResult : Result FileSystem.Error Path
        }
    | CompilerDownloaded 
        { localPath : Path
        , downloadResult : Result (HttpClient.Error Bytes) (HttpClient.Response Bytes)
        }
    | CompilerInstalled (Result FileSystem.Error Path)
    | CompilerInitialized { backendStreams : ChildProcess.StreamIO, encodedCommand : Bytes }
    | CompilerRan Int
    | CompilerRanStatic { path : String, exitCode : Int }
    | InitiatePackageInstall
        (Result
            PackageInstallError
            { projectPath : Path
            , outline : Outline
            , andThen : PackageResolution -> Cmd Msg
            }
        )
    | InstallPackages
        (Result String
            { projectPath : Path
            , outline : Outline
            , projectSources : Dict String String
            , rootPackages : Array { name : PackageName, version : SemanticVersionRange }
            , loadedPackages : Dict String { outline : Outline.PkgOutline, sources : Dict String String }
            , solvedPackages : Dict String Compiler.Dependencies.SimplifiedOutline
            , andThen : PackageResolution -> Cmd Msg
            }
        )


type alias PackageResolution =
    { projectPath : Path
    , outline : Outline
    , rootSources : Dict String String
    , dependencies : Dict String { outline : Outline.PkgOutline, sources : Dict String String }
    }


type PackageInstallError
    = PackageInstallNoProject FileSystem.Error
    | PackageInstallNoGrenJson FileSystem.Error
    | PackageInstallInvalidGrenJson Decode.Error


port completeStaticBuild : String -> Cmd msg


update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    { model = model
    , command =
        when msg is
            ExistanceChecked { maybeRemotePath, localPath, existanceResult = Err _ } ->
                when maybeRemotePath is
                    Just remotePath ->
                        Stream.Log.line model.stdout ("Compiler not found at " ++ model.pathToString localPath ++ ". Downloading...")
                            |> Task.andThen (\_ -> Compiler.Backend.download model.httpPermission remotePath)
                            |> Task.attempt (\result -> CompilerDownloaded { localPath = localPath, downloadResult = result })
            
                    Nothing ->
                        Stream.Log.line model.stderr ("Compiler not found at " ++ model.pathToString localPath)
                            |> Task.execute

            ExistanceChecked { existanceResult = Ok compilerPath } ->
                parseUserArgs model compilerPath

            CompilerDownloaded { localPath, downloadResult = Err ((HttpClient.BadStatus res) as err) } ->
                if res.statusCode == 302 then
                    when Dict.get "location" res.headers is
                        Just [ location ] ->
                            Compiler.Backend.download model.httpPermission location
                                |> Task.attempt (\result -> CompilerDownloaded { localPath = localPath, downloadResult = result })

                        _ ->
                            Stream.Log.line model.stderr "Missing, or vague, 'location' header in 302 response from server."
                                |> Task.execute

                else
                    Stream.Log.line model.stderr (HttpClient.errorToString err)
                        |> Task.execute
        
            CompilerDownloaded { downloadResult = Err err } ->
                Stream.Log.line model.stderr (HttpClient.errorToString err)
                    |> Task.execute
        
            CompilerDownloaded { localPath, downloadResult = Ok res } ->
                let
                    cacheFolder =
                        Path.parentPath localPath
                            |> Maybe.withDefault Path.empty
                in
                FileSystem.makeDirectory model.fsPermission { recursive = True } cacheFolder
                    |> Task.andThen (\_cacheFolder -> FileSystem.writeFile model.fsPermission res.data localPath)
                    |> Task.andThen 
                        (FileSystem.changeAccess
                            model.fsPermission
                            { owner = [ FileSystem.Read, FileSystem.Write, FileSystem.Execute ]
                            , group = [ FileSystem.Read, FileSystem.Execute ]
                            , others = [ FileSystem.Read, FileSystem.Execute ]
                            }
                        )
                    |> Task.andThen 
                        (\binPath -> 
                            Stream.Log.line model.stdout "Downloaded"
                                |> Task.map (\_ -> binPath)
                        )
                    |> Task.attempt CompilerInstalled
        
            CompilerInstalled (Err fsErr) ->
                Stream.Log.line model.stderr ("Failed to install binary after download, due to error: " ++ FileSystem.errorToString fsErr)
                    |> Task.execute
        
            CompilerInstalled (Ok compilerPath) ->
                parseUserArgs model compilerPath

            CompilerInitialized { backendStreams, encodedCommand } ->
                Stream.write encodedCommand backendStreams.input
                    |> Task.andThen (\_ -> Stream.closeWritable backendStreams.input)
                    |> Task.onError
                        (\streamErr ->
                            Stream.Log.line model.stderr ("Failed to send command to compiler backend due to error: " ++ Stream.errorToString streamErr)
                        )
                    |> Task.andThen
                        (\_ ->
                            backendStreams.output
                                |> Stream.awaitAndPipeThrough Stream.textDecoder
                                |> Task.andThen readStringFromStream
                                |> Task.andThen (\str -> Stream.writeStringAsBytes str model.stdout)
                        )
                    |> Task.andThen
                        (\_ ->
                            backendStreams.error
                                |> Stream.awaitAndPipeThrough Stream.textDecoder
                                |> Task.andThen readStringFromStream
                                |> Task.andThen (\str -> Stream.writeStringAsBytes str model.stderr)
                        )
                    |> Task.map (\_ -> {})
                    |> Task.onError
                        (\streamErr ->
                            Stream.Log.line model.stderr ("Something went wrong when reading from backend: " ++ Stream.errorToString streamErr)
                        )
                    |> Task.execute

            CompilerRan exitCode ->
                Node.exitWithCode exitCode
                    |> Task.execute
            
            CompilerRanStatic { path, exitCode } ->
                if exitCode == 0 then
                    completeStaticBuild path
                
                else
                    Node.exitWithCode exitCode
                        |> Task.execute

            InitiatePackageInstall (Err err) ->
                -- TODO: Replace error output code in backend
                Stream.Log.line model.stdout (Debug.toString msg)
                    |> Task.execute

            InitiatePackageInstall (Ok { projectPath, outline, andThen }) ->
                let
                    rootDeps =
                        when outline is
                            Outline.App appOutline ->
                                Dict.union
                                    appOutline.dependencies.direct
                                    appOutline.dependencies.indirect
                                    |> Dict.map
                                        (\_ v ->
                                            when v is
                                                Outline.Version vsn ->
                                                    Outline.Version (SemanticVersionRange.fromExact vsn)

                                                Outline.LocalPath p ->
                                                    Outline.LocalPath p
                                        )

                            Outline.Pkg pkgOutline ->
                                pkgOutline.dependencies
                in
                rootDeps
                    |> Dict.foldl
                        (\key value acc ->
                            Array.pushLast
                                { name = PackageName.fromString key |> Maybe.withDefault PackageName.example
                                , constraint = value
                                }
                                acc
                        )
                        []
                    |> Array.map
                        (\{ name, constraint } ->
                            when constraint is
                                Outline.Version vsn ->
                                    loadPackageFromBundle model.fsPermission name (SemanticVersionRange.lowerBound vsn) projectPath

                                Outline.LocalPath path ->
                                    loadPackageFromPath model.fsPermission name path
                        )
                    |> Task.sequence
                    |> Task.map (Array.mapAndKeepJust identity)
                    |> Task.andThen
                        (\pkgs ->
                            let
                                loadedPackages =
                                    Array.foldl
                                        (\pkg dict ->
                                            Dict.set
                                                (PackageName.toString pkg.name)
                                                { outline = pkg.outline
                                                , sources = pkg.sources
                                                }
                                                dict
                                        )
                                        Dict.empty
                                        pkgs
                            in
                            Outline.findSourceFiles model.fsPermission outline projectPath
                                |> Task.mapError FileSystem.errorToString
                                |> Task.map
                                    (\sourceFiles ->
                                        { projectPath = projectPath
                                        , outline = outline
                                        , projectSources =
                                            Array.foldl
                                                (\{ moduleName, source } dict -> Dict.set moduleName source dict)
                                                Dict.empty
                                                sourceFiles
                                        , rootPackages =
                                            Dict.foldl
                                                (\key value acc ->
                                                    when value is
                                                        Outline.Version vsn ->
                                                            Array.pushLast
                                                                { name = PackageName.fromString key |> Maybe.withDefault PackageName.example
                                                                , version = vsn
                                                                }
                                                                acc

                                                        Outline.LocalPath _ ->
                                                            when Dict.get key loadedPackages is
                                                                Just { outline = pkgOutline } ->
                                                                    Array.pushLast
                                                                        { name = PackageName.fromString key |> Maybe.withDefault PackageName.example
                                                                        , version = SemanticVersionRange.fromExact pkgOutline.version
                                                                        }
                                                                        acc

                                                                _ ->
                                                                    acc
                                                )
                                                []
                                                rootDeps
                                        , loadedPackages = loadedPackages
                                        , solvedPackages = Dict.empty
                                        , andThen = andThen
                                        }
                                    )
                        )
                    |> Task.attempt InstallPackages

            InstallPackages (Err errorStr) ->
                -- TODO: Real errors
                "InstallPackages Error:" ++ errorStr
                    |> Stream.Log.line model.stdout
                    |> Task.execute

            InstallPackages (Ok { projectPath, projectSources, outline, rootPackages, loadedPackages, solvedPackages, andThen }) ->
                when Compiler.Dependencies.solve rootPackages solvedPackages is
                    Compiler.Dependencies.Complete ->
                        andThen
                            { projectPath = projectPath
                            , outline = outline
                            , rootSources = projectSources
                            , dependencies = loadedPackages
                            }

                    Compiler.Dependencies.Missing { name, version } ->
                        let
                            packageNameString =
                                PackageName.toString name
                        in
                        when Dict.get packageNameString loadedPackages is
                            Just loadedPackage ->
                                Outline.findSourceFiles model.fsPermission outline projectPath
                                    |> Task.mapError FileSystem.errorToString
                                    |> Task.map
                                        (\sourceFiles ->
                                            { projectPath = projectPath
                                            , outline = outline
                                            , projectSources =
                                                Array.foldl
                                                    (\{ moduleName, source } dict -> Dict.set moduleName source dict)
                                                    Dict.empty
                                                    sourceFiles
                                            , rootPackages = rootPackages
                                            , loadedPackages = loadedPackages
                                            , solvedPackages =
                                                Dict.set
                                                    packageNameString
                                                    { name = name
                                                    , version = version
                                                    , dependencies =
                                                        Dict.mapAndKeepJust
                                                            (\_ constraint ->
                                                                when constraint is
                                                                    -- TODO: Error
                                                                    Outline.Version vsn ->
                                                                        Just vsn

                                                                    Outline.LocalPath _ ->
                                                                        Nothing
                                                            )
                                                            loadedPackage.outline.dependencies
                                                    }
                                                    solvedPackages
                                            , andThen = andThen
                                            }
                                        )
                                        |> Task.attempt InstallPackages
                                
                            Nothing ->
                                let
                                    lowerBound =
                                        SemanticVersionRange.lowerBound version

                                    bundlePath =
                                        packageBundlePath name lowerBound projectPath

                                    repoPath =
                                        localRepoPath name lowerBound projectPath
                                in
                                FileSystem.remove model.fsPermission { recursive = True, ignoreErrors = False } repoPath
                                    |> Task.onError (\_ -> Task.succeed repoPath) -- Probably because directory doesn't exist, that's fine
                                    |> Task.andThen (\_ -> Git.clonePackage model.cpPermission repoPath name lowerBound)
                                    |> Task.mapError (\{ stderr } -> Maybe.withDefault "" <| Bytes.toString stderr)
                                    |> Task.andThen (\{} ->
                                        (Path.append (Path.fromPosixString "gren.json") repoPath)
                                            |> readOutline model.fsPermission
                                            |> Task.mapError FileSystem.errorToString
                                            |> Task.andThen
                                                (\decodeResult ->
                                                    when decodeResult is
                                                        Ok (Outline.Pkg packageOutline) ->
                                                            Outline.findSourceFiles model.fsPermission (Outline.Pkg packageOutline) repoPath
                                                                |> Task.mapError FileSystem.errorToString
                                                                |> Task.map
                                                                    (\files ->
                                                                        let
                                                                            sources =
                                                                                Array.foldl
                                                                                    (\{ moduleName, source } dict ->
                                                                                        Dict.set moduleName source dict
                                                                                    )
                                                                                    Dict.empty
                                                                                    files
                                                                        in
                                                                        { name = name
                                                                        , outline = packageOutline
                                                                        , sources = sources
                                                                        , data =
                                                                            packageBundleEncoder packageOutline sources
                                                                                |> Json.encode 0
                                                                        }
                                                                    )

                                                        Ok (Outline.App _) ->
                                                            Task.fail "Expected package-type outline."

                                                        Err err ->
                                                            Task.fail <| Debug.toString err
                                                )
                                    )
                                    |> Task.andThen
                                        (\pkg ->
                                            let
                                                packagesDir =
                                                    Path.append (Path.fromPosixString "gren_packages") projectPath
                                            in
                                            packagesDir
                                                |> FileSystem.makeDirectory model.fsPermission { recursive = False }
                                                |> Task.onError
                                                    (\err ->
                                                        if FileSystem.errorIsFileExists err then
                                                            Task.succeed packagesDir

                                                        else
                                                            Task.fail err
                                                    )
                                                |> Task.andThen (\_ -> FileSystem.writeFileStream model.fsPermission bundlePath)
                                                |> Task.mapError FileSystem.errorToString
                                                |> Task.andThen
                                                    (\stream ->
                                                        Stream.fromArray [ pkg.data ]
                                                            |> Task.andThen (Stream.awaitAndPipeThrough Stream.textEncoder)
                                                            |> Task.andThen (Stream.awaitAndPipeThrough Stream.gzipCompression)
                                                            |> Task.andThen (Stream.pipeTo stream)
                                                            |> Task.mapError Stream.errorToString
                                                    )
                                                |> Task.map (\_ -> pkg)
                                        )
                                    |> Task.andThen
                                        (\pkg ->
                                            Outline.findSourceFiles model.fsPermission outline projectPath
                                                |> Task.mapError FileSystem.errorToString
                                                |> Task.map
                                                    (\sourceFiles ->
                                                        { projectPath = projectPath
                                                        , outline = outline
                                                        , projectSources =
                                                            Array.foldl
                                                                (\{ moduleName, source } dict -> Dict.set moduleName source dict)
                                                                Dict.empty
                                                                sourceFiles
                                                        , rootPackages = rootPackages
                                                        , loadedPackages =
                                                            Dict.set
                                                                (PackageName.toString name)
                                                                { outline = pkg.outline, sources = pkg.sources }
                                                                loadedPackages
                                                        , solvedPackages = solvedPackages
                                                        , andThen = andThen
                                                        }
                                                    )
                                        )
                                    -- TODO: Print progress
                                    |> Task.attempt InstallPackages

                    Compiler.Dependencies.Conflict _ ->
                        "TODO: CONFLICT"
                            |> Stream.Log.line model.stdout
                            |> Task.execute
        }


type alias LoadedPackage =
    { name : PackageName
    , outline : Outline.PkgOutline
    , sources : Dict String String
    }

-- TODO: extract to module
loadPackageFromPath : FileSystem.Permission -> PackageName -> Path -> Task String (Maybe LoadedPackage)
loadPackageFromPath fsPermission name path =
    let
        outlinePath =
            Path.append (Path.fromPosixString "gren.json") path
    in
    FileSystem.readFile fsPermission outlinePath
        |> Task.mapError FileSystem.errorToString
        |> Task.andThen
            (\outlineBytes ->
                when Bytes.toString outlineBytes is
                    Just str ->
                        Task.succeed str

                    Nothing ->
                        Task.fail "gren.json not valid utf-8"
            )
        |> Task.andThen
            (\outlineStr ->
                when Decode.decodeString Outline.pkgJsonDecoder outlineStr is
                    Ok outline ->
                        Outline.findSourceFiles fsPermission (Outline.Pkg outline) path
                            |> Task.mapError FileSystem.errorToString
                            |> Task.andThen
                                (\sourceFiles ->
                                    if name /= outline.name then
                                        Task.fail ("Name in outline was expected to be " ++ PackageName.toString name)

                                    else
                                        Task.succeed
                                            (Just
                                                { name = name
                                                , outline = outline
                                                , sources =
                                                    Array.foldl
                                                        (\{ moduleName, source } acc ->
                                                            Dict.set moduleName source acc
                                                        )
                                                        Dict.empty
                                                        sourceFiles
                                                }
                                            )
                                )

                    Err jsonErr ->
                        Task.fail <| Decode.errorToString jsonErr
            )

loadPackageFromBundle : FileSystem.Permission -> PackageName -> SemanticVersion -> Path -> Task String (Maybe LoadedPackage)
loadPackageFromBundle fsPermission name vsn projectPath =
    packageBundlePath name vsn projectPath
        |> FileSystem.readFileStream fsPermission
        |> Task.mapError FileSystem.errorToString
        |> Task.andThen
            (\stream ->
                stream
                    |> Stream.awaitAndPipeThrough Stream.gzipDecompression
                    |> Task.andThen (Stream.awaitAndPipeThrough Stream.textDecoder)
                    |> Task.andThen readStringFromStream
                    |> Task.mapError Stream.errorToString
                    |> Task.andThen
                        (\data ->
                            when Decode.decodeString packageBundleDecoder data is
                                Ok bundle ->
                                    if name /= bundle.outline.name then
                                        Task.fail ("Package name mismatch. Expected " ++ PackageName.toString name)

                                    else if vsn /= bundle.outline.version then
                                        Task.fail ("Package version mismatch. Expected " ++ SemanticVersion.toString vsn)

                                    else
                                        Task.succeed
                                            (Just
                                                { name = name
                                                , outline = bundle.outline
                                                , sources = bundle.sources
                                                }
                                            )

                                Err jsonErr ->
                                    Task.fail <| Decode.errorToString jsonErr
                        )
                    |> Task.onError (\_ -> Task.succeed Nothing)
            )

packageBundleEncoder : Outline.PkgOutline -> Dict String String -> Json.Value
packageBundleEncoder outline sources =
    Json.object
        [ { key = "outline", value = Outline.toJson (Outline.Pkg outline) }
        , { key = "sources", value = Json.dict identity Json.string sources }
        ]


packageBundleDecoder : Decoder { outline : Outline.PkgOutline, sources : Dict String String }
packageBundleDecoder =
    Decode.map2 (\outline sources -> { outline = outline, sources = sources })
        (Decode.field "outline" Outline.pkgJsonDecoder)
        (Decode.field "sources" (Decode.dict Decode.string))


readStringFromStream : Stream.Readable String -> Task Stream.Error String
readStringFromStream stream =
    Stream.readUntilClosed (\chunk result -> Ok (result ++ chunk)) "" stream


packageBundlePath : PackageName -> SemanticVersion -> Path -> Path
packageBundlePath name version projectPath =
    let
        normalizedName =
            (PackageName.toString name ++ "__" ++ SemanticVersion.toString version)
                |> String.replace "-" "_"
                |> String.replace "." "_"
                |> String.replace "/" "_"
                |> String.append ".pkg.gz"
    in
    Path.join
        [ projectPath
        , Path.fromPosixString "gren_packages"
        , Path.fromPosixString normalizedName
        ]


localRepoPath : PackageName -> SemanticVersion -> Path -> Path
localRepoPath name version projectPath =
    let
        normalizedName =
            (PackageName.toString name ++ "__" ++ SemanticVersion.toString version)
                |> String.replace "-" "_"
                |> String.replace "." "_"
                |> String.replace "/" "_"
    in
    Path.join
        [ projectPath
        , Path.fromPosixString ".gren/git"
        , Path.fromPosixString normalizedName
        ]


parseUserArgs : Model -> Path -> Cmd Msg
parseUserArgs model compilerPath =
    let
        colorFilter =
            if model.useColor then
                identity

            else
                PP.stripColor

        prettyTextToTerminal doc =
            doc
                |> colorFilter
                |> PP.toStringWithOptions
                    { PP.defaultOptions | maxColumns = 80 }
    in
    when CLI.Parser.run model.args CliParser.parser is
        CLI.Parser.UnknownCommand commandName ->
            Stream.Log.line model.stderr ("I don't recognize this command: " ++ commandName)
                |> Task.execute
    
        CLI.Parser.BadFlags err ->
            err
                |> CLI.Parser.flagErrorPrettified
                |> prettyTextToTerminal
                |> Stream.Log.line model.stderr
                |> Task.execute
    
        CLI.Parser.BadArguments err ->
            err
                |> CLI.Parser.argumentErrorPrettified
                |> prettyTextToTerminal
                |> Stream.Log.line model.stderr
                |> Task.execute
    
        CLI.Parser.HelpText prettifiedText ->
            prettifiedText
                |> prettyTextToTerminal
                |> Stream.Log.line model.stdout
                |> Task.execute
    
        CLI.Parser.Success parsedCommand ->
            let
                initWithCommand backendCommand cpOpts =
                    when cpOpts.streams is
                        Nothing ->
                            -- TODO: error handling
                            Debug.todo "no stream for child process"

                        Just streams ->
                            CompilerInitialized
                                { backendStreams = streams
                                , encodedCommand =
                                    Compiler.Backend.encodeCommand
                                        { interactiveSession = model.interactive
                                        , pathToString = model.pathToString
                                        }
                                        backendCommand
                                }
            in
            when parsedCommand is
                CliParser.Init flags ->
                    Compiler.Backend.run
                        model.cpPermission
                        { useColor = model.useColor
                        , compilerPath = compilerPath
                        , pathToString = model.pathToString
                        , onInit = initWithCommand <| Compiler.Backend.Init flags 
                        , onComplete = CompilerRan
                        }

                CliParser.Repl flags ->
                    Compiler.Backend.run
                        model.cpPermission
                        { useColor = model.useColor
                        , compilerPath = compilerPath
                        , pathToString = model.pathToString
                        , onInit = initWithCommand <| Compiler.Backend.Repl flags 
                        , onComplete = CompilerRan
                        }

                CliParser.Make flags ->
                    runMake model.fsPermission
                        (\resolved ->
                            Compiler.Backend.run
                                model.cpPermission
                                { useColor = model.useColor
                                , compilerPath = compilerPath
                                , pathToString = model.pathToString
                                , onInit = initWithCommand <|
                                    Compiler.Backend.Make
                                        { optimize = flags.optimize
                                        , sourcemaps = flags.sourcemaps
                                        , output = flags.output
                                        , report = flags.report
                                        , projectPath = resolved.projectPath
                                        , entryPoints = flags.entryPoints
                                        , outline = resolved.outline
                                        , rootSources = resolved.rootSources
                                        , dependencies = resolved.dependencies
                                        }
                                , onComplete = CompilerRan
                                }
                        )

                CliParser.MakeStatic opts ->
                    runMake model.fsPermission
                        (\resolved ->
                            Compiler.Backend.run
                                model.cpPermission
                                { useColor = model.useColor
                                , compilerPath = compilerPath
                                , pathToString = model.pathToString
                                , onInit = initWithCommand <|
                                    Compiler.Backend.Make
                                        { optimize = True
                                        , sourcemaps = False
                                        , output = Just (Compiler.Backend.Exe <| model.pathToString opts.output)
                                        , report = Nothing
                                        , projectPath = resolved.projectPath
                                        , entryPoints = [ opts.source ]
                                        , outline = resolved.outline
                                        , rootSources = resolved.rootSources
                                        , dependencies = resolved.dependencies
                                        }
                                , onComplete =
                                    (\exitCode ->
                                        CompilerRanStatic
                                            { path = model.pathToString opts.output
                                            , exitCode = exitCode
                                            }
                                    )
                                }
                        )

                CliParser.Docs flags ->
                    Compiler.Backend.run
                        model.cpPermission
                        { useColor = model.useColor
                        , compilerPath = compilerPath
                        , pathToString = model.pathToString
                        , onInit = initWithCommand <| Compiler.Backend.Docs flags 
                        , onComplete = CompilerRan
                        }

                -- TODO: test installing single package
                CliParser.PackageInstall _ ->
                    Compiler.Paths.projectRoot model.fsPermission
                        |> Task.mapError PackageInstallNoProject
                        |> Task.map (Path.append (Path.fromPosixString "gren.json"))
                        |> Task.andThen
                            (\grenJsonPath ->
                                readOutline model.fsPermission grenJsonPath
                                    |> Task.mapError PackageInstallNoGrenJson
                                    |> Task.andThen
                                        (\decodeResult ->
                                            when decodeResult is
                                                Ok outline ->
                                                    Task.succeed
                                                        { projectPath =
                                                            Path.parentPath grenJsonPath
                                                                |> Maybe.withDefault grenJsonPath
                                                        , outline = outline
                                                        , andThen = (\_ -> Task.succeed {} |> Task.execute)
                                                        }

                                                Err err ->
                                                    Task.fail (PackageInstallInvalidGrenJson err)
                                        )
                            )
                        |> Task.attempt InitiatePackageInstall

                CliParser.PackageUninstall packageName ->
                    Compiler.Backend.run
                        model.cpPermission
                        { useColor = model.useColor
                        , compilerPath = compilerPath
                        , pathToString = model.pathToString
                        , onInit = initWithCommand <| Compiler.Backend.PackageUninstall packageName
                        , onComplete = CompilerRan
                        }

                CliParser.PackageOutdated ->
                    Compiler.Backend.run
                        model.cpPermission
                        { onInit = initWithCommand <| Compiler.Backend.PackageOutdated
                        , useColor = model.useColor
                        , compilerPath = compilerPath
                        , pathToString = model.pathToString
                        , onComplete = CompilerRan
                        }

                CliParser.PackageValidate ->
                    Compiler.Backend.run
                        model.cpPermission
                        { onInit = initWithCommand <| Compiler.Backend.PackageValidate
                        , useColor = model.useColor
                        , compilerPath = compilerPath
                        , pathToString = model.pathToString
                        , onComplete = CompilerRan
                        }

                CliParser.PackageBump ->
                    Compiler.Backend.run
                        model.cpPermission
                        { onInit = initWithCommand Compiler.Backend.PackageBump
                        , useColor = model.useColor
                        , compilerPath = compilerPath
                        , pathToString = model.pathToString
                        , onComplete = CompilerRan
                        }

                CliParser.PackageDiff args ->
                    Compiler.Backend.run
                        model.cpPermission
                        { onInit = initWithCommand <| Compiler.Backend.PackageDiff args
                        , useColor = model.useColor
                        , compilerPath = compilerPath
                        , pathToString = model.pathToString
                        , onComplete = CompilerRan
                        }

                CliParser.Paths opts ->
                    when opts is
                        { project = False, packageCache = False, backend = False, json = False } ->
                            Compiler.Paths.projectRoot model.fsPermission
                                |> Task.andThen
                                    (\project ->
                                        [ "project: " ++ model.pathToString project
                                        , "package-cache: " ++ model.pathToString (Path.append (Path.fromPosixString "gren_packages") project)
                                        , "backend: " ++ model.pathToString model.backendPath
                                        ]
                                            |> String.join "\n"
                                            |> Stream.Log.line model.stdout
                                    )
                                |> Task.onError (\_ -> Stream.Log.line model.stdout "Couldn't find project!")
                                |> Task.execute

                        { project = False, packageCache = False, backend = False, json = True } ->
                            Compiler.Paths.projectRoot model.fsPermission
                                |> Task.andThen
                                    (\project ->
                                        Json.object
                                            [ { key = "project", value = Json.string (model.pathToString project) }
                                            , { key = "packageCache", value = Json.string (model.pathToString (Path.append (Path.fromPosixString "gren_packages") project)) }
                                            , { key = "backend", value = Json.string (model.pathToString model.backendPath) }
                                            ]
                                            |> Json.encode 4
                                            |> Stream.Log.line model.stdout
                                    )
                                |> Task.onError (\_ -> Stream.Log.line model.stdout "Couldn't find project!")
                                |> Task.execute

                        { project = True, packageCache = False, backend = False, json = False } ->
                            Compiler.Paths.projectRoot model.fsPermission
                                |> Task.andThen
                                    (\project ->
                                        Stream.Log.line model.stdout (model.pathToString project)
                                    )
                                |> Task.onError (\_ -> Stream.Log.line model.stdout "Couldn't find project!")
                                |> Task.execute

                        { project = True, packageCache = False, backend = False, json = True } ->
                            Compiler.Paths.projectRoot model.fsPermission
                                |> Task.andThen
                                    (\project ->
                                        Json.object
                                            [ { key = "project", value = Json.string (model.pathToString project) }
                                            ]
                                            |> Json.encode 4
                                            |> Stream.Log.line model.stdout
                                    )
                                |> Task.onError (\_ -> Stream.Log.line model.stdout "Couldn't find project!")
                                |> Task.execute

                        { project = False, packageCache = True, backend = False, json = False } ->
                            Compiler.Paths.projectRoot model.fsPermission
                                |> Task.andThen
                                    (\project ->
                                         model.pathToString (Path.append (Path.fromPosixString "gren_packages") project)
                                            |> Stream.Log.line model.stdout
                                    )
                                |> Task.onError (\_ -> Stream.Log.line model.stdout "Couldn't find project!")
                                |> Task.execute

                        { project = False, packageCache = True, backend = False, json = True } ->
                            Compiler.Paths.projectRoot model.fsPermission
                                |> Task.andThen
                                    (\project ->
                                        Json.object
                                            [ { key = "packageCache", value = Json.string (model.pathToString (Path.append (Path.fromPosixString "gren_packages") project)) }
                                            ]
                                            |> Json.encode 4
                                            |> Stream.Log.line model.stdout
                                    )
                                |> Task.onError (\_ -> Stream.Log.line model.stdout "Couldn't find project!")
                                |> Task.execute

                        { project = False, packageCache = False, backend = True, json = False } ->
                            Stream.Log.line model.stdout (model.pathToString model.backendPath)
                                |> Task.execute

                        { project = False, packageCache = False, backend = True, json = True } ->
                            Json.object
                                [ { key = "backend", value = Json.string (model.pathToString model.backendPath) }
                                ]
                                |> Json.encode 4
                                |> Stream.Log.line model.stdout
                                |> Task.execute

                        _ ->
                            Stream.Log.line model.stdout "You can only use one of --project, --package-cache and --backend!"
                                |> Task.execute


runMake : FileSystem.Permission -> (PackageResolution -> Cmd Msg) -> Cmd Msg
runMake fsPermission andThen =
    Compiler.Paths.projectRoot fsPermission
        |> Task.mapError PackageInstallNoProject
        |> Task.map (Path.append (Path.fromPosixString "gren.json"))
        |> Task.andThen
            (\grenJsonPath ->
                readOutline fsPermission grenJsonPath
                    |> Task.mapError PackageInstallNoGrenJson
                    |> Task.andThen
                        (\decodeResult ->
                            when decodeResult is
                                Ok outline ->
                                    Task.succeed
                                        { projectPath =
                                            Path.parentPath grenJsonPath
                                                |> Maybe.withDefault grenJsonPath
                                        , outline = outline
                                        , andThen = andThen
                                        }

                                Err err ->
                                    Task.fail (PackageInstallInvalidGrenJson err)
                        )
            )
        |> Task.attempt InitiatePackageInstall


readOutline : FileSystem.Permission -> Path -> Task FileSystem.Error (Result Decode.Error Outline)
readOutline fsPerm path =
    FileSystem.readFile fsPerm path
        |> Task.map (Bytes.toString >> Maybe.withDefault "")
        |> Task.map (Decode.decodeString Outline.jsonDecoder)

