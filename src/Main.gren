port module Main exposing (main)

import Node
import ChildProcess
import Terminal.Parser as CliParser
import Terminal.Package
import Terminal.Paths
import Compiler.Backend
import Compiler.PackageName as PackageName exposing (PackageName)
import Compiler.Platform as Platform exposing (Platform)
import Compiler.Paths
import Compiler.Outline as Outline exposing (Outline)
import Compiler.Dependencies
import Git
import Init
import Stream
import Stream.Log
import Task exposing (Task)
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import HttpClient
import Bytes exposing (Bytes)
import Terminal
import Process
import CLI.Parser
import CLI.PrettyPrinter as PP
import SemanticVersion exposing (SemanticVersion)
import SemanticVersionRange exposing (SemanticVersionRange)
import Json.Encode as Json
import Json.Decode as Decode exposing (Decoder)


main : Node.Program Model Msg
main =
    Node.defineProgram
        { init = init
        , update = update
        , subscriptions = \_model -> Sub.none
        }


type alias Model = 
    { args : Array String
    , stdout : Stream.Writable Bytes
    , stderr : Stream.Writable Bytes
    , stdin : Stream.Readable Bytes
    , useColor : Bool
    , interactive : Bool
    , backendPath : Path
    , fsPermission : FileSystem.Permission
    , cpPermission : ChildProcess.Permission
    , httpPermission : HttpClient.Permission
    , pathToString : Path -> String
    }


init : Node.Environment -> Init.Task { model : Model, command : Cmd Msg }
init env =
    Init.await FileSystem.initialize <| \fsPermission ->
    Init.await ChildProcess.initialize <| \cpPermission ->
    Init.await HttpClient.initialize <| \httpPermission ->
    Init.await Terminal.initialize <| \terminalConfig ->
    Init.awaitTask Node.getEnvironmentVariables <| \envVars ->
    Init.awaitTask (FileSystem.homeDirectory fsPermission) <| \homeDir ->
            let
                userArgs =
                    Array.dropFirst 2 env.args

                interactiveTerminal =
                    terminalConfig /= Nothing

                useColor =
                    interactiveTerminal && not (Dict.member "NO_COLOR" envVars)

                maybePaths =
                    when { platform = env.platform, override = Dict.get "GREN_BIN" envVars } is
                        { override = Just overridePath, platform = Node.Win32 } ->
                            Just <|
                                { remotePath = Nothing
                                , localPath = Path.fromWin32String overridePath
                                }
                        
                        { override = Just overridePath } ->
                            Just <|
                                { remotePath = Nothing
                                , localPath = Path.fromPosixString overridePath
                                }

                        _ ->
                            Compiler.Backend.downloadUrl env.platform env.cpuArchitecture
                                |> Result.map 
                                    (\url ->
                                        { remotePath = Just url
                                        , localPath = Compiler.Backend.cachePath env.platform envVars homeDir
                                        }
                                    )
                                |> Result.toMaybe

            in
            Node.startProgram
                { model =
                    { args = userArgs
                    , stdout = env.stdout
                    , stderr = env.stderr
                    , stdin = env.stdin
                    , interactive = interactiveTerminal
                    , useColor = useColor
                    , backendPath =
                        when maybePaths is
                            Nothing ->
                                Compiler.Backend.cachePath env.platform envVars homeDir

                            Just paths ->
                                paths.localPath
                    , fsPermission = fsPermission
                    , cpPermission = cpPermission
                    , httpPermission = httpPermission
                    , pathToString =
                        if env.platform == Node.Win32 then
                            Path.toWin32String
                        else
                            Path.toPosixString
                    }
                , command =
                    when maybePaths is
                        Just paths ->
                            FileSystem.checkAccess fsPermission [] paths.localPath
                                |> Task.attempt 
                                    (\result -> 
                                        ExistanceChecked
                                            { maybeRemotePath = paths.remotePath
                                            , localPath = paths.localPath
                                            , existanceResult = result
                                            }
                                    )

                        Nothing ->
                            Stream.Log.line env.stderr "We currently don't support this platform/arch."
                                |> Task.execute
                }


type Msg
    = ExistanceChecked 
        { maybeRemotePath : Maybe String
        , localPath : Path
        , existanceResult : Result FileSystem.Error Path
        }
    | CompilerDownloaded 
        { localPath : Path
        , downloadResult : Result (HttpClient.Error Bytes) (HttpClient.Response Bytes)
        }
    | CompilerInstalled (Result FileSystem.Error Path)
    | CompilerInitialized { backendStreams : ChildProcess.StreamIO, encodedCommand : Bytes }
    | CompilerRan Int
    | CompilerRanStatic { path : String, exitCode : Int }
    | InitiatePackageInstall
        (Result
            Terminal.Package.PackageInstallError
            { projectPath : Path
            , outline : Outline
            , andThen : Terminal.Package.PackageResolution -> Cmd Msg
            }
        )
    | InstallPackages
        (Result String
            { projectPath : Path
            , outline : Outline
            , projectSources : Dict String String
            , rootPackages : Array { name : PackageName, version : SemanticVersionRange }
            , loadedPackages : Dict String { outline : Outline.PkgOutline, sources : Dict String String }
            , solvedPackages : Dict String Compiler.Dependencies.SimplifiedOutline
            , andThen : Terminal.Package.PackageResolution -> Cmd Msg
            }
        )
    | PackageResolutionReady
        (Result
            Terminal.Package.PackageInstallError
            { resolution : Terminal.Package.PackageResolution
            , andThen : Terminal.Package.PackageResolution -> Cmd Msg
            }
        )


port completeStaticBuild : String -> Cmd msg


update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    { model = model
    , command =
        when msg is
            ExistanceChecked { maybeRemotePath, localPath, existanceResult = Err _ } ->
                when maybeRemotePath is
                    Just remotePath ->
                        Stream.Log.line model.stdout ("Compiler not found at " ++ model.pathToString localPath ++ ". Downloading...")
                            |> Task.andThen (\_ -> Compiler.Backend.download model.httpPermission remotePath)
                            |> Task.attempt (\result -> CompilerDownloaded { localPath = localPath, downloadResult = result })
            
                    Nothing ->
                        Stream.Log.line model.stderr ("Compiler not found at " ++ model.pathToString localPath)
                            |> Task.execute

            ExistanceChecked { existanceResult = Ok compilerPath } ->
                parseUserArgs model compilerPath

            CompilerDownloaded { localPath, downloadResult = Err ((HttpClient.BadStatus res) as err) } ->
                if res.statusCode == 302 then
                    when Dict.get "location" res.headers is
                        Just [ location ] ->
                            Compiler.Backend.download model.httpPermission location
                                |> Task.attempt (\result -> CompilerDownloaded { localPath = localPath, downloadResult = result })

                        _ ->
                            Stream.Log.line model.stderr "Missing, or vague, 'location' header in 302 response from server."
                                |> Task.execute

                else
                    Stream.Log.line model.stderr (HttpClient.errorToString err)
                        |> Task.execute
        
            CompilerDownloaded { downloadResult = Err err } ->
                Stream.Log.line model.stderr (HttpClient.errorToString err)
                    |> Task.execute
        
            CompilerDownloaded { localPath, downloadResult = Ok res } ->
                let
                    cacheFolder =
                        Path.parentPath localPath
                            |> Maybe.withDefault Path.empty
                in
                FileSystem.makeDirectory model.fsPermission { recursive = True } cacheFolder
                    |> Task.andThen (\_cacheFolder -> FileSystem.writeFile model.fsPermission res.data localPath)
                    |> Task.andThen 
                        (FileSystem.changeAccess
                            model.fsPermission
                            { owner = [ FileSystem.Read, FileSystem.Write, FileSystem.Execute ]
                            , group = [ FileSystem.Read, FileSystem.Execute ]
                            , others = [ FileSystem.Read, FileSystem.Execute ]
                            }
                        )
                    |> Task.andThen 
                        (\binPath -> 
                            Stream.Log.line model.stdout "Downloaded"
                                |> Task.map (\_ -> binPath)
                        )
                    |> Task.attempt CompilerInstalled
        
            CompilerInstalled (Err fsErr) ->
                Stream.Log.line model.stderr ("Failed to install binary after download, due to error: " ++ FileSystem.errorToString fsErr)
                    |> Task.execute
        
            CompilerInstalled (Ok compilerPath) ->
                parseUserArgs model compilerPath

            CompilerInitialized { backendStreams, encodedCommand } ->
                Stream.write encodedCommand backendStreams.input
                    |> Task.andThen (\_ -> Stream.closeWritable backendStreams.input)
                    |> Task.onError
                        (\streamErr ->
                            Stream.Log.line model.stderr ("Failed to send command to compiler backend due to error: " ++ Stream.errorToString streamErr)
                        )
                    |> Task.andThen
                        (\_ ->
                            backendStreams.output
                                |> Stream.awaitAndPipeThrough Stream.textDecoder
                                |> Task.andThen readStringFromStream
                                |> Task.andThen (\str -> Stream.writeStringAsBytes str model.stdout)
                        )
                    |> Task.andThen
                        (\_ ->
                            backendStreams.error
                                |> Stream.awaitAndPipeThrough Stream.textDecoder
                                |> Task.andThen readStringFromStream
                                |> Task.andThen (\str -> Stream.writeStringAsBytes str model.stderr)
                        )
                    |> Task.map (\_ -> {})
                    |> Task.onError
                        (\streamErr ->
                            Stream.Log.line model.stderr ("Something went wrong when reading from backend: " ++ Stream.errorToString streamErr)
                        )
                    |> Task.execute

            CompilerRan exitCode ->
                Node.exitWithCode exitCode
                    |> Task.execute
            
            CompilerRanStatic { path, exitCode } ->
                if exitCode == 0 then
                    completeStaticBuild path
                
                else
                    Node.exitWithCode exitCode
                        |> Task.execute

            InitiatePackageInstall (Err err) ->
                -- TODO: Replace error output code in backend
                Stream.Log.line model.stdout (Debug.toString msg)
                    |> Task.execute

            InitiatePackageInstall (Ok { projectPath, outline, andThen }) ->
                let
                    rootDeps =
                        when outline is
                            Outline.App appOutline ->
                                Dict.union
                                    appOutline.dependencies.direct
                                    appOutline.dependencies.indirect
                                    |> Dict.map
                                        (\_ v ->
                                            when v is
                                                Outline.Version vsn ->
                                                    Outline.Version (SemanticVersionRange.fromExact vsn)

                                                Outline.LocalPath p ->
                                                    Outline.LocalPath p
                                        )

                            Outline.Pkg pkgOutline ->
                                pkgOutline.dependencies
                in
                rootDeps
                    |> Dict.foldl
                        (\key value acc ->
                            Array.pushLast
                                { name = PackageName.fromString key |> Maybe.withDefault PackageName.example
                                , constraint = value
                                }
                                acc
                        )
                        []
                    |> Array.map
                        (\{ name, constraint } ->
                            when constraint is
                                Outline.Version vsn ->
                                    loadPackageFromBundle model.fsPermission name (SemanticVersionRange.lowerBound vsn) projectPath

                                Outline.LocalPath path ->
                                    loadPackageFromPath model.fsPermission name path
                        )
                    |> Task.concurrent
                    |> Task.map (Array.mapAndKeepJust identity)
                    |> Task.andThen
                        (\pkgs ->
                            let
                                loadedPackages =
                                    Array.foldl
                                        (\pkg dict ->
                                            Dict.set
                                                (PackageName.toString pkg.name)
                                                { outline = pkg.outline
                                                , sources = pkg.sources
                                                }
                                                dict
                                        )
                                        Dict.empty
                                        pkgs
                            in
                            Outline.findSourceFiles model.fsPermission outline projectPath
                                |> Task.mapError FileSystem.errorToString
                                |> Task.map
                                    (\sourceFiles ->
                                        { projectPath = projectPath
                                        , outline = outline
                                        , projectSources =
                                            Array.foldl
                                                (\{ moduleName, source } dict -> Dict.set moduleName source dict)
                                                Dict.empty
                                                sourceFiles
                                        , rootPackages =
                                            Dict.foldl
                                                (\key value acc ->
                                                    when value is
                                                        Outline.Version vsn ->
                                                            Array.pushLast
                                                                { name = PackageName.fromString key |> Maybe.withDefault PackageName.example
                                                                , version = vsn
                                                                }
                                                                acc

                                                        Outline.LocalPath _ ->
                                                            when Dict.get key loadedPackages is
                                                                Just { outline = pkgOutline } ->
                                                                    Array.pushLast
                                                                        { name = PackageName.fromString key |> Maybe.withDefault PackageName.example
                                                                        , version = SemanticVersionRange.fromExact pkgOutline.version
                                                                        }
                                                                        acc

                                                                _ ->
                                                                    acc
                                                )
                                                []
                                                rootDeps
                                        , loadedPackages = loadedPackages
                                        , solvedPackages = Dict.empty
                                        , andThen = andThen
                                        }
                                    )
                        )
                    |> Task.attempt InstallPackages

            InstallPackages (Err errorStr) ->
                -- TODO: Real errors
                "InstallPackages Error:" ++ errorStr
                    |> Stream.Log.line model.stdout
                    |> Task.execute

            InstallPackages (Ok opts) ->
                Terminal.Package.install
                    { fsPermission = model.fsPermission
                    , cpPermission = model.cpPermission
                    , stdout = model.stdout
                    }
                    opts
                    |> Task.map (\res -> { resolution = res, andThen = opts.andThen })
                    |> Task.attempt PackageResolutionReady

            PackageResolutionReady (Err error) ->
                -- TODO: Real errors
                "InstallPackages Error:" ++ Debug.toString error
                    |> Stream.Log.line model.stdout
                    |> Task.execute

            PackageResolutionReady (Ok { resolution, andThen }) ->
                andThen resolution
        }


type alias LoadedPackage =
    { name : PackageName
    , outline : Outline.PkgOutline
    , sources : Dict String String
    }


-- TODO: extract to module
loadPackageFromPath : FileSystem.Permission -> PackageName -> Path -> Task String (Maybe LoadedPackage)
loadPackageFromPath fsPermission name path =
    let
        outlinePath =
            Path.append (Path.fromPosixString "gren.json") path
    in
    FileSystem.readFile fsPermission outlinePath
        |> Task.mapError FileSystem.errorToString
        |> Task.andThen
            (\outlineBytes ->
                when Bytes.toString outlineBytes is
                    Just str ->
                        Task.succeed str

                    Nothing ->
                        Task.fail "gren.json not valid utf-8"
            )
        |> Task.andThen
            (\outlineStr ->
                when Decode.decodeString Outline.pkgJsonDecoder outlineStr is
                    Ok outline ->
                        Outline.findSourceFiles fsPermission (Outline.Pkg outline) path
                            |> Task.mapError FileSystem.errorToString
                            |> Task.andThen
                                (\sourceFiles ->
                                    if name /= outline.name then
                                        Task.fail ("Name in outline was expected to be " ++ PackageName.toString name)

                                    else
                                        Task.succeed
                                            (Just
                                                { name = name
                                                , outline = outline
                                                , sources =
                                                    Array.foldl
                                                        (\{ moduleName, source } acc ->
                                                            Dict.set moduleName source acc
                                                        )
                                                        Dict.empty
                                                        sourceFiles
                                                }
                                            )
                                )

                    Err jsonErr ->
                        Task.fail <| Decode.errorToString jsonErr
            )

loadPackageFromBundle : FileSystem.Permission -> PackageName -> SemanticVersion -> Path -> Task String (Maybe LoadedPackage)
loadPackageFromBundle fsPermission name vsn projectPath =
    Terminal.Package.packageBundlePath name vsn projectPath
        |> FileSystem.readFileStream fsPermission
        |> Task.mapError FileSystem.errorToString
        |> Task.andThen
            (\stream ->
                stream
                    |> Stream.awaitAndPipeThrough Stream.gzipDecompression
                    |> Task.andThen (Stream.awaitAndPipeThrough Stream.textDecoder)
                    |> Task.andThen readStringFromStream
                    |> Task.mapError Stream.errorToString
                    |> Task.andThen
                        (\data ->
                            when Decode.decodeString Terminal.Package.packageBundleDecoder data is
                                Ok bundle ->
                                    if name /= bundle.outline.name then
                                        Task.fail ("Package name mismatch. Expected " ++ PackageName.toString name)

                                    else if vsn /= bundle.outline.version then
                                        Task.fail ("Package version mismatch. Expected " ++ SemanticVersion.toString vsn)

                                    else
                                        Task.succeed
                                            (Just
                                                { name = name
                                                , outline = bundle.outline
                                                , sources = bundle.sources
                                                }
                                            )

                                Err jsonErr ->
                                    Task.fail <| Decode.errorToString jsonErr
                        )
                    |> Task.onError (\_ -> Task.succeed Nothing)
            )

readStringFromStream : Stream.Readable String -> Task Stream.Error String
readStringFromStream stream =
    Stream.readUntilClosed (\chunk result -> Ok (result ++ chunk)) "" stream


parseUserArgs : Model -> Path -> Cmd Msg
parseUserArgs model compilerPath =
    let
        colorFilter =
            if model.useColor then
                identity

            else
                PP.stripColor

        prettyTextToTerminal doc =
            doc
                |> colorFilter
                |> PP.toStringWithOptions
                    { PP.defaultOptions | maxColumns = 80 }
    in
    when CLI.Parser.run model.args CliParser.parser is
        CLI.Parser.UnknownCommand commandName ->
            Stream.Log.line model.stderr ("I don't recognize this command: " ++ commandName)
                |> Task.execute
    
        CLI.Parser.BadFlags err ->
            err
                |> CLI.Parser.flagErrorPrettified
                |> prettyTextToTerminal
                |> Stream.Log.line model.stderr
                |> Task.execute
    
        CLI.Parser.BadArguments err ->
            err
                |> CLI.Parser.argumentErrorPrettified
                |> prettyTextToTerminal
                |> Stream.Log.line model.stderr
                |> Task.execute
    
        CLI.Parser.HelpText prettifiedText ->
            prettifiedText
                |> prettyTextToTerminal
                |> Stream.Log.line model.stdout
                |> Task.execute
    
        CLI.Parser.Success parsedCommand ->
            let
                initWithCommand backendCommand cpOpts =
                    when cpOpts.streams is
                        Nothing ->
                            -- TODO: error handling
                            Debug.todo "no stream for child process"

                        Just streams ->
                            CompilerInitialized
                                { backendStreams = streams
                                , encodedCommand =
                                    Compiler.Backend.encodeCommand
                                        { interactiveSession = model.interactive
                                        , pathToString = model.pathToString
                                        }
                                        backendCommand
                                }
            in
            when parsedCommand is
                CliParser.Init flags ->
                    Compiler.Backend.run
                        model.cpPermission
                        { useColor = model.useColor
                        , compilerPath = compilerPath
                        , pathToString = model.pathToString
                        , onInit = initWithCommand <| Compiler.Backend.Init flags 
                        , onComplete = CompilerRan
                        }

                CliParser.Repl flags ->
                    Compiler.Backend.run
                        model.cpPermission
                        { useColor = model.useColor
                        , compilerPath = compilerPath
                        , pathToString = model.pathToString
                        , onInit = initWithCommand <| Compiler.Backend.Repl flags 
                        , onComplete = CompilerRan
                        }

                CliParser.Make flags ->
                    runMake model.fsPermission
                        (\resolved ->
                            Compiler.Backend.run
                                model.cpPermission
                                { useColor = model.useColor
                                , compilerPath = compilerPath
                                , pathToString = model.pathToString
                                , onInit = initWithCommand <|
                                    Compiler.Backend.Make
                                        { optimize = flags.optimize
                                        , sourcemaps = flags.sourcemaps
                                        , output = flags.output
                                        , report = flags.report
                                        , projectPath = resolved.projectPath
                                        , entryPoints = flags.entryPoints
                                        , outline = resolved.outline
                                        , rootSources = resolved.rootSources
                                        , dependencies = resolved.dependencies
                                        }
                                , onComplete = CompilerRan
                                }
                        )

                CliParser.MakeStatic opts ->
                    runMake model.fsPermission
                        (\resolved ->
                            Compiler.Backend.run
                                model.cpPermission
                                { useColor = model.useColor
                                , compilerPath = compilerPath
                                , pathToString = model.pathToString
                                , onInit = initWithCommand <|
                                    Compiler.Backend.Make
                                        { optimize = True
                                        , sourcemaps = False
                                        , output = Just (Compiler.Backend.Exe <| model.pathToString opts.output)
                                        , report = Nothing
                                        , projectPath = resolved.projectPath
                                        , entryPoints = [ opts.source ]
                                        , outline = resolved.outline
                                        , rootSources = resolved.rootSources
                                        , dependencies = resolved.dependencies
                                        }
                                , onComplete =
                                    (\exitCode ->
                                        CompilerRanStatic
                                            { path = model.pathToString opts.output
                                            , exitCode = exitCode
                                            }
                                    )
                                }
                        )

                CliParser.Docs flags ->
                    Compiler.Backend.run
                        model.cpPermission
                        { useColor = model.useColor
                        , compilerPath = compilerPath
                        , pathToString = model.pathToString
                        , onInit = initWithCommand <| Compiler.Backend.Docs flags 
                        , onComplete = CompilerRan
                        }

                CliParser.PackageInstall Nothing ->
                    Terminal.Package.readProjectOutline model.fsPermission
                        |> Task.map
                            (\{ grenJsonPath, outline } ->
                                { projectPath =
                                    Path.parentPath grenJsonPath
                                        |> Maybe.withDefault grenJsonPath
                                , outline = outline
                                , andThen = (\_ -> Task.succeed {} |> Task.execute)
                                }
                            )
                        |> Task.attempt InitiatePackageInstall

                CliParser.PackageInstall (Just requestedPackage) ->
                    Terminal.Package.readProjectOutline model.fsPermission
                        |> Task.andThen
                            (\{ grenJsonPath, outline } ->
                                let
                                    packageNameStr =
                                        PackageName.toString requestedPackage
                                in
                                when outline is
                                    Outline.App appOutline ->
                                        when
                                            { direct = Dict.member packageNameStr appOutline.dependencies.direct
                                            , transitive = Dict.get packageNameStr appOutline.dependencies.indirect
                                            }
                                        is
                                            { direct = False, transitive = Nothing } ->
                                                Stream.Log.line model.stdout ("Installing " ++ packageNameStr)
                                                    |> Task.andThen
                                                        (\_ ->
                                                            Git.fetchLatestVersion model.cpPermission requestedPackage
                                                        )
                                                    |> Task.mapError
                                                        (\err ->
                                                            Terminal.Package.PackageInstallDebug <| Debug.toString err
                                                        )
                                                    |> Task.andThen
                                                        (\maybeVersion ->
                                                            when maybeVersion is
                                                                Nothing ->
                                                                    Task.fail <| Terminal.Package.PackageInstallDebug "Could not find version"

                                                                Just packageVersion ->
                                                                    Task.succeed packageVersion
                                                        )
                                                    |> Task.map
                                                        (\packageVersion ->
                                                            { projectPath =
                                                                Path.parentPath grenJsonPath
                                                                    |> Maybe.withDefault grenJsonPath
                                                            , outline =
                                                                { appOutline
                                                                    | dependencies =
                                                                        { appOutline.dependencies | direct = Dict.set packageNameStr (Outline.Version packageVersion) appOutline.dependencies.direct
                                                                        }
                                                                }
                                                                |> Outline.App
                                                            , andThen =
                                                                (\resolved ->
                                                                    let
                                                                        originalPackages =
                                                                            (Dict.keys appOutline.dependencies.direct)
                                                                                ++ (Dict.keys appOutline.dependencies.indirect)

                                                                        newPackages =
                                                                            resolved.dependencies
                                                                                |> Dict.keepIf (\k _ -> not <| Array.member k originalPackages)
                                                                                |> Dict.map (\_ value -> value.outline.version)

                                                                        finalOutline =
                                                                            Outline.App
                                                                                { appOutline
                                                                                    | dependencies =
                                                                                        { appOutline.dependencies
                                                                                            | direct = Dict.set packageNameStr (Outline.Version packageVersion) appOutline.dependencies.direct
                                                                                            , indirect =
                                                                                                Dict.union
                                                                                                    appOutline.dependencies.indirect
                                                                                                    (newPackages |> Dict.remove packageNameStr |> Dict.map (\_ v -> Outline.Version v))
                                                                                        }
                                                                                }

                                                                        plan =
                                                                            "The plan is to add the following dependencies:\n\n"
                                                                                ++ (Dict.foldl (\k v acc ->  acc ++ "  " ++ k ++ " " ++ SemanticVersion.toString v ++ "\n") "" newPackages)
                                                                                ++ "\nDo you want me to update the gren.json file accordingly? [Y/n]: "
                                                                    in
                                                                    Stream.Log.string model.stdout plan
                                                                        |> Task.andThen (\_ -> Stream.readBytesAsString model.stdin)
                                                                        |> Task.mapError (\_ -> "Stream error")
                                                                        |> Task.andThen
                                                                            (\answer ->
                                                                                when Maybe.map (String.trim >> String.toLower) answer is
                                                                                    Just "y" ->
                                                                                        Task.succeed {}

                                                                                    Just "" ->
                                                                                        Task.succeed {}

                                                                                    _ ->
                                                                                        Task.fail ""
                                                                            )
                                                                        |> Task.andThen
                                                                            (\{} ->
                                                                                finalOutline
                                                                                    |> Outline.toJson
                                                                                    |> Json.encode 4
                                                                                    |> Task.succeed
                                                                            )
                                                                        |> Task.andThen
                                                                            (\newOutline ->
                                                                                FileSystem.writeFile model.fsPermission (Bytes.fromString newOutline) grenJsonPath
                                                                                    |> Task.mapError (\fsErr -> Debug.toString fsErr)
                                                                                    |> Task.map (\_ -> {})
                                                                            )
                                                                        |> Task.onError
                                                                            (\err ->
                                                                                Stream.Log.line model.stdout ("Error: " ++ err)
                                                                            )
                                                                        |> Task.andThen
                                                                            (\_ ->
                                                                                Stream.Log.line model.stdout "Done"
                                                                            )
                                                                        -- TODO: Refactor
                                                                        -- TODO: Support package installs as well
                                                                        -- TODO: Don't read from stdin if not interactive prompt
                                                                        |> Task.execute
                                                                )
                                                            }
                                                        )

                                            { direct = True } ->
                                                Task.fail <| Terminal.Package.PackageInstallDebug "Already installed"

                                            { transitive = Just packageVersion } ->
                                                Stream.Log.line model.stdout "Move to direct? y/N"
                                                    |> Task.andThen (\_ -> Stream.readBytesAsString model.stdin)
                                                    |> Task.mapError (\_ -> Terminal.Package.PackageInstallDebug "Stream error")
                                                    |> Task.andThen
                                                        (\answer ->
                                                            when Maybe.map (String.trim >> String.toLower) answer is
                                                                Just "y" ->
                                                                    Task.succeed {}

                                                                _ ->
                                                                    Task.fail <| Terminal.Package.PackageInstallDebug ""
                                                        )
                                                    |> Task.andThen
                                                        (\{} ->
                                                            { appOutline
                                                                | dependencies =
                                                                    { direct = Dict.set packageNameStr packageVersion appOutline.dependencies.direct
                                                                    , indirect = Dict.remove packageNameStr appOutline.dependencies.indirect
                                                                    }
                                                            }
                                                            |> Outline.App
                                                            |> Outline.toJson
                                                            |> Json.encode 4
                                                            |> Task.succeed
                                                        )
                                                    |> Task.andThen
                                                        (\newOutline ->
                                                            FileSystem.writeFile model.fsPermission (Bytes.fromString newOutline) grenJsonPath
                                                                |> Task.mapError (\fsErr -> Terminal.Package.PackageInstallDebug (Debug.toString fsErr))
                                                        )
                                                    |> Task.andThen
                                                        (\_ ->
                                                            Task.fail <| Terminal.Package.PackageInstallDebug "done"
                                                        )

                                    Outline.Pkg pkgOutline ->
                                        if Dict.member packageNameStr pkgOutline.dependencies then
                                            Task.fail <| Terminal.Package.PackageInstallDebug "Already installed"

                                        else
                                            Stream.Log.line model.stdout ("Installing " ++ packageNameStr)
                                                |> Task.map
                                                    (\_ ->
                                                        { projectPath =
                                                            Path.parentPath grenJsonPath
                                                                |> Maybe.withDefault grenJsonPath
                                                        , outline = outline
                                                        , andThen = (\_ -> Task.succeed {} |> Task.execute)
                                                        }
                                                    )
                            )
                        |> Task.attempt InitiatePackageInstall

                CliParser.PackageUninstall packageName ->
                    Compiler.Backend.run
                        model.cpPermission
                        { useColor = model.useColor
                        , compilerPath = compilerPath
                        , pathToString = model.pathToString
                        , onInit = initWithCommand <| Compiler.Backend.PackageUninstall packageName
                        , onComplete = CompilerRan
                        }

                CliParser.PackageOutdated ->
                    Compiler.Backend.run
                        model.cpPermission
                        { onInit = initWithCommand <| Compiler.Backend.PackageOutdated
                        , useColor = model.useColor
                        , compilerPath = compilerPath
                        , pathToString = model.pathToString
                        , onComplete = CompilerRan
                        }

                CliParser.PackageValidate ->
                    Compiler.Backend.run
                        model.cpPermission
                        { onInit = initWithCommand <| Compiler.Backend.PackageValidate
                        , useColor = model.useColor
                        , compilerPath = compilerPath
                        , pathToString = model.pathToString
                        , onComplete = CompilerRan
                        }

                CliParser.PackageBump ->
                    Compiler.Backend.run
                        model.cpPermission
                        { onInit = initWithCommand Compiler.Backend.PackageBump
                        , useColor = model.useColor
                        , compilerPath = compilerPath
                        , pathToString = model.pathToString
                        , onComplete = CompilerRan
                        }

                CliParser.PackageDiff args ->
                    Compiler.Backend.run
                        model.cpPermission
                        { onInit = initWithCommand <| Compiler.Backend.PackageDiff args
                        , useColor = model.useColor
                        , compilerPath = compilerPath
                        , pathToString = model.pathToString
                        , onComplete = CompilerRan
                        }

                CliParser.Paths opts ->
                    Terminal.Paths.print
                        { fsPermission = model.fsPermission
                        , stdout = model.stdout
                        , pathToString = model.pathToString
                        , backendPath = model.backendPath
                        }
                        opts


runMake : FileSystem.Permission -> (Terminal.Package.PackageResolution -> Cmd Msg) -> Cmd Msg
runMake fsPermission andThen =
    Compiler.Paths.projectRoot fsPermission
        |> Task.mapError Terminal.Package.PackageInstallNoProject
        |> Task.map (Path.append (Path.fromPosixString "gren.json"))
        |> Task.andThen
            (\grenJsonPath ->
                Terminal.Package.readOutline fsPermission grenJsonPath
                    |> Task.mapError Terminal.Package.PackageInstallNoGrenJson
                    |> Task.andThen
                        (\decodeResult ->
                            when decodeResult is
                                Ok outline ->
                                    Task.succeed
                                        { projectPath =
                                            Path.parentPath grenJsonPath
                                                |> Maybe.withDefault grenJsonPath
                                        , outline = outline
                                        , andThen = andThen
                                        }

                                Err err ->
                                    Task.fail (Terminal.Package.PackageInstallInvalidGrenJson err)
                        )
            )
        |> Task.attempt InitiatePackageInstall


