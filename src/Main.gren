module Main exposing (main)

import Meta
import Node
import ChildProcess
import Terminal.Parser as CliParser
import Terminal.PackageInstall
import Terminal.PackageUninstall
import Terminal.PackageOutdated
import Terminal.PackageBump
import Terminal.PackageDiff
import Terminal.PackageValidate
import Terminal.Paths
import Terminal.Init
import Terminal.Run
import Terminal.Help
import Terminal.Repl
import Compiler.Backend
import Compiler.PackageName as PackageName exposing (PackageName)
import Compiler.Paths
import Compiler.Outline as Outline exposing (Outline)
import Compiler.ModuleName as ModuleName exposing (ModuleName)
import Git
import Init
import Stream
import Stream.Log
import Task exposing (Task)
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import HttpClient
import Bytes exposing (Bytes)
import Terminal
import CLI.Parser
import CLI.PrettyPrinter as PP
import SemanticVersion exposing (SemanticVersion)
import Json.Encode as Json
import Stream.Extra
import Process


main : Node.Program Model Msg
main =
    Node.defineProgram
        { init = init
        , update = update
        , subscriptions = \_model -> Sub.none
        }


type alias Model = 
    { args : Array String
    , stdout : Stream.Writable Bytes
    , stderr : Stream.Writable Bytes
    , stdin : Stream.Readable Bytes
    , useColor : Bool
    , interactive : Bool
    , cacheRoot : Compiler.Paths.CacheRoot
    , backendPath : Path
    , fsPermission : FileSystem.Permission
    , cpPermission : ChildProcess.Permission
    , httpPermission : HttpClient.Permission
    -- TODO: Remove
    , pathToString : Path -> String
    }

init : Node.Environment -> Init.Task { model : Model, command : Cmd Msg }
init env =
    Init.await FileSystem.initialize <| \fsPermission ->
    Init.await ChildProcess.initialize <| \cpPermission ->
    Init.await HttpClient.initialize <| \httpPermission ->
    Init.await Terminal.initialize <| \terminalConfig ->
    Init.awaitTask Node.getEnvironmentVariables <| \envVars ->
    Init.awaitTask (FileSystem.homeDirectory fsPermission) <| \homeDir ->
        let
            userArgs =
                Array.dropFirst 2 env.args

            interactiveTerminal =
                terminalConfig /= Nothing

            useColor =
                interactiveTerminal && not (Dict.member "NO_COLOR" envVars)

            cacheRoot =
                Compiler.Paths.cacheRoot env.platform envVars homeDir Meta.version

            backendBinary =
                Compiler.Paths.backendBinary env.platform cacheRoot                

            maybePaths =
                when { platform = env.platform, override = Dict.get "GREN_BIN" envVars } is
                    { override = Just overridePath, platform = Node.Win32 } ->
                        Just <|
                            { remotePath = Nothing
                            , localPath = Path.fromWin32String overridePath
                            }
                    
                    { override = Just overridePath } ->
                        Just <|
                            { remotePath = Nothing
                            , localPath = Path.fromPosixString overridePath
                            }

                    _ ->
                        Compiler.Backend.downloadUrl env.platform env.cpuArchitecture
                            |> Result.map 
                                (\url ->
                                    { remotePath = Just url
                                    , localPath = backendBinary
                                    }
                                )
                            |> Result.toMaybe

        in
        Node.startProgram
            { model =
                { args = userArgs
                , stdout = env.stdout
                , stderr = env.stderr
                , stdin = env.stdin
                , interactive = interactiveTerminal
                , useColor = useColor
                , cacheRoot = cacheRoot
                , backendPath = backendBinary
                , fsPermission = fsPermission
                , cpPermission = cpPermission
                , httpPermission = httpPermission
                , pathToString =
                    if env.platform == Node.Win32 then
                        Path.toWin32String
                    else
                        Path.toPosixString
                }
            , command =
                when maybePaths is
                    Just paths ->
                        FileSystem.checkAccess fsPermission [] paths.localPath
                            |> Task.attempt 
                                (\result -> 
                                    ExistanceChecked
                                        { maybeRemotePath = paths.remotePath
                                        , localPath = paths.localPath
                                        , existanceResult = result
                                        }
                                )

                    Nothing ->
                        Stream.Log.line env.stderr "We currently don't support this platform/arch."
                            |> Task.andThen (\_ -> Node.exitWithCode 1)
                            |> Task.execute
            }


type Msg
    = ExistanceChecked 
        { maybeRemotePath : Maybe String
        , localPath : Path
        , existanceResult : Result FileSystem.Error Path
        }
    | CompilerDownloaded 
        { localPath : Path
        , downloadResult : Result (HttpClient.Error Bytes) (HttpClient.Response Bytes)
        }
    | CompilerInstalled (Result FileSystem.Error Path)
    | CompilerInitialized { quiet : Bool, backendStreams : ChildProcess.StreamIO, encodedCommand : Bytes }
    | CompilerRan Int
    | CompiledForRun { path : Path, exitCode : Int }
    | RunStarted Process.Id
    | RunExited Int
    | RedirectTerminalIO
        (Result
            { error : Stream.Error
            , source : Stream.Readable Bytes
            , target : Stream.Writable Bytes
            }
            { source : Stream.Readable Bytes
            , target : Stream.Writable Bytes
            }
        )
    | RunCmd (Cmd Msg) -- TODO: remove


update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    let
        endWithError errorStr =
            Stream.Log.line model.stderr errorStr
                |> Task.andThen (\_ -> Node.exitWithCode 1)
                |> Task.execute
    in
    { model = model
    , command =
        when msg is
            ExistanceChecked { maybeRemotePath, localPath, existanceResult = Err _ } ->
                when maybeRemotePath is
                    Just remotePath ->
                        Stream.Log.line model.stdout ("Compiler not found at " ++ model.pathToString localPath ++ ". Downloading...")
                            |> Task.andThen (\_ -> Compiler.Backend.download model.httpPermission remotePath)
                            |> Task.attempt (\result -> CompilerDownloaded { localPath = localPath, downloadResult = result })
            
                    Nothing ->
                        endWithError ("Compiler not found at " ++ model.pathToString localPath)

            ExistanceChecked { existanceResult = Ok compilerPath } ->
                parseUserArgs model compilerPath

            CompilerDownloaded { localPath, downloadResult = Err ((HttpClient.BadStatus res) as err) } ->
                if res.statusCode == 302 then
                    when Dict.get "location" res.headers is
                        Just [ location ] ->
                            Compiler.Backend.download model.httpPermission location
                                |> Task.attempt (\result -> CompilerDownloaded { localPath = localPath, downloadResult = result })

                        _ ->
                            endWithError "Missing, or vague, 'location' header in 302 response from server."

                else
                    endWithError (HttpClient.errorToString err)
        
            CompilerDownloaded { downloadResult = Err err } ->
                endWithError (HttpClient.errorToString err)
        
            CompilerDownloaded { localPath, downloadResult = Ok res } ->
                let
                    cacheFolder =
                        Path.parentPath localPath
                            |> Maybe.withDefault Path.empty
                in
                FileSystem.makeDirectory model.fsPermission { recursive = True } cacheFolder
                    |> Task.andThen (\_cacheFolder -> FileSystem.writeFile model.fsPermission res.data localPath)
                    |> Task.andThen 
                        (FileSystem.changeAccess
                            model.fsPermission
                            { owner = [ FileSystem.Read, FileSystem.Write, FileSystem.Execute ]
                            , group = [ FileSystem.Read, FileSystem.Execute ]
                            , others = [ FileSystem.Read, FileSystem.Execute ]
                            }
                        )
                    |> Task.andThen 
                        (\binPath -> 
                            Stream.Log.line model.stdout "Downloaded"
                                |> Task.map (\_ -> binPath)
                        )
                    |> Task.attempt CompilerInstalled
        
            CompilerInstalled (Err fsErr) ->
                endWithError ("Failed to install binary after download, due to error: " ++ FileSystem.errorToString fsErr)
        
            CompilerInstalled (Ok compilerPath) ->
                parseUserArgs model compilerPath

            CompilerInitialized { backendStreams, encodedCommand, quiet } ->
                Cmd.batch
                    [ Stream.write encodedCommand backendStreams.input
                        |> Task.map (\_ -> { source = model.stdin, target = backendStreams.input })
                        |> Task.mapError
                            (\err ->
                                { error = err
                                , source = model.stdin
                                , target = backendStreams.input
                                }
                            )
                        |> Task.attempt RedirectTerminalIO
                    , if quiet then
                        Cmd.none
                      else
                        Task.succeed { source = backendStreams.output, target = model.stdout }
                            |> Task.attempt RedirectTerminalIO
                    , Task.succeed { source = backendStreams.error, target = model.stderr }
                        |> Task.attempt RedirectTerminalIO
                    ]

            CompilerRan exitCode ->
                Task.execute <| Node.exitWithCode exitCode
            
            CompiledForRun { path, exitCode } ->
                if exitCode == 0 then
                    Terminal.Run.run 
                        { cpPermission = model.cpPermission
                        , fsPermission = model.fsPermission
                        , pathToString = model.pathToString
                        , path = path
                        , onInit = \{ processId } -> RunStarted processId
                        , onExit = RunExited
                        }
                        |> Task.onError
                            (\error ->
                                Terminal.Run.prettifyError error
                                    |> Terminal.Help.prettyPrint { useColor = model.useColor }
                                    |> Stream.Log.line model.stderr
                                    |> Task.map (\_ -> Task.execute <| Node.exitWithCode 1)
                            )
                        |> Task.perform RunCmd

                else
                    Task.execute <| Node.exitWithCode exitCode

            RunStarted _ ->
                Cmd.none

            RunExited exitCode ->
                Task.execute <| Node.exitWithCode exitCode

            RedirectTerminalIO (Ok streams) ->
                Stream.read streams.source
                    |> Task.andThen (\str -> Stream.write str streams.target)
                    |> Task.map (\_ -> streams)
                    |> Task.mapError
                        (\err ->
                            { error = err
                            , source = streams.source
                            , target = streams.target
                            }
                        )
                    |> Task.attempt RedirectTerminalIO

            RedirectTerminalIO (Err { error, source, target }) ->
                when error is
                    Stream.Closed ->
                        Cmd.none

                    _ ->
                        Stream.Log.line model.stderr ("Something went wrong when communicating with compiler backend: " ++ Stream.errorToString error)
                            |> Task.andThen (\_ -> Node.exitWithCode 1)
                            |> Task.execute

            RunCmd cmd ->
                cmd
        }


parseUserArgs : Model -> Path -> Cmd Msg
parseUserArgs model compilerPath =
    let
        printOpts =
            { useColor = model.useColor
            }

        endWithError prettyErr =
            Terminal.Help.prettyPrint printOpts prettyErr
                |> Stream.Log.string model.stderr
                |> Task.map (\_ -> Task.execute <| Node.exitWithCode 1)

        endWithErrorString stringErr =
            Stream.Log.string model.stderr stringErr
                |> Task.map (\_ -> Task.execute <| Node.exitWithCode 1)
    in
    when CLI.Parser.run model.args CliParser.parser is
        CLI.Parser.UnknownCommand commandName ->
            endWithErrorString ("I don't recognize this command: " ++ commandName)
                |> Task.perform RunCmd
    
        CLI.Parser.BadFlags err ->
            err
                |> CLI.Parser.flagErrorPrettified
                |> endWithError
                |> Task.perform RunCmd
    
        CLI.Parser.BadArguments err ->
            err
                |> CLI.Parser.argumentErrorPrettified
                |> endWithError
                |> Task.perform RunCmd
    
        CLI.Parser.HelpText prettifiedText ->
            prettifiedText
                |> Terminal.Help.prettyPrint printOpts
                |> Stream.Log.line model.stdout
                |> Task.execute
    
        CLI.Parser.Success parsedCommand ->
            let
                initWithCommand backendCommand =
                    \cpOpts ->
                        when cpOpts.streams is
                            Nothing ->
                                RunCmd Cmd.none

                            Just streams ->
                                CompilerInitialized
                                    { backendStreams = streams
                                    , quiet = False
                                    , encodedCommand =
                                        Compiler.Backend.encodeCommand
                                            { interactiveSession = model.interactive
                                            , pathToString = model.pathToString
                                            }
                                            backendCommand
                                    }
            in
            when parsedCommand is
                CliParser.Init flags ->
                    Terminal.Init.run
                        { fsPermission = model.fsPermission
                        , cpPermission = model.cpPermission
                        , cacheRoot = model.cacheRoot
                        , stdout = model.stdout
                        , stdin = model.stdin
                        , interactive = model.interactive
                        , useColor = model.useColor
                        , package = flags.package
                        , platform = flags.platform
                        }
                        |> Task.map (\_ -> Cmd.none)
                        |> Task.mapError Terminal.Init.prettifyError
                        |> Task.onError endWithError
                        |> Task.perform RunCmd

                CliParser.Repl flags ->
                    Terminal.PackageInstall.readProjectOutline model.fsPermission
                        |> Task.onError
                            (\err ->
                                when err is
                                    Terminal.PackageInstall.ReadProjectOutlineNoProject _ ->
                                        Terminal.Repl.setupGlobalReplProject
                                            { stdout = model.stdout
                                            , stdin = model.stdin
                                            , fsPermission = model.fsPermission
                                            , cpPermission = model.cpPermission
                                            , cacheRoot = model.cacheRoot
                                            , useColor = model.useColor
                                            }
                                            |> Task.mapError Terminal.Repl.prettifyError

                                    _ ->
                                        Task.fail err
                                            |> Task.mapError Terminal.PackageInstall.prettifyProjectOutlineError
                            )
                        |> Task.andThen
                            (\projectOutline ->
                                Terminal.PackageInstall.run
                                    { fsPermission = model.fsPermission
                                    , cpPermission = model.cpPermission
                                    , cacheRoot = model.cacheRoot
                                    , interactive = model.interactive
                                    , useColor = model.useColor
                                    , stdout = model.stdout
                                    , stdin = model.stdin
                                    , strictAppResolution = True
                                    }
                                    projectOutline
                                    |> Task.mapError Terminal.PackageInstall.prettifyError
                            )
                        |> Task.map
                            (\resolved ->
                                Compiler.Backend.run
                                    model.cpPermission
                                    { useColor = model.useColor
                                    , compilerPath = compilerPath
                                    , pathToString = model.pathToString
                                    , onInit =
                                        initWithCommand <|
                                            Compiler.Backend.Repl
                                                { interpreter = flags.interpreter
                                                , projectPath = resolved.projectPath
                                                , outline = resolved.outline
                                                , rootSources = resolved.rootSources
                                                , dependencies = resolved.dependencies
                                                }
                                    , onComplete = CompilerRan
                                    }
                            )
                        |> Task.onError endWithError
                        |> Task.perform RunCmd

                CliParser.Make flags ->
                    resolveProject model
                        |> Task.andThen (verifyMakeFlags model.fsPermission flags.entryPoints flags.output)
                        |> Task.map
                            (\resolved ->
                                Compiler.Backend.run
                                    model.cpPermission
                                    { useColor = model.useColor
                                    , compilerPath = compilerPath
                                    , pathToString = model.pathToString
                                    , onInit = initWithCommand <|
                                        Compiler.Backend.Make
                                            { optimize = flags.optimize
                                            , sourcemaps = flags.sourcemaps
                                            , output = flags.output
                                            , report = flags.report
                                            , projectPath = resolved.projectPath
                                            , entryPoints = flags.entryPoints
                                            , outline = resolved.outline
                                            , rootSources = resolved.rootSources
                                            , dependencies = resolved.dependencies
                                            }
                                    , onComplete = CompilerRan
                                    }
                            )
                        |> Task.onError endWithError
                        |> Task.perform RunCmd

                CliParser.Run opts ->
                    Terminal.Run.make
                        { fsPermission = model.fsPermission
                        , cpPermission = model.cpPermission
                        , cacheRoot = model.cacheRoot
                        , useColor = model.useColor
                        , compilerPath = compilerPath
                        , pathToString = model.pathToString
                        , moduleName = opts.moduleName
                        , package = opts.package
                        , onBackendInitialized = 
                            (\{ backendStreams, encodedCommand } ->
                                when backendStreams is
                                    Nothing ->
                                        RunCmd Cmd.none

                                    Just streams ->
                                        CompilerInitialized
                                            { backendStreams = streams
                                            , encodedCommand = encodedCommand
                                            , quiet = True
                                            }
                            )
                        , onCompiled = 
                            (\outputPath exitCode ->
                                CompiledForRun
                                    { path = outputPath
                                    , exitCode = exitCode
                                    }
                            )
                        }
                        |> Task.mapError Terminal.Run.prettifyError
                        |> Task.onError endWithError
                        |> Task.perform RunCmd

                CliParser.Docs flags ->
                    resolveProject model
                        |> Task.map
                            (\resolved ->
                                Compiler.Backend.run
                                    model.cpPermission
                                    { useColor = model.useColor
                                    , compilerPath = compilerPath
                                    , pathToString = model.pathToString
                                    , onInit =
                                        initWithCommand <|
                                            Compiler.Backend.Docs
                                                { output = flags.output
                                                , report = flags.report
                                                , projectPath = resolved.projectPath
                                                , outline = resolved.outline
                                                , rootSources = resolved.rootSources
                                                , dependencies = resolved.dependencies
                                                }
                                    , onComplete = CompilerRan
                                    }
                            )
                        |> Task.onError endWithError
                        |> Task.perform RunCmd

                CliParser.PackageInstall Nothing ->
                    resolveProject model
                        |> Task.andThen
                            (\res ->
                                Terminal.PackageInstall.cleanPackageDirectory model.fsPermission res
                                    |> Task.mapError (\_ -> PP.empty)
                            )
                        |> Task.map (\_ -> Cmd.none)
                        |> Task.onError endWithError
                        |> Task.perform RunCmd

                CliParser.PackageInstall (Just requestedPackage) ->
                    Terminal.PackageInstall.readProjectOutline model.fsPermission
                        |> Task.mapError Terminal.PackageInstall.prettifyProjectOutlineError
                        |> Task.andThen
                            (\projectOutline ->
                                Terminal.PackageInstall.addPackage
                                    { fsPermission = model.fsPermission
                                    , cpPermission = model.cpPermission
                                    , cacheRoot = model.cacheRoot
                                    , interactive = model.interactive
                                    , useColor = model.useColor
                                    , stdout = model.stdout
                                    , stdin = model.stdin
                                    , strictAppResolution = True
                                    }
                                    projectOutline
                                    requestedPackage
                                    |> Task.mapError Terminal.PackageInstall.prettifyAddPackageError
                            )
                        |> Task.map (\_ -> Cmd.none)
                        |> Task.onError endWithError
                        |> Task.perform RunCmd

                CliParser.PackageUninstall packageName ->
                    Terminal.PackageInstall.readProjectOutline model.fsPermission
                        |> Task.mapError Terminal.PackageInstall.prettifyProjectOutlineError
                        |> Task.andThen
                            (\projectOutline ->
                                Terminal.PackageUninstall.run
                                    { fsPermission = model.fsPermission
                                    , cpPermission = model.cpPermission
                                    , cacheRoot = model.cacheRoot
                                    , interactive = model.interactive
                                    , useColor = model.useColor
                                    , stdout = model.stdout
                                    , stdin = model.stdin
                                    }
                                    projectOutline
                                    packageName
                                    |> Task.mapError Terminal.PackageUninstall.prettifyError
                                    |> Task.andThen
                                        (\res ->
                                            Terminal.PackageInstall.cleanPackageDirectory model.fsPermission res
                                                |> Task.mapError (\_ -> PP.empty)
                                        )
                            )
                        |> Task.map (\_ -> Cmd.none)
                        |> Task.onError endWithError
                        |> Task.perform RunCmd

                CliParser.PackageOutdated ->
                    Terminal.PackageInstall.readProjectOutline model.fsPermission
                        |> Task.mapError Terminal.PackageInstall.prettifyProjectOutlineError
                        |> Task.andThen
                            (\projectOutline ->
                                Terminal.PackageOutdated.run
                                    { fsPermission = model.fsPermission
                                    , cpPermission = model.cpPermission
                                    , interactive = model.interactive
                                    , useColor = model.useColor
                                    , stdout = model.stdout
                                    , stdin = model.stdin
                                    }
                                    projectOutline
                                    |> Task.mapError Terminal.PackageOutdated.prettifyError
                            )
                        |> Task.map (\_ -> Cmd.none)
                        |> Task.onError endWithError
                        |> Task.perform RunCmd

                CliParser.PackageValidate ->
                    Terminal.PackageInstall.readProjectOutline model.fsPermission
                        |> Task.mapError Terminal.PackageInstall.prettifyProjectOutlineError
                        |> Task.andThen
                            (\projectOutline ->
                                Terminal.PackageValidate.run
                                    { fsPermission = model.fsPermission
                                    , cpPermission = model.cpPermission
                                    , cacheRoot = model.cacheRoot
                                    , interactive = model.interactive
                                    , useColor = model.useColor
                                    , stdout = model.stdout
                                    , stdin = model.stdin
                                    }
                                    projectOutline
                                    |> Task.mapError Terminal.PackageValidate.prettifyError
                            )
                        |> Task.map
                            (\backendFlags ->
                                Compiler.Backend.run
                                    model.cpPermission
                                    { onInit =
                                        initWithCommand <|
                                            Compiler.Backend.PackageValidate backendFlags
                                    , useColor = model.useColor
                                    , compilerPath = compilerPath
                                    , pathToString = model.pathToString
                                    , onComplete = CompilerRan
                                    }
                            )
                        |> Task.onError endWithError
                        |> Task.perform RunCmd

                CliParser.PackageBump ->
                    Terminal.PackageInstall.readProjectOutline model.fsPermission
                        |> Task.mapError Terminal.PackageInstall.prettifyProjectOutlineError
                        |> Task.andThen
                            (\projectOutline ->
                                Terminal.PackageBump.run
                                    { fsPermission = model.fsPermission
                                    , cpPermission = model.cpPermission
                                    , cacheRoot = model.cacheRoot
                                    , interactive = model.interactive
                                    , useColor = model.useColor
                                    , stdout = model.stdout
                                    , stdin = model.stdin
                                    }
                                    projectOutline
                                    |> Task.mapError Terminal.PackageBump.prettifyError
                            )
                        |> Task.map
                            (\backendFlags ->
                                Compiler.Backend.run
                                    model.cpPermission
                                    { onInit =
                                        initWithCommand <|
                                            Compiler.Backend.PackageBump backendFlags
                                    , useColor = model.useColor
                                    , compilerPath = compilerPath
                                    , pathToString = model.pathToString
                                    , onComplete = CompilerRan
                                    }
                            )
                        |> Task.onError endWithError
                        |> Task.perform RunCmd

                CliParser.PackageDiff args ->
                    let
                        diffTask =
                            when args is
                                CliParser.DiffLatest ->
                                    Terminal.PackageDiff.runLocal
                                        { fsPermission = model.fsPermission
                                        , cpPermission = model.cpPermission
                                        , cacheRoot = model.cacheRoot
                                        , interactive = model.interactive
                                        , useColor = model.useColor
                                        , stdout = model.stdout
                                        , stdin = model.stdin
                                        }
                                        Nothing
                                        |> Task.mapError Terminal.PackageDiff.prettifyLocalError

                                CliParser.DiffVersion version ->
                                    Terminal.PackageDiff.runLocal
                                        { fsPermission = model.fsPermission
                                        , cpPermission = model.cpPermission
                                        , cacheRoot = model.cacheRoot
                                        , interactive = model.interactive
                                        , useColor = model.useColor
                                        , stdout = model.stdout
                                        , stdin = model.stdin
                                        }
                                        (Just version)
                                        |> Task.mapError Terminal.PackageDiff.prettifyLocalError

                                CliParser.DiffRange { lower, upper } ->
                                    Terminal.PackageInstall.readProjectOutline model.fsPermission
                                        |> Task.mapError Terminal.PackageInstall.prettifyProjectOutlineError
                                        |> Task.andThen
                                            (\{ outline } ->
                                                when outline is
                                                    Outline.App _ ->
                                                        -- TODO
                                                        Terminal.PackageDiff.LocalCannotDiffApplication
                                                            |> Terminal.PackageDiff.prettifyLocalError 
                                                            |> Task.fail

                                                    Outline.Pkg pkgOutline ->
                                                        Terminal.PackageDiff.runGlobal
                                                            { fsPermission = model.fsPermission
                                                            , cpPermission = model.cpPermission
                                                            , cacheRoot = model.cacheRoot
                                                            , interactive = model.interactive
                                                            , useColor = model.useColor
                                                            , stdout = model.stdout
                                                            , stdin = model.stdin
                                                            }
                                                            pkgOutline.name
                                                            lower
                                                            upper
                                                            |> Task.mapError Terminal.PackageDiff.prettifyGlobalError
                                            )

                                CliParser.DiffGlobal { package, lower, upper } ->
                                    Terminal.PackageDiff.runGlobal
                                        { fsPermission = model.fsPermission
                                        , cpPermission = model.cpPermission
                                        , cacheRoot = model.cacheRoot
                                        , interactive = model.interactive
                                        , useColor = model.useColor
                                        , stdout = model.stdout
                                        , stdin = model.stdin
                                        }
                                        package
                                        lower
                                        upper
                                        |> Task.mapError Terminal.PackageDiff.prettifyGlobalError
                    in
                    diffTask
                        |> Task.map
                            (\backendFlags ->
                                Compiler.Backend.run
                                    model.cpPermission
                                    { onInit =
                                        initWithCommand <|
                                            Compiler.Backend.PackageDiff backendFlags
                                    , useColor = model.useColor
                                    , compilerPath = compilerPath
                                    , pathToString = model.pathToString
                                    , onComplete = CompilerRan
                                    }
                            )
                        |> Task.onError endWithError
                        |> Task.perform RunCmd

                CliParser.Paths opts ->
                    Terminal.Paths.run
                        { fsPermission = model.fsPermission
                        , stdout = model.stdout
                        , pathToString = model.pathToString
                        , cacheRoot = model.cacheRoot
                        , backendPath = model.backendPath
                        }
                        opts
                        |> Task.map (\_ -> Cmd.none)
                        |> Task.mapError Terminal.Paths.errorToString
                        |> Task.onError endWithErrorString
                        |> Task.perform RunCmd


resolveProject : Model -> Task PP.Document Terminal.PackageInstall.PackageResolution
resolveProject model =
    Terminal.PackageInstall.readProjectOutline model.fsPermission
        |> Task.mapError Terminal.PackageInstall.prettifyProjectOutlineError
        |> Task.andThen
            (\projectOutline ->
                Terminal.PackageInstall.run
                    { fsPermission = model.fsPermission
                    , cpPermission = model.cpPermission
                    , cacheRoot = model.cacheRoot
                    , interactive = model.interactive
                    , useColor = model.useColor
                    , stdout = model.stdout
                    , stdin = model.stdin
                    , strictAppResolution = True
                    }
                    projectOutline
                    |> Task.mapError Terminal.PackageInstall.prettifyError
            )


-- TODO: Move to gren-lang/compiler-node
verifyMakeFlags : FileSystem.Permission -> Array ModuleName  -> Maybe Compiler.Backend.MakeOutput -> Terminal.PackageInstall.PackageResolution -> Task PP.Document Terminal.PackageInstall.PackageResolution
verifyMakeFlags fsPermission entryPoints maybeOutput resolution =
    let
        maybeOutputPath =
            when maybeOutput is
                Nothing ->
                    Nothing

                Just Compiler.Backend.StdOut ->
                    Nothing
                    
                Just Compiler.Backend.DevNull ->
                    Nothing

                Just (Compiler.Backend.Html strPath) ->
                    Just strPath

                Just (Compiler.Backend.Js strPath) ->
                    Just strPath

                Just (Compiler.Backend.Exe strPath) ->
                    Just strPath

        compatibleOutputCheck =
            when maybeOutputPath is
                Nothing ->
                    Task.succeed {}

                Just strPath ->
                    Node.getPlatform
                        |> Task.map
                            (\platform ->
                                when platform is
                                    Node.Win32 ->
                                        Path.fromWin32String strPath

                                    _ ->
                                        Path.fromPosixString strPath
                            )
                        |> Task.andThen
                            (\path ->
                                FileSystem.metadata fsPermission { resolveLink = False } path
                                    |> Task.mapError
                                        (\fsError ->
                                            Terminal.Help.report
                                                "CANNOT ACCESS OUTPUT PATH"
                                                (Just path)
                                                (PP.verticalBlock
                                                    [ PP.words
                                                        ( "You have told me to compile this project to "
                                                            ++ Path.toPosixString path
                                                            ++ ", but I cannot access this path for some reason!"
                                                        )
                                                    ]
                                                )
                                        )
                                    |> Task.andThen
                                        (\metadata ->
                                            if metadata.entityType == FileSystem.Directory then
                                                Task.fail <|
                                                    Terminal.Help.report
                                                        "OUTPUT PATH IS A DIRECTORY"
                                                        (Just path)
                                                        (PP.verticalBlock
                                                            [ PP.words
                                                                ( "You have told me to compile this project to "
                                                                    ++ Path.toPosixString path
                                                                    ++ ", but this is a directory!"
                                                                )
                                                            ]
                                                        )

                                            else
                                                Task.succeed {}
                                        )
                                )
    in
    compatibleOutputCheck
        |> Task.andThen
            (\{} ->
                when Array.findFirst (\moduleName -> not <| Dict.member (ModuleName.toString moduleName) resolution.rootSources) entryPoints is
                    Nothing ->
                        Task.succeed resolution

                    Just { value = moduleName } ->
                        Task.fail <|
                            Terminal.Help.report
                                "MODULE DOES NOT EXIST"
                                Nothing
                                (PP.verticalBlock
                                    [ PP.words
                                        ( "You have told me to compile "
                                            ++ ModuleName.toString moduleName
                                            ++ ", but this module isn't defined in this project!"
                                        )
                                    ]
                                )
            )
