module Terminal.PackageUninstall exposing
    ( Error (..)
    , run
    )


import CLI.PrettyPrinter as PP
import ChildProcess
import Compiler.PackageName as PackageName exposing (PackageName)
import Compiler.Paths
import Compiler.Outline as Outline exposing (Outline)
import Compiler.Dependencies
import Git
import Stream
import Stream.Log
import Task exposing (Task)
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import Bytes exposing (Bytes)
import SemanticVersion exposing (SemanticVersion)
import SemanticVersionRange exposing (SemanticVersionRange)
import Json.Encode as Json
import Json.Decode as Decode exposing (Decoder)
import Stream.Extra
import Terminal.Help as Help
import Terminal.PackageInstall


type alias Config =
    { fsPermission : FileSystem.Permission
    , cpPermission : ChildProcess.Permission
    , interactive : Bool
    , useColor : Bool
    , stdout : Stream.Writable Bytes
    , stdin : Stream.Readable Bytes
    }


type alias Options =
    { projectPath : Path
    , outline : Outline
    }


type Error
    = PackageInstallNoProject FileSystem.Error
    | PackageInstallNoGrenJson FileSystem.Error
    | PackageInstallInvalidGrenJson Decode.Error
    | PackageInstallDebug String


-- TODO: Also remove indirect dependencies which are no longer needed
-- TODO: Suggest moving a direct dependency to indirect
-- TODO: Make sure to clean gren_packages folder
run : Config -> Options -> PackageName -> Task Error {}
run config { projectPath, outline } requestedPackage =
    let
        packageNameStr =
            PackageName.toString requestedPackage

        grenJsonPath =
            Path.append (Path.fromPosixString "gren.json") projectPath
    in
    when outline is
        Outline.App appOutline ->
            when
                { direct = Dict.member packageNameStr appOutline.dependencies.direct
                , transitive = Dict.get packageNameStr appOutline.dependencies.indirect
                }
            is
                { direct = False, transitive = Nothing } ->
                    Task.fail <| PackageInstallDebug "Package not installed"

                { direct = True } ->
                    Stream.Log.line config.stdout ("Removing " ++ packageNameStr)
                        |> Task.andThen
                            (\packageVersion ->
                                Terminal.PackageInstall.run
                                    config
                                    { projectPath = projectPath
                                    , outline =
                                        { appOutline
                                            | dependencies =
                                                { appOutline.dependencies | direct = Dict.remove packageNameStr appOutline.dependencies.direct
                                                }
                                        }
                                        |> Outline.App
                                    }
                                    |> Task.mapError (\err -> PackageInstallDebug (Debug.toString err))
                            )
                        |> Task.andThen
                            (\resolved ->
                                let
                                    originalPackages =
                                        Dict.union appOutline.dependencies.direct appOutline.dependencies.indirect

                                    newPackages =
                                        Dict.keys resolved.dependencies

                                    finalOutline =
                                        Outline.App
                                            { appOutline
                                                | dependencies =
                                                    { appOutline.dependencies
                                                        | direct = Dict.keepIf (\k _ -> Array.member k newPackages) appOutline.dependencies.direct
                                                        , indirect = Dict.keepIf (\k _ -> Array.member k newPackages) appOutline.dependencies.indirect
                                                    }
                                            }

                                    removedPackages =
                                        Dict.keepIf (\k _ -> not <| Array.member k newPackages) originalPackages
                                            |> Dict.keys

                                    plan =
                                        PP.verticalBlock
                                            [ PP.words "The plan is to remove the following dependencies:"
                                            , PP.empty
                                            , removedPackages
                                                |> Array.map PP.text
                                                |> PP.verticalBlock
                                                |> PP.indent
                                            , PP.empty
                                            , PP.words "Do you want me to update the gren.json file accordingly?"
                                            ]
                                in
                                Help.confirm
                                    { stdout = config.stdout
                                    , stdin = config.stdin
                                    , useColor = config.useColor
                                    , interactive = config.interactive
                                    , question = plan
                                    , defaultValue = True
                                    }
                                    |> Task.mapError (\_ -> "Stream error")
                                    |> Task.andThen
                                        (\confirmed ->
                                            if confirmed then
                                                finalOutline
                                                    |> Outline.toJson
                                                    |> Json.encode 4
                                                    |> Task.succeed

                                            else
                                                Task.fail ""
                                        )
                                    |> Task.andThen
                                        (\newOutline ->
                                            FileSystem.writeFile config.fsPermission (Bytes.fromString newOutline) grenJsonPath
                                                |> Task.mapError (\fsErr -> Debug.toString fsErr)
                                                |> Task.map (\_ -> {})
                                        )
                                    |> Task.onError
                                        (\err ->
                                            Stream.Log.line config.stdout ("Error: " ++ err)
                                        )
                                    |> Task.andThen
                                        (\_ ->
                                            Stream.Log.line config.stdout "Done"
                                        )
                            )

                { transitive = Just packageVersion } ->
                    -- TODO: implement
                    Stream.Log.line config.stdout ("Removing " ++ packageNameStr)

        Outline.Pkg pkgOutline ->
            if Dict.member packageNameStr pkgOutline.dependencies then
                -- TODO: implement
                Stream.Log.line config.stdout ("Removing " ++ packageNameStr)

            else
               Task.fail <| PackageInstallDebug "Package not installed"
