module Terminal.PackageUninstall exposing
    ( Error (..)
    , run
    )


import CLI.PrettyPrinter as PP
import ChildProcess
import Compiler.PackageName as PackageName exposing (PackageName)
import Compiler.Paths
import Compiler.Outline as Outline exposing (Outline)
import Compiler.Dependencies
import Git
import Stream
import Stream.Log
import Task exposing (Task)
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import Bytes exposing (Bytes)
import SemanticVersion exposing (SemanticVersion)
import SemanticVersionRange exposing (SemanticVersionRange)
import Json.Encode as Json
import Json.Decode as Decode exposing (Decoder)
import Stream.Extra
import Terminal.Help as Help
import Terminal.PackageInstall


type alias Config =
    { fsPermission : FileSystem.Permission
    , cpPermission : ChildProcess.Permission
    , interactive : Bool
    , useColor : Bool
    , stdout : Stream.Writable Bytes
    , stdin : Stream.Readable Bytes
    }


type alias Options =
    { projectPath : Path
    , outline : Outline
    }


type Error
    = PackageInstallNoProject FileSystem.Error
    | PackageInstallNoGrenJson FileSystem.Error
    | PackageInstallInvalidGrenJson Decode.Error
    | PackageInstallDebug String


-- TODO: Also remove indirect dependencies which are no longer needed
-- TODO: Suggest moving a direct dependency to indirect
-- TODO: Make sure to clean gren_packages folder
run : Config -> Options -> PackageName -> Task Error {}
run config { projectPath, outline } requestedPackage =
    let
        packageNameStr =
            PackageName.toString requestedPackage

        grenJsonPath =
            Path.append (Path.fromPosixString "gren.json") projectPath
    in
    when outline is
        Outline.App appOutline ->
            when
                { direct = Dict.member packageNameStr appOutline.dependencies.direct
                , transitive = Dict.get packageNameStr appOutline.dependencies.indirect
                }
            is
                { direct = False, transitive = Nothing } ->
                    Task.fail <| PackageInstallDebug "Package not installed"

                { direct = True } ->
                    Stream.Log.line config.stdout ("Removing " ++ packageNameStr)
                        |> Task.andThen
                            (\packageVersion ->
                                Terminal.PackageInstall.run
                                    config
                                    { projectPath = projectPath
                                    , outline =
                                        { appOutline
                                            | dependencies =
                                                { appOutline.dependencies | direct = Dict.remove packageNameStr appOutline.dependencies.direct
                                                }
                                        }
                                        |> Outline.App
                                    }
                                    |> Task.mapError (\err -> PackageInstallDebug (Debug.toString err))
                            )
                        |> Task.andThen
                            (\resolved ->
                                let
                                    originalPackages =
                                        Dict.union appOutline.dependencies.direct appOutline.dependencies.indirect

                                    newPackages =
                                        Dict.keys resolved.dependencies

                                    finalOutline =
                                        Outline.App
                                            { appOutline
                                                | dependencies =
                                                    { appOutline.dependencies
                                                        | direct = Dict.keepIf (\k _ -> Array.member k newPackages) appOutline.dependencies.direct
                                                        , indirect = Dict.keepIf (\k _ -> Array.member k newPackages) appOutline.dependencies.indirect
                                                    }
                                            }

                                    removedPackages =
                                        Dict.keepIf (\k _ -> not <| Array.member k newPackages) originalPackages
                                            |> Dict.keys

                                    plan =
                                        PP.verticalBlock
                                            [ PP.words "The plan is to remove the following dependencies:"
                                            , PP.empty
                                            , removedPackages
                                                |> Array.map PP.text
                                                |> PP.verticalBlock
                                                |> PP.indent
                                            , PP.empty
                                            , PP.words "Do you want me to update the gren.json file accordingly?"
                                            ]
                                in
                                Help.confirm
                                    { stdout = config.stdout
                                    , stdin = config.stdin
                                    , interactive = config.interactive
                                    , question = plan
                                    , defaultValue = True
                                    }
                                    |> Task.mapError (\_ -> "Stream error")
                                    |> Task.andThen
                                        (\confirmed ->
                                            if confirmed then
                                                finalOutline
                                                    |> Outline.toJson
                                                    |> Json.encode 4
                                                    |> Task.succeed

                                            else
                                                Task.fail ""
                                        )
                                    |> Task.andThen
                                        (\newOutline ->
                                            FileSystem.writeFile config.fsPermission (Bytes.fromString newOutline) grenJsonPath
                                                |> Task.mapError (\fsErr -> Debug.toString fsErr)
                                                |> Task.map (\_ -> {})
                                        )
                                    |> Task.onError
                                        (\err ->
                                            Stream.Log.line config.stdout ("Error: " ++ err)
                                        )
                                    |> Task.andThen
                                        (\_ ->
                                            Stream.Log.line config.stdout "Done"
                                        )
                            )

                { transitive = Just packageVersion } ->
                    Stream.Log.line config.stdout ("Removing " ++ packageNameStr)

        Outline.Pkg pkgOutline ->
            if Dict.member packageNameStr pkgOutline.dependencies then
                Stream.Log.line config.stdout ("Removing " ++ packageNameStr)

            else
               Task.fail <| PackageInstallDebug "Package not installed"


outdatedDeps : Config -> Options -> Task Error {}
outdatedDeps config { projectPath, outline } =
    let
        grenJsonPath =
            Path.append (Path.fromPosixString "gren.json") projectPath

        deps =
            when outline is
                Outline.App appOutline ->
                    Dict.union appOutline.dependencies.direct appOutline.dependencies.indirect
                        |> Dict.mapAndKeepJust (\_ v -> extractVersion v)
                        |> Dict.map (\_ v -> SemanticVersionRange.fromExact v)

                Outline.Pkg pkgOutline ->
                    pkgOutline.dependencies
                        |> Dict.mapAndKeepJust (\_ v -> extractVersion v)

        extractVersion cons =
            when cons is
                Outline.Version v ->
                    Just v

                Outline.LocalPath _ ->
                    Nothing
    in
    deps
        |> Dict.foldl
            (\packageStr versionRange tasks ->
                when PackageName.fromString packageStr is
                    Nothing ->
                        tasks

                    Just packageName ->
                        let
                            task =
                                Git.fetchVersions config.cpPermission packageName
                                    |> Task.map (\vs -> Array.keepIf (\v -> SemanticVersion.compare v (SemanticVersionRange.lowerBound versionRange) == GT) vs)
                                    |> Task.map (\vs -> { name = packageName, versions = vs })
                        in
                        Array.pushLast task tasks
            )
            []
        |> Task.concurrent
        |> Task.mapError (\_ -> PackageInstallDebug "failed to get versions")
        |> Task.map
            (\vs ->
                Array.mapAndKeepJust
                    (\p ->
                        when Array.last p.versions is
                            Just v ->
                                Just
                                    { name = p.name
                                    , version = v
                                    }

                            Nothing ->
                                Nothing
                    )
                    vs
            )
        |> Task.andThen
            (\vs ->
                if vs == [] then
                    Stream.Log.line config.stdout "All dependencies are up to date."

                else
                    let
                        plan =
                            "The plan is to update the following dependencies:\n\n"
                                ++ (Array.foldl (\package acc -> acc ++ "  " ++ PackageName.toString package.name ++ " " ++ SemanticVersion.toString package.version ++ "\n") "" vs)
                                ++ "\nDo you want me to update the gren.json file accordingly? [Y/n]: "
                    in
                    Stream.Log.line config.stdout plan
            )
