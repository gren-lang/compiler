module Terminal.PackageDiff exposing
    ( Config
    , Options
    , Error (..)
    , Result
    , runLocal
    , runGlobal
    )


import ChildProcess
import Compiler.Backend
import Compiler.PackageName as PackageName exposing (PackageName)
import Compiler.Paths
import Compiler.Outline as Outline exposing (Outline)
import Compiler.Dependencies
import Git
import Stream
import Stream.Log
import Task exposing (Task)
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import Bytes exposing (Bytes)
import SemanticVersion exposing (SemanticVersion)
import SemanticVersionRange exposing (SemanticVersionRange)
import Json.Encode as Json
import Json.Decode as Decode exposing (Decoder)
import Stream.Extra
import Terminal.User as User
import Terminal.PackageInstall


type alias Config =
    { fsPermission : FileSystem.Permission
    , cpPermission : ChildProcess.Permission
    , interactive : Bool
    , useColor : Bool
    , stdout : Stream.Writable Bytes
    , stdin : Stream.Readable Bytes
    }


type alias Options =
    { projectPath : Path
    , outline : Outline
    }


type Error
    = ErrorDebug String


type alias Result =
    { projectPath : Path
    , firstPackage :
        { outline : Outline
        , rootSources : Dict String String
        , dependencies : Dict String { outline : Outline.PkgOutline, sources : Dict String String }
        }
    , secondPackage :
        { outline : Outline
        , rootSources : Dict String String
        , dependencies : Dict String { outline : Outline.PkgOutline, sources : Dict String String }
        }
    }


runLocal : Config -> Maybe SemanticVersion -> Task String Result
runLocal config maybeVersion =
    Terminal.PackageInstall.readProjectOutline config.fsPermission
        |> Task.mapError Debug.toString
        |> Task.andThen
            (\{ projectPath, outline } ->
                when outline is
                    Outline.App _ ->
                        Task.fail "Can only use bump on packages"

                    Outline.Pkg pkgOutline ->
                        let
                            versionTask =
                                when maybeVersion is
                                    Just v ->
                                        Task.succeed v

                                    Nothing ->
                                        Git.fetchVersions config.cpPermission pkgOutline.name
                                            |> Task.mapError Debug.toString
                                            |> Task.andThen
                                                (\knownVersions ->
                                                    if Array.isEmpty knownVersions then
                                                        Task.fail "No published versions"

                                                    else
                                                        Array.last knownVersions
                                                            |> Maybe.withDefault
                                                                { major = 1
                                                                , minor = 0
                                                                , patch = 0
                                                                }
                                                            |> Task.succeed
                                                )
                        in
                        versionTask
                            |> Task.andThen
                                (\remoteVersion ->
                                    Terminal.PackageInstall.run
                                        { fsPermission = config.fsPermission
                                        , cpPermission = config.cpPermission
                                        , interactive = config.interactive
                                        , useColor = config.useColor
                                        , stdout = config.stdout
                                        , stdin = config.stdin
                                        }
                                        { projectPath = projectPath, outline = outline }
                                        |> Task.mapError Debug.toString
                                        |> Task.map
                                            (\resolved ->
                                                { projectPath = projectPath
                                                , packageName = pkgOutline.name
                                                , packageVersion = remoteVersion
                                                , currentPackage = resolved
                                                }
                                            )
                                )
            )
        |> Task.andThen
            (\{ projectPath, packageName, packageVersion, currentPackage } ->
                installHiddenProject config projectPath packageName packageVersion
                    |> Task.map
                        (\resolved ->
                            { projectPath = projectPath
                            , currentPackage = currentPackage
                            , remotePackage = resolved
                            }
                        )
            )
        |> Task.map
            (\{ projectPath, currentPackage, remotePackage } ->
                { projectPath = projectPath
                , firstPackage =
                    { outline = currentPackage.outline
                    , rootSources = currentPackage.rootSources
                    , dependencies = currentPackage.dependencies
                    }
                , secondPackage =
                    { outline = remotePackage.outline
                    , rootSources = remotePackage.rootSources
                    , dependencies = remotePackage.dependencies
                    }
                }
            )


installHiddenProject : Config -> Path -> PackageName -> SemanticVersion -> Task String Terminal.PackageInstall.PackageResolution
installHiddenProject config projectPath packageName packageVersion =
     let
        repoPath =
            Terminal.PackageInstall.localRepoPath packageName packageVersion projectPath
    in
    FileSystem.remove config.fsPermission { recursive = True } repoPath
        |> Task.onError (\_ -> Task.succeed repoPath) -- Probably because directory doesn't exist, that's fine
        |> Task.andThen (\_ -> Git.clonePackage config.cpPermission repoPath packageName packageVersion)
        |> Task.mapError (\{ stderr } -> Maybe.withDefault "" <| Bytes.toString stderr)
        |> Task.andThen
            (\_ ->
                Path.append (Path.fromPosixString "gren.json") repoPath
                    |> Terminal.PackageInstall.readOutline config.fsPermission
                    |> Task.mapError Debug.toString
                    |> Task.andThen
                        (\result ->
                            when result is
                                Ok decodedOutline ->
                                    Task.succeed decodedOutline

                                Err err ->
                                    Task.fail (Debug.toString err)
                        )
            )
        |> Task.andThen
            (\publishedOutline ->
                Terminal.PackageInstall.run
                    { fsPermission = config.fsPermission
                    , cpPermission = config.cpPermission
                    , interactive = config.interactive
                    , useColor = config.useColor
                    , stdout = config.stdout
                    , stdin = config.stdin
                    }
                    { projectPath = repoPath, outline = publishedOutline }
                    |> Task.mapError Debug.toString
            )


runGlobal : Config -> PackageName -> SemanticVersion -> SemanticVersion -> Task String Result
runGlobal config packageName lowerVersion upperVersion =
    Terminal.PackageInstall.readProjectOutline config.fsPermission
        |> Task.mapError Debug.toString
        |> Task.andThen
            (\{ projectPath } ->
                Task.map2
                    (\firstPackage secondPackage ->
                        { projectPath = projectPath
                        , firstPackage =
                            { outline = firstPackage.outline
                            , rootSources = firstPackage.rootSources
                            , dependencies = firstPackage.dependencies
                            }
                        , secondPackage =
                            { outline = secondPackage.outline
                            , rootSources = secondPackage.rootSources
                            , dependencies = secondPackage.dependencies
                            }
                        }
                    )
                    (installHiddenProject config projectPath packageName lowerVersion)
                    (installHiddenProject config projectPath packageName upperVersion)
            )
