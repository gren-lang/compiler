module Terminal.PackageDiff exposing
    ( Config
    , Options
    , Error (..)
    , Result
    , runLocal
    , runGlobal
    )


import ChildProcess
import Compiler.Backend
import Compiler.PackageName as PackageName exposing (PackageName)
import Compiler.Paths
import Compiler.Outline as Outline exposing (Outline)
import Compiler.Dependencies
import Git
import Stream
import Stream.Log
import Task exposing (Task)
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import Bytes exposing (Bytes)
import SemanticVersion exposing (SemanticVersion)
import SemanticVersionRange exposing (SemanticVersionRange)
import Json.Encode as Json
import Json.Decode as Decode exposing (Decoder)
import Stream.Extra
import Terminal.PackageInstall


type alias Config =
    { fsPermission : FileSystem.Permission
    , cpPermission : ChildProcess.Permission
    , interactive : Bool
    , useColor : Bool
    , stdout : Stream.Writable Bytes
    , stdin : Stream.Readable Bytes
    }


type alias Options =
    { projectPath : Path
    , outline : Outline
    }


type Error
    = LocalReadProjectOutlineError Terminal.PackageInstall.ReadProjectOutlineError
    | LocalCannotDiffApplication
    | LocalFetchVersionsFailed Git.Error
    | LocalNoPublishedVersions
    | LocalInstallError Terminal.PackageInstall.PackageInstallError
    | LocalHiddenProjectError InstallHiddenProjectError


type alias Result =
    { projectPath : Path
    , firstPackage :
        { outline : Outline
        , rootSources : Dict String String
        , dependencies : Dict String { outline : Outline.PkgOutline, sources : Dict String String }
        }
    , secondPackage :
        { outline : Outline
        , rootSources : Dict String String
        , dependencies : Dict String { outline : Outline.PkgOutline, sources : Dict String String }
        }
    }


runLocal : Config -> Maybe SemanticVersion -> Task Error Result
runLocal config maybeVersion =
    Terminal.PackageInstall.readProjectOutline config.fsPermission
        |> Task.mapError LocalReadProjectOutlineError
        |> Task.andThen
            (\{ projectPath, outline } ->
                when outline is
                    Outline.App _ ->
                        Task.fail LocalCannotDiffApplication

                    Outline.Pkg pkgOutline ->
                        let
                            versionTask =
                                when maybeVersion is
                                    Just v ->
                                        Task.succeed v

                                    Nothing ->
                                        Git.fetchVersions config.cpPermission pkgOutline.name
                                            |> Task.mapError LocalFetchVersionsFailed
                                            |> Task.andThen
                                                (\knownVersions ->
                                                    if Array.isEmpty knownVersions then
                                                        Task.fail LocalNoPublishedVersions

                                                    else
                                                        Array.last knownVersions
                                                            |> Maybe.withDefault
                                                                { major = 1
                                                                , minor = 0
                                                                , patch = 0
                                                                }
                                                            |> Task.succeed
                                                )
                        in
                        versionTask
                            |> Task.andThen
                                (\remoteVersion ->
                                    Terminal.PackageInstall.run
                                        { fsPermission = config.fsPermission
                                        , cpPermission = config.cpPermission
                                        , interactive = config.interactive
                                        , useColor = config.useColor
                                        , stdout = config.stdout
                                        , stdin = config.stdin
                                        }
                                        { projectPath = projectPath, outline = outline }
                                        |> Task.mapError LocalInstallError
                                        |> Task.map
                                            (\resolved ->
                                                { projectPath = projectPath
                                                , packageName = pkgOutline.name
                                                , packageVersion = remoteVersion
                                                , currentPackage = resolved
                                                }
                                            )
                                )
            )
        |> Task.andThen
            (\{ projectPath, packageName, packageVersion, currentPackage } ->
                installHiddenProject config projectPath packageName packageVersion
                    |> Task.mapError LocalHiddenProjectError
                    |> Task.map
                        (\resolved ->
                            { projectPath = projectPath
                            , currentPackage = currentPackage
                            , remotePackage = resolved
                            }
                        )
            )
        |> Task.map
            (\{ projectPath, currentPackage, remotePackage } ->
                { projectPath = projectPath
                , firstPackage =
                    { outline = currentPackage.outline
                    , rootSources = currentPackage.rootSources
                    , dependencies = currentPackage.dependencies
                    }
                , secondPackage =
                    { outline = remotePackage.outline
                    , rootSources = remotePackage.rootSources
                    , dependencies = remotePackage.dependencies
                    }
                }
            )


type InstallHiddenProjectError
    = HiddenProjectFileSystemError FileSystem.Error
    | HiddenProjectGitCloneError ChildProcess.FailedRun
    | HiddenProjectReadOutlineError FileSystem.Error
    | HiddenProjectOutlineDecodeError Decode.Error
    | HiddenProjectInstallError Terminal.PackageInstall.PackageInstallError


installHiddenProject : Config -> Path -> PackageName -> SemanticVersion -> Task InstallHiddenProjectError Terminal.PackageInstall.PackageResolution
installHiddenProject config projectPath packageName packageVersion =
     let
        repoPath =
            Terminal.PackageInstall.localRepoPath packageName packageVersion projectPath
    in
    FileSystem.remove config.fsPermission { recursive = True } repoPath
        |> Task.onError
            (\err ->
                if FileSystem.errorIsNoSuchFileOrDirectory err then
                    Task.succeed repoPath

                else
                    Task.fail <| HiddenProjectFileSystemError err
            )
        |> Task.andThen
            (\_ ->
                Git.clonePackage config.cpPermission repoPath packageName packageVersion
                    |> Task.mapError HiddenProjectGitCloneError
            )
        |> Task.andThen
            (\_ ->
                Path.append (Path.fromPosixString "gren.json") repoPath
                    |> Terminal.PackageInstall.readOutline config.fsPermission
                    |> Task.mapError HiddenProjectReadOutlineError
                    |> Task.andThen
                        (\result ->
                            when result is
                                Ok decodedOutline ->
                                    Task.succeed decodedOutline

                                Err err ->
                                    Task.fail <| HiddenProjectOutlineDecodeError err
                        )
            )
        |> Task.andThen
            (\publishedOutline ->
                Terminal.PackageInstall.run
                    { fsPermission = config.fsPermission
                    , cpPermission = config.cpPermission
                    , interactive = config.interactive
                    , useColor = config.useColor
                    , stdout = config.stdout
                    , stdin = config.stdin
                    }
                    { projectPath = repoPath, outline = publishedOutline }
                    |> Task.mapError HiddenProjectInstallError
            )


type GlobalError
    = GlobalReadProjectOutlineError Terminal.PackageInstall.ReadProjectOutlineError
    | GlobalHiddenProjectError InstallHiddenProjectError


runGlobal : Config -> PackageName -> SemanticVersion -> SemanticVersion -> Task GlobalError Result
runGlobal config packageName lowerVersion upperVersion =
    Terminal.PackageInstall.readProjectOutline config.fsPermission
        |> Task.mapError GlobalReadProjectOutlineError
        |> Task.andThen
            (\{ projectPath } ->
                Task.map2
                    (\firstPackage secondPackage ->
                        { projectPath = projectPath
                        , firstPackage =
                            { outline = firstPackage.outline
                            , rootSources = firstPackage.rootSources
                            , dependencies = firstPackage.dependencies
                            }
                        , secondPackage =
                            { outline = secondPackage.outline
                            , rootSources = secondPackage.rootSources
                            , dependencies = secondPackage.dependencies
                            }
                        }
                    )
                    (installHiddenProject config projectPath packageName lowerVersion)
                    (installHiddenProject config projectPath packageName upperVersion)
                    |> Task.mapError GlobalHiddenProjectError
            )
