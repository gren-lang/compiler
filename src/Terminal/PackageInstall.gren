module Terminal.PackageInstall exposing
    ( PackageInstallError (..)
    , PackageResolution
    , run
    , prettifyError
    --
    , AddPackageError (..)
    , addPackage
    , prettifyAddPackageError
    --
    , ReadProjectOutlineError (..)
    , readProjectOutline
    , prettifyProjectOutlineError
    , readOutline
    , localRepoPath
    )


import CLI.PrettyPrinter as PP
import ChildProcess
import Compiler.PackageName as PackageName exposing (PackageName)
import Compiler.Paths
import Compiler.Outline as Outline exposing (Outline)
import Compiler.Dependencies
import Git
import Stream
import Stream.Log
import Task exposing (Task)
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import Bytes exposing (Bytes)
import SemanticVersion exposing (SemanticVersion)
import SemanticVersionRange exposing (SemanticVersionRange)
import Json.Encode as Json
import Json.Decode as Decode exposing (Decoder)
import Stream.Extra
import Terminal.Help as Help


type alias Config =
    { fsPermission : FileSystem.Permission
    , cpPermission : ChildProcess.Permission
    , interactive : Bool
    , useColor : Bool
    , stdout : Stream.Writable Bytes
    , stdin : Stream.Readable Bytes
    }


type alias Options =
    { projectPath : Path
    , outline : Outline
    }


type alias PackageResolution =
    { projectPath : Path
    , outline : Outline
    , rootSources : Dict String String
    , dependencies : Dict String { outline : Outline.PkgOutline, sources : Dict String String }
    }


type PackageInstallError
    = PackageInstallFailedToFindProjectSourceFiles FileSystem.Error
    | PackageInstallFailedToFindSourceFiles { package : PackageName, error : FileSystem.Error }
    | PackageInstallInvalidOutline { package : PackageName, message : String }
    | PackageInstallFailedToLoadBundle Path
    | PackageInstallInvalidBundle { package : PackageName, path : Path, message : String }
    | PackageInstallConflict { package : PackageName, version1 : SemanticVersionRange, version2 : SemanticVersionRange }
    | PackageInstallGitError { package : PackageName, error : Git.Error }
    | PackageInstallFileSystemError { package : PackageName, error : FileSystem.Error }
    | PackageInstallCreateBundleError { package : PackageName, path : Path, error : Stream.Error }


run : Config -> Options -> Task PackageInstallError PackageResolution
run config { projectPath, outline } =
    let
        rootDeps =
            when outline is
                Outline.App appOutline ->
                    Dict.union
                        appOutline.dependencies.direct
                        appOutline.dependencies.indirect
                        |> Dict.map
                            (\_ v ->
                                when v is
                                    Outline.Version vsn ->
                                        Outline.Version (SemanticVersionRange.fromExact vsn)

                                    Outline.LocalPath p ->
                                        Outline.LocalPath p
                            )

                Outline.Pkg pkgOutline ->
                    pkgOutline.dependencies
    in
    rootDeps
        |> Dict.foldl
            (\key value acc ->
                Array.pushLast
                    { name = PackageName.fromString key |> Maybe.withDefault PackageName.example
                    , constraint = value
                    }
                    acc
            )
            []
        |> Array.map
            (\{ name, constraint } ->
                when constraint is
                    Outline.Version vsn ->
                        loadPackageFromBundle config.fsPermission name (SemanticVersionRange.lowerBound vsn) projectPath

                    Outline.LocalPath path ->
                        loadPackageFromPath config.fsPermission name path
            )
        |> Task.concurrent
        |> Task.map (Array.mapAndKeepJust identity)
        |> Task.andThen
            (\pkgs ->
                let
                    loadedPackages =
                        Array.foldl
                            (\pkg dict ->
                                Dict.set
                                    (PackageName.toString pkg.name)
                                    { outline = pkg.outline
                                    , sources = pkg.sources
                                    }
                                    dict
                            )
                            Dict.empty
                            pkgs
                in
                Outline.findSourceFiles config.fsPermission outline projectPath
                    |> Task.onError
                        (\err ->
                            if FileSystem.errorIsNoSuchFileOrDirectory err then
                                Task.succeed []

                            else
                                Task.fail <| PackageInstallFailedToFindProjectSourceFiles err
                        )
                    |> Task.map
                        (\sourceFiles ->
                            { projectPath = projectPath
                            , outline = outline
                            , projectSources =
                                Array.foldl
                                    (\{ moduleName, source } dict -> Dict.set moduleName source dict)
                                    Dict.empty
                                    sourceFiles
                            , rootPackages =
                                Dict.foldl
                                    (\key value acc ->
                                        when value is
                                            Outline.Version vsn ->
                                                Array.pushLast
                                                    { name = PackageName.fromString key |> Maybe.withDefault PackageName.example
                                                    , version = vsn
                                                    }
                                                    acc

                                            Outline.LocalPath _ ->
                                                when Dict.get key loadedPackages is
                                                    Just { outline = pkgOutline } ->
                                                        Array.pushLast
                                                            { name = PackageName.fromString key |> Maybe.withDefault PackageName.example
                                                            , version = SemanticVersionRange.fromExact pkgOutline.version
                                                            }
                                                            acc

                                                    _ ->
                                                        acc
                                    )
                                    []
                                    rootDeps
                            , loadedPackages = loadedPackages
                            , solvedPackages = Dict.empty
                            }
                        )
            )
        |> Task.andThen (installStep config)


type alias StepOptions =
    { projectPath : Path
    , outline : Outline
    , projectSources : Dict String String
    , rootPackages : Array { name : PackageName, version : SemanticVersionRange }
    , loadedPackages : Dict String { outline : Outline.PkgOutline, sources : Dict String String }
    , solvedPackages : Dict String Compiler.Dependencies.SimplifiedOutline
    }


installStep : Config -> StepOptions -> Task PackageInstallError PackageResolution
installStep config { projectPath, outline, projectSources, rootPackages, loadedPackages, solvedPackages } =
    when Compiler.Dependencies.solve rootPackages solvedPackages is
        Compiler.Dependencies.Complete ->
            Task.succeed
                { projectPath = projectPath
                , outline = outline
                , rootSources = projectSources
                , dependencies = loadedPackages
                }

        Compiler.Dependencies.Missing { name, version } ->
            let
                packageNameString =
                    PackageName.toString name
            in
            -- TODO: Check that the package is defined in the outline
            when Dict.get packageNameString loadedPackages is
                Just loadedPackage ->
                    installStep config
                        { projectPath = projectPath
                        , outline = outline
                        , projectSources = projectSources
                        , rootPackages = rootPackages
                        , loadedPackages = loadedPackages
                        , solvedPackages =
                            Dict.set
                                packageNameString
                                { name = name
                                , version = version
                                , dependencies =
                                    Dict.mapAndKeepJust
                                        (\_ constraint ->
                                            when constraint is
                                                -- TODO: Error
                                                Outline.Version vsn ->
                                                    Just vsn

                                                Outline.LocalPath _ ->
                                                    Nothing
                                        )
                                        loadedPackage.outline.dependencies
                                }
                                solvedPackages
                        }
                
                Nothing ->
                    let
                        lowerBound =
                            SemanticVersionRange.lowerBound version

                        bundlePath =
                            packageBundlePath name lowerBound projectPath

                        repoPath =
                            localRepoPath name lowerBound projectPath
                    in
                    FileSystem.remove config.fsPermission { recursive = True } repoPath
                        |> Task.onError (\err ->
                            if FileSystem.errorIsNoSuchFileOrDirectory err then
                                Task.succeed repoPath

                            else
                                Task.fail <| PackageInstallFileSystemError
                                    { package = name
                                    , error = err
                                    }
                        )
                        |> Task.andThen
                            (\_ ->
                                Git.clonePackage config.cpPermission repoPath name lowerBound
                                    |> Task.mapError
                                        (\err ->
                                            PackageInstallGitError
                                                { package = name
                                                , error = err
                                                }
                                        )
                            )
                        |> Task.andThen (\{} ->
                            (Path.append (Path.fromPosixString "gren.json") repoPath)
                                |> readOutline config.fsPermission
                                |> Task.mapError
                                    (\err ->
                                        PackageInstallFileSystemError
                                            { package = name
                                            , error = err
                                            }
                                    )
                                |> Task.andThen
                                    (\decodeResult ->
                                        when decodeResult is
                                            Ok (Outline.Pkg packageOutline) ->
                                                Outline.findSourceFiles config.fsPermission (Outline.Pkg packageOutline) repoPath
                                                    |> Task.mapError
                                                        (\err ->
                                                            PackageInstallFailedToFindSourceFiles
                                                                { package = name
                                                                , error = err
                                                                }
                                                        )
                                                    |> Task.map
                                                        (\files ->
                                                            let
                                                                sources =
                                                                    Array.foldl
                                                                        (\{ moduleName, source } dict ->
                                                                            Dict.set moduleName source dict
                                                                        )
                                                                        Dict.empty
                                                                        files
                                                            in
                                                            { name = name
                                                            , outline = packageOutline
                                                            , sources = sources
                                                            , data =
                                                                packageBundleEncoder packageOutline sources
                                                                    |> Json.encode 0
                                                            }
                                                        )

                                            Ok (Outline.App _) ->
                                                Task.fail <| PackageInstallInvalidOutline
                                                    { package = name
                                                    , message = "Expected package-type outline."
                                                    }

                                            Err err ->
                                                Task.fail <| PackageInstallInvalidOutline
                                                    { package = name
                                                    , message = Decode.errorToString err
                                                    }
                                    )
                        )
                        |> Task.andThen
                            (\pkg ->
                                let
                                    packagesDir =
                                        Path.append (Path.fromPosixString "gren_packages") projectPath
                                in
                                packagesDir
                                    |> FileSystem.makeDirectory config.fsPermission { recursive = False }
                                    |> Task.onError
                                        (\err ->
                                            if FileSystem.errorIsFileExists err then
                                                Task.succeed packagesDir

                                            else
                                                Task.fail <| PackageInstallFileSystemError
                                                    { package = name
                                                    , error = err
                                                    }
                                        )
                                    |> Task.andThen
                                        (\_ ->
                                            FileSystem.writeFileStream config.fsPermission FileSystem.Replace bundlePath
                                                |> Task.mapError
                                                    (\err ->
                                                        PackageInstallFileSystemError
                                                            { package = name
                                                            , error = err
                                                            }
                                                    )
                                        )
                                    |> Task.andThen
                                        (\stream ->
                                            Stream.fromArray [ pkg.data ]
                                                |> Task.andThen (Stream.awaitAndPipeThrough Stream.textEncoder)
                                                |> Task.andThen (Stream.awaitAndPipeThrough Stream.gzipCompression)
                                                |> Task.andThen (Stream.pipeTo stream)
                                                |> Task.mapError
                                                    (\ err ->
                                                        PackageInstallCreateBundleError
                                                            { package = name
                                                            , path = bundlePath
                                                            , error = err
                                                            }
                                                    )
                                        )
                                    |> Task.map (\_ -> pkg)
                            )
                        |> Task.map
                            (\pkg ->
                                { projectPath = projectPath
                                , outline = outline
                                , projectSources = projectSources
                                , rootPackages = rootPackages
                                , loadedPackages =
                                    Dict.set
                                        (PackageName.toString name)
                                        { outline = pkg.outline, sources = pkg.sources }
                                        loadedPackages
                                , solvedPackages = solvedPackages
                                }
                            )
                        -- TODO: Print progress
                        |> Task.andThen (installStep config)

        Compiler.Dependencies.Conflict conflict ->
            Task.fail <| PackageInstallConflict
                { package = conflict.name
                , version1 = conflict.version1
                , version2 = conflict.version2
                }


prettifyError : PackageInstallError -> PP.Document
prettifyError error =
    when error is
        PackageInstallFailedToFindProjectSourceFiles fsErr ->
            Help.report
                "FAILED TO FIND PROJECT SOURCES"
                Nothing
                (PP.verticalBlock
                    [ PP.words "An error occured while I was searching for this project's source code."
                    , PP.empty
                    , PP.words "The error is:"
                    , PP.empty
                    , PP.words (FileSystem.errorToString fsErr)
                        |> PP.indent
                    ]
                )

        PackageInstallFailedToFindSourceFiles { package, error = fsErr} ->
            Help.report
                ("FAILED TO FIND SOURCES FOR PACKAGE " ++ PackageName.toString package)
                Nothing
                (PP.verticalBlock
                    [ PP.words "An error occured while I was searching for the package's source code."
                    , PP.empty
                    , PP.words "The error is:"
                    , PP.empty
                    , PP.words (FileSystem.errorToString fsErr)
                        |> PP.indent
                    ]
                )
        
        PackageInstallInvalidOutline { package, message } ->
            Help.report
                ("INVALID gren.json IN " ++ PackageName.toString package)
                Nothing
                (PP.verticalBlock
                    [ PP.words "An error occured while I was reading the gren.json file for this package."
                    , PP.empty
                    , PP.words "The error is:"
                    , PP.empty
                    , PP.words message
                        |> PP.indent
                    ]
                )

        PackageInstallFailedToLoadBundle path ->
            Help.report
                "FAILED TO LOAD PACKAGE"
                (Just path)
                (PP.verticalBlock
                    [ PP.words "An error occured while I was loading the bundle for this package."
                    , PP.empty
                    , PP.words "Try to delete it and re-run this command to re-generate the bundle."
                    ]
                )

        PackageInstallInvalidBundle { package, path, message } ->
            Help.report
                ("FAILED TO LOAD PACKAGE " ++ PackageName.toString package)
                (Just path)
                (PP.verticalBlock
                    [ PP.words "An error occured while I was loading the bundle for this package."
                    , PP.empty
                    , PP.words "The error is:"
                    , PP.empty
                    , PP.words message
                        |> PP.indent
                    , PP.empty
                    , PP.words "This is likely due to an error in how the package was published. Consider letting the package author know."
                    ]
                )

        PackageInstallConflict { package, version1, version2 } ->
            Help.report
                "CANNOT FIND COMPATIBLE VERSION"
                Nothing
                (PP.verticalBlock
                    [ PP.words "I cannot find a version of"
                    , PP.text (" " ++ PackageName.toString package ++ " ")
                        |> PP.color PP.Green
                    , PP.words "that is compatible with your existing dependencies."
                    , PP.empty
                    , PP.words "These are the confliction versions:"
                    , PP.empty
                    , PP.verticalBlock
                        [ PP.text (SemanticVersionRange.toString version1)
                        , PP.text (SemanticVersionRange.toString version2)
                        ]
                        |> PP.indent
                    ]
                )

        PackageInstallGitError { package, error = gitErr } ->
            Git.report
                "PROBLEM INSTALLING PACKAGE"
                ("I was trying to install " ++ PackageName.toString package)
                gitErr

        PackageInstallFileSystemError { package, error = fsErr } ->
            Help.report
                ("FAILED TO LOAD " ++ PackageName.toString package)
                Nothing
                (PP.verticalBlock
                    [ PP.words "An error occured while installing this package."
                    , PP.empty
                    , PP.words "The error is:"
                    , PP.empty
                    , PP.words (FileSystem.errorToString fsErr)
                        |> PP.indent
                    ]
                )

        PackageInstallCreateBundleError { package, path, error = streamErr } ->
            Help.report
                ("FAILED TO CREATE BUNDLE FOR " ++ PackageName.toString package)
                (Just path)
                (PP.verticalBlock
                    [ PP.words "An error occured while I was creating the bundle for this package."
                    , PP.empty
                    , PP.words "The error is:"
                    , PP.empty
                    , PP.words (Stream.errorToString streamErr)
                        |> PP.indent
                    ]
                )


-- ADD PACKAGE


type AddPackageError
    = AddPackageAlreadyInstalled
    | AddPackagePromptError Stream.Error
    | AddPackageUserCancelled
    | AddPackageWriteOutlineError FileSystem.Error
    | AddPackageGitError Git.Error
    | AddPackageInstallError PackageInstallError


-- TODO: Refactor
addPackage : Config -> Options -> PackageName -> Task AddPackageError {}
addPackage config { projectPath, outline } requestedPackage =
    let
        packageNameStr =
            PackageName.toString requestedPackage

        grenJsonPath =
            Path.append (Path.fromPosixString "gren.json") projectPath
    in
    when outline is
        Outline.App appOutline ->
            when
                { direct = Dict.member packageNameStr appOutline.dependencies.direct
                , transitive = Dict.get packageNameStr appOutline.dependencies.indirect
                }
            is
                { direct = False, transitive = Nothing } ->
                    Stream.Log.line config.stdout ("Installing " ++ packageNameStr)
                        |> Task.andThen
                            (\_ ->
                                Git.fetchLatestVersion config.cpPermission requestedPackage
                            )
                        |> Task.mapError AddPackageGitError
                        |> Task.andThen
                            (\packageVersion ->
                                run
                                    config
                                    { projectPath = projectPath
                                    , outline =
                                        { appOutline
                                            | dependencies =
                                                { appOutline.dependencies | direct = Dict.set packageNameStr (Outline.Version packageVersion) appOutline.dependencies.direct
                                                }
                                        }
                                        |> Outline.App
                                    }
                                    |> Task.mapError AddPackageInstallError
                                    |> Task.map (\res -> { resolved = res, packageVersion = packageVersion })
                            )
                        |> Task.andThen
                            (\{ packageVersion, resolved } ->
                                let
                                    originalPackages =
                                        (Dict.keys appOutline.dependencies.direct)
                                            ++ (Dict.keys appOutline.dependencies.indirect)

                                    newPackages =
                                        resolved.dependencies
                                            |> Dict.keepIf (\k _ -> not <| Array.member k originalPackages)
                                            |> Dict.map (\_ value -> value.outline.version)

                                    finalOutline =
                                        Outline.App
                                            { appOutline
                                                | dependencies =
                                                    { appOutline.dependencies
                                                        | direct = Dict.set packageNameStr (Outline.Version packageVersion) appOutline.dependencies.direct
                                                        , indirect =
                                                            Dict.union
                                                                appOutline.dependencies.indirect
                                                                (newPackages |> Dict.remove packageNameStr |> Dict.map (\_ v -> Outline.Version v))
                                                    }
                                            }

                                    plan =
                                        PP.verticalBlock
                                            [ PP.words "The plan is to add the following dependencies:"
                                            , PP.empty
                                            , PP.empty
                                            , Dict.foldl (\k v acc -> Array.pushLast (k ++ " " ++ SemanticVersion.toString v) acc) [] newPackages
                                                |> Array.map PP.text
                                                |> PP.verticalBlock
                                                |> PP.indent
                                            , PP.empty
                                            , PP.words "Do you want me to update the gren.json file accordingly?"
                                            ]
                                in
                                Help.confirm
                                    { stdout = config.stdout
                                    , stdin = config.stdin
                                    , useColor = config.useColor
                                    , interactive = config.interactive
                                    , question = plan
                                    , defaultValue = True
                                    }
                                    |> Task.mapError AddPackagePromptError
                                    |> Task.andThen
                                        (\confirmed ->
                                            if confirmed then
                                                finalOutline
                                                    |> Outline.toJson
                                                    |> Json.encode 4
                                                    |> Task.succeed

                                            else
                                                Task.fail AddPackageUserCancelled
                                        )
                                    |> Task.andThen
                                        (\newOutline ->
                                            FileSystem.writeFile config.fsPermission (Bytes.fromString newOutline) grenJsonPath
                                                |> Task.mapError AddPackageWriteOutlineError
                                                |> Task.map (\_ -> {})
                                        )
                            )

                { direct = True } ->
                    Task.fail AddPackageAlreadyInstalled

                { transitive = Just packageVersion } ->
                    Help.confirm
                        { stdout = config.stdout
                        , stdin = config.stdin
                        , useColor = config.useColor
                        , interactive = config.interactive
                        , question = PP.words "Move to direct?"
                        , defaultValue = True
                        }
                        |> Task.mapError AddPackagePromptError
                        |> Task.andThen
                            (\answer ->
                                if answer then
                                    Task.succeed {}

                                else
                                    Task.fail AddPackageUserCancelled
                            )
                        |> Task.andThen
                            (\{} ->
                                { appOutline
                                    | dependencies =
                                        { direct = Dict.set packageNameStr packageVersion appOutline.dependencies.direct
                                        , indirect = Dict.remove packageNameStr appOutline.dependencies.indirect
                                        }
                                }
                                |> Outline.App
                                |> Outline.toJson
                                |> Json.encode 4
                                |> Task.succeed
                            )
                        |> Task.andThen
                            (\newOutline ->
                                FileSystem.writeFile config.fsPermission (Bytes.fromString newOutline) grenJsonPath
                                    |> Task.mapError AddPackageWriteOutlineError
                                    |> Task.map (\_ -> {})
                            )

        Outline.Pkg pkgOutline ->
            if Dict.member packageNameStr pkgOutline.dependencies then
                Task.fail AddPackageAlreadyInstalled

            else
                -- TODO: Implement
                Stream.Log.line config.stdout ("Installing " ++ packageNameStr)


prettifyAddPackageError : AddPackageError -> PP.Document
prettifyAddPackageError error =
    when error is
        AddPackageAlreadyInstalled ->
            PP.empty

        AddPackagePromptError streamErr ->
            Help.report
                "FAILED TO COMMUNICATE WITH USER"
                Nothing
                (PP.verticalBlock
                    [ PP.words "I wanted to ask you a question, but something seems to be wrong with the stdin stream."
                    , PP.empty
                    , PP.words "The error is:"
                    , PP.empty
                    , PP.words (Stream.errorToString streamErr)
                        |> PP.indent
                    , PP.empty
                    , PP.words "This is most definetly a bug. Please report it."
                    ]
                )

        AddPackageUserCancelled ->
            PP.empty

        AddPackageWriteOutlineError fsErr ->
            Help.report
                "FAILED TO UPDATE OUTLINE"
                Nothing
                (PP.verticalBlock
                    [ PP.words "An error occured while I was updating the gren.json file."
                    , PP.empty
                    , PP.words "The error is:"
                    , PP.empty
                    , PP.words (FileSystem.errorToString fsErr)
                        |> PP.indent
                    ]
                )

        AddPackageGitError gitErr ->
            Git.report
                "FAILED TO ADD PACKAGE"
                "I was trying to add a new package to the project"
                gitErr

        AddPackageInstallError installErr ->
            prettifyError installErr


packageBundlePath : PackageName -> SemanticVersion -> Path -> Path
packageBundlePath name version projectPath =
    let
        normalizedName =
            (PackageName.toString name ++ "__" ++ SemanticVersion.toString version)
                |> String.replace "-" "_"
                |> String.replace "." "_"
                |> String.replace "/" "_"
                |> String.append ".pkg.gz"
    in
    Path.join
        [ projectPath
        , Path.fromPosixString "gren_packages"
        , Path.fromPosixString normalizedName
        ]


localRepoPath : PackageName -> SemanticVersion -> Path -> Path
localRepoPath name version projectPath =
    let
        normalizedName =
            (PackageName.toString name ++ "__" ++ SemanticVersion.toString version)
                |> String.replace "-" "_"
                |> String.replace "." "_"
                |> String.replace "/" "_"
    in
    Path.join
        [ projectPath
        , Path.fromPosixString ".gren/git"
        , Path.fromPosixString normalizedName
        ]


type ReadProjectOutlineError
    = ReadProjectOutlineNoProject FileSystem.Error
    | ReadProjectOutlineInvalidGrenJson Decode.Error


readProjectOutline : FileSystem.Permission -> Task ReadProjectOutlineError { projectPath : Path, outline : Outline }
readProjectOutline fsPermission =
    Compiler.Paths.projectRoot fsPermission
        |> Task.mapError ReadProjectOutlineNoProject
        |> Task.andThen
            (\projectPath ->
                readOutline fsPermission (Path.append (Path.fromPosixString "gren.json") projectPath)
                    |> Task.mapError ReadProjectOutlineNoProject
                    |> Task.andThen
                        (\decodeResult ->
                            when decodeResult is
                                Ok outline ->
                                    Task.succeed
                                        { projectPath = projectPath
                                        , outline = outline
                                        }

                                Err err ->
                                    Task.fail (ReadProjectOutlineInvalidGrenJson err)
                        )
            )

prettifyProjectOutlineError : ReadProjectOutlineError -> PP.Document
prettifyProjectOutlineError error =
    when error is
        ReadProjectOutlineNoProject _ ->
            Help.report
                "COULDN'T FIND PROJECT"
                (Just (Path.fromPosixString "gren.json"))
                (PP.verticalBlock
                    [ PP.words "I couldn't find a Gren project."
                    , PP.empty
                    , PP.words "You can create new projects using"
                    , PP.empty
                    , PP.text "gren init"
                        |> PP.indent
                        |> PP.color PP.Green
                    ]
                )

        ReadProjectOutlineInvalidGrenJson jsonErr ->
            Help.report
                "FAILED TO READ OUTLINE"
                (Just (Path.fromPosixString "gren.json"))
                (PP.verticalBlock
                    [ PP.words "Something seems to be wrong with the gren.json file."
                    , PP.empty
                    , PP.words "The error I'm having is:"
                    , PP.empty
                    , PP.text (Decode.errorToString jsonErr)
                        |> PP.indent
                    ]
                )


readOutline : FileSystem.Permission -> Path -> Task FileSystem.Error (Result Decode.Error Outline)
readOutline fsPerm path =
    FileSystem.readFile fsPerm path
        |> Task.map (Bytes.toString >> Maybe.withDefault "")
        |> Task.map (Decode.decodeString Outline.jsonDecoder)


packageBundleEncoder : Outline.PkgOutline -> Dict String String -> Json.Value
packageBundleEncoder outline sources =
    Json.object
        [ { key = "outline", value = Outline.toJson (Outline.Pkg outline) }
        , { key = "sources", value = Json.dict identity Json.string sources }
        ]


packageBundleDecoder : Decoder { outline : Outline.PkgOutline, sources : Dict String String }
packageBundleDecoder =
    Decode.map2 (\outline sources -> { outline = outline, sources = sources })
        (Decode.field "outline" Outline.pkgJsonDecoder)
        (Decode.field "sources" (Decode.dict Decode.string))


type alias LoadedPackage =
    { name : PackageName
    , outline : Outline.PkgOutline
    , sources : Dict String String
    }


-- TODO: extract to module
loadPackageFromPath : FileSystem.Permission -> PackageName -> Path -> Task PackageInstallError (Maybe LoadedPackage)
loadPackageFromPath fsPermission name path =
    let
        outlinePath =
            Path.append (Path.fromPosixString "gren.json") path
    in
    FileSystem.readFile fsPermission outlinePath
        |> Task.mapError
            (\err ->
                PackageInstallInvalidOutline
                    { package = name
                    , message = FileSystem.errorToString err
                    }
            )
        |> Task.andThen
            (\outlineBytes ->
                when Bytes.toString outlineBytes is
                    Just str ->
                        Task.succeed str

                    Nothing ->
                        Task.fail <| PackageInstallInvalidOutline
                            { package = name
                            , message = "gren.json is not a valid utf-8 string"
                            }
            )
        |> Task.andThen
            (\outlineStr ->
                when Decode.decodeString Outline.pkgJsonDecoder outlineStr is
                    Ok outline ->
                        Outline.findSourceFiles fsPermission (Outline.Pkg outline) path
                            |> Task.mapError
                                (\err ->
                                    PackageInstallFailedToFindSourceFiles
                                        { package = name
                                        , error = err
                                        }
                                )
                            |> Task.andThen
                                (\sourceFiles ->
                                    if name /= outline.name then
                                        Task.fail <| PackageInstallInvalidOutline
                                            { package = name
                                            , message = "Name in gren.json was expected to be " ++ PackageName.toString name
                                            }

                                    else
                                        Task.succeed
                                            (Just
                                                { name = name
                                                , outline = outline
                                                , sources =
                                                    Array.foldl
                                                        (\{ moduleName, source } acc ->
                                                            Dict.set moduleName source acc
                                                        )
                                                        Dict.empty
                                                        sourceFiles
                                                }
                                            )
                                )

                    Err jsonErr ->
                        Task.fail <| PackageInstallInvalidOutline
                            { package = name
                            , message = Decode.errorToString jsonErr
                            }
            )

loadPackageFromBundle : FileSystem.Permission -> PackageName -> SemanticVersion -> Path -> Task PackageInstallError (Maybe LoadedPackage)
loadPackageFromBundle fsPermission name vsn projectPath =
    let
        bundlePath =
            packageBundlePath name vsn projectPath
    in
    bundlePath
        |> FileSystem.readFileStream fsPermission FileSystem.Beginning
        |> Task.mapError (\_ -> PackageInstallFailedToLoadBundle bundlePath)
        |> Task.andThen
            (\stream ->
                stream
                    |> Stream.awaitAndPipeThrough Stream.gzipDecompression
                    |> Task.andThen (Stream.awaitAndPipeThrough Stream.textDecoder)
                    |> Task.andThen Stream.Extra.consumeString
                    |> Task.mapError
                        (\err ->
                            PackageInstallInvalidBundle
                                { package = name
                                , path = bundlePath
                                , message = "Failed to read bundle from disk. Error: " ++ Stream.errorToString err
                                }
                        )
                    |> Task.andThen
                        (\data ->
                            when Decode.decodeString packageBundleDecoder data is
                                Ok bundle ->
                                    if name /= bundle.outline.name then
                                        Task.fail <| PackageInstallInvalidBundle
                                            { package = name
                                            , path = bundlePath
                                            , message = "Package name mismatch. Expected " ++ PackageName.toString name 
                                            }

                                    else if vsn /= bundle.outline.version then
                                        Task.fail <| PackageInstallInvalidBundle
                                            { package = name
                                            , path = bundlePath
                                            , message = "Package version mismatch. Expected " ++ SemanticVersion.toString vsn
                                            }

                                    else
                                        Task.succeed
                                            (Just
                                                { name = name
                                                , outline = bundle.outline
                                                , sources = bundle.sources
                                                }
                                            )

                                Err jsonErr ->
                                    Task.fail <| PackageInstallInvalidBundle
                                        { package = name
                                        , path = bundlePath
                                        , message = Decode.errorToString jsonErr
                                        }
                        )
            )

