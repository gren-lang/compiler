module Terminal.PackageInstall exposing
    ( PackageInstallError (..)
    , PackageResolution
    , run
    , prettifyError
    --
    , cleanPackageDirectory
    --
    , AddPackageError (..)
    , addPackage
    , prettifyAddPackageError
    --
    , ReadProjectOutlineError (..)
    , readProjectOutline
    , prettifyProjectOutlineError
    , readOutline
    , localRepoPath
    )


import CLI.PrettyPrinter as PP
import ChildProcess
import Meta
import Compiler.PackageName as PackageName exposing (PackageName)
import Compiler.Paths
import Compiler.Outline as Outline exposing (Outline)
import Compiler.Dependencies
import Compiler.Backend
import Compiler.Platform as Platform exposing (Platform)
import Git
import Stream
import Stream.Log
import Task exposing (Task)
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import Bytes exposing (Bytes)
import SemanticVersion exposing (SemanticVersion)
import SemanticVersionRange exposing (SemanticVersionRange)
import Json.Encode as Json
import Json.Decode as Decode exposing (Decoder)
import Stream.Extra
import Terminal.Help as Help


type alias Config =
    { fsPermission : FileSystem.Permission
    , cpPermission : ChildProcess.Permission
    , cacheRoot : Compiler.Paths.CacheRoot
    , interactive : Bool
    , useColor : Bool
    , stdout : Stream.Writable Bytes
    , stdin : Stream.Readable Bytes
    , strictAppResolution : Bool
    }


type alias Options =
    { projectPath : Path
    , outline : Outline
    }


type alias PackageResolution =
    { projectPath : Path
    , outline : Outline
    , rootSources : Dict String Compiler.Backend.SourceFile
    , dependencies : Dict String { outline : Outline.PkgOutline, sources : Dict String String }
    , didDownload : Bool
    }


type PackageInstallError
    = PackageInstallFailedToFindProjectSourceFiles FileSystem.Error
    | PackageInstallFailedToFindSourceFiles { package : PackageName, error : FileSystem.Error }
    | PackageInstallInvalidOutline { package : PackageName, message : String }
    | PackageInstallFailedToLoadBundle { package : PackageName, path : Path, message : String }
    | PackageInstallInvalidBundle { package : PackageName, path : Path, message : String }
    | PackageInstallConflict { package : PackageName, version1 : SemanticVersionRange, version2 : SemanticVersionRange }
    | PackageInstallGitError { package : PackageName, error : Git.Error }
    | PackageInstallFileSystemError { package : PackageName, error : FileSystem.Error }
    | PackageInstallCreateBundleError { package : PackageName, path : Path, error : Stream.Error }
    | PackageInstallMissingIndirectDependency { package : PackageName, version : SemanticVersionRange }
    | PackageInstallBadLocalDependency { package : PackageName, dependency : PackageName }
    | PackageInstallRootIncompatibleCompiler SemanticVersionRange
    | PackageInstallIncompatibleCompiler { package : PackageName, rootCompiler : SemanticVersionRange, packageCompiler : SemanticVersionRange }
    | PackageInstallIncompatiblePlatform { package : PackageName, rootPlatform : Platform, packagePlatform : Platform }


run : Config -> Options -> Task PackageInstallError PackageResolution
run config { projectPath, outline } =
    let
        rootDeps =
            when outline is
                Outline.App appOutline ->
                    Dict.union
                        appOutline.dependencies.direct
                        appOutline.dependencies.indirect
                        |> Dict.map
                            (\_ v ->
                                when v is
                                    Outline.Version vsn ->
                                        Outline.Version (SemanticVersionRange.fromExact vsn)

                                    Outline.LocalPath p ->
                                        Outline.LocalPath p
                            )

                Outline.Pkg pkgOutline ->
                    pkgOutline.dependencies
    in
    rootDeps
        |> Dict.foldl
            (\key value acc ->
                Array.pushLast
                    { name = PackageName.fromString key |> Maybe.withDefault PackageName.example
                    , constraint = value
                    }
                    acc
            )
            []
        |> Array.map
            (\{ name, constraint } ->
                when constraint is
                    Outline.Version vsn ->
                        loadPackageFromBundle config.fsPermission name (SemanticVersionRange.lowerBound vsn) projectPath
                            |> Task.map Just
                            |> Task.onError
                                (\err ->
                                    {- Due to a bug in gren-lang/core, we aren't able to
                                    detech why installing the package failed. Will simply
                                    assume that loading the package failed due to it being
                                    missing until a new version of gren-lang/core is released.
                                    TODO:
                                    when err is
                                        PackageInstallFailedToLoadBundle { message } ->
                                            -- Ignore packages that doesn't exist, they
                                            -- will be created in `installStep`
                                            if String.contains "ENOENT" message then
                                                Task.succeed Nothing

                                            else
                                                Task.fail err

                                        _ ->
                                            Task.fail err
                                    -}
                                    Task.succeed Nothing
                                )

                    Outline.LocalPath path ->
                        loadPackageFromPath config.fsPermission name path
                            |> Task.map Just
            )
        |> Task.sequence -- TODO: use concurrent
        |> Task.map (Array.mapAndKeepJust identity)
        |> Task.andThen
            (\pkgs ->
                let
                    pkgsDict =
                        Array.foldl
                            (\pkg dict ->
                                Dict.set
                                    (PackageName.toString pkg.name)
                                    pkg
                                    dict
                            )
                            Dict.empty
                            pkgs

                    loadedPackages =
                        Dict.map
                            (\_name pkg ->
                                { outline = pkg.outline
                                , sources = pkg.sources
                                }
                            )
                            pkgsDict
                in
                Outline.findSourceFiles config.fsPermission outline projectPath
                    |> Task.onError
                        (\err ->
                            if FileSystem.errorIsNoSuchFileOrDirectory err then
                                Task.succeed []

                            else
                                Task.fail <| PackageInstallFailedToFindProjectSourceFiles err
                        )
                    |> Task.map
                        (\sourceFiles ->
                            { projectPath = projectPath
                            , outline = outline
                            , projectSources =
                                Array.foldl
                                    (\{ path, moduleName, source } dict -> Dict.set moduleName { path = path, data = source } dict)
                                    Dict.empty
                                    sourceFiles
                            , startedDownload = False
                            , strictResolution =
                                when outline is
                                    Outline.App _ ->
                                        config.strictAppResolution

                                    Outline.Pkg _ ->
                                        False
                            , rootPackages =
                                Dict.foldl
                                    (\key value acc ->
                                        when value is
                                            Outline.Version vsn ->
                                                Array.pushLast
                                                    { name = PackageName.fromString key |> Maybe.withDefault PackageName.example
                                                    , version = vsn
                                                    }
                                                    acc

                                            Outline.LocalPath _ ->
                                                when Dict.get key loadedPackages is
                                                    Just { outline = pkgOutline } ->
                                                        Array.pushLast
                                                            { name = PackageName.fromString key |> Maybe.withDefault PackageName.example
                                                            , version = SemanticVersionRange.fromExact pkgOutline.version
                                                            }
                                                            acc

                                                    _ ->
                                                        acc
                                    )
                                    []
                                    rootDeps
                            , rootPackageConstraints =
                                Dict.map
                                    (\key value ->
                                        when value is
                                            Outline.Version _ ->
                                                value

                                            Outline.LocalPath _ ->
                                                when Dict.get key pkgsDict is
                                                    Just { path } ->
                                                        Outline.LocalPath path

                                                    Nothing ->
                                                        value
                                    )
                                    rootDeps
                            , loadedPackages = loadedPackages
                            , solvedPackages = Dict.empty
                            }
                        )
            )
        |> Task.andThen (installStep config)
        |> Task.andThen
            (\resolution ->
                if resolution.didDownload then
                    Stream.Log.line config.stdout ""
                        |> Task.map (\_ -> resolution)

                else
                    Task.succeed resolution
            )
        |> Task.onError
            (\err ->
                Stream.Log.line config.stdout ""
                    |> Task.andThen (\_ -> Task.fail err)
            )


type alias StepOptions =
    { projectPath : Path
    , outline : Outline
    , projectSources : Dict String Compiler.Backend.SourceFile
    , strictResolution : Bool
    , startedDownload : Bool
    , rootPackages : Array { name : PackageName, version : SemanticVersionRange }
    , rootPackageConstraints : Dict String (Outline.VersionConstraint SemanticVersionRange)
    , loadedPackages : Dict String { outline : Outline.PkgOutline, sources : Dict String String }
    , solvedPackages : Dict String Compiler.Dependencies.SimplifiedOutline
    }


-- TODO: Refactor into smaller functions
installStep : Config -> StepOptions -> Task PackageInstallError PackageResolution
installStep config opts =
    when Compiler.Dependencies.solve opts.rootPackages opts.solvedPackages is
        Compiler.Dependencies.Complete ->
            let
                { rootPlatform, rootCompiler } =
                    when opts.outline is
                        Outline.App appOutline ->
                            { rootPlatform = appOutline.platform
                            , rootCompiler = SemanticVersionRange.fromExact appOutline.grenVersion
                            }

                        Outline.Pkg pkgOutline ->
                            { rootPlatform = pkgOutline.platform
                            , rootCompiler = pkgOutline.grenVersion
                            }

                incompatiblePackages =
                    opts.loadedPackages
                        |> Dict.mapAndKeepJust
                            (\_ package ->
                                when SemanticVersionRange.intersect package.outline.grenVersion rootCompiler is
                                    Nothing ->
                                        Just <| PackageInstallIncompatibleCompiler
                                            { package = package.outline.name
                                            , rootCompiler = rootCompiler
                                            , packageCompiler = package.outline.grenVersion
                                            }

                                    Just _ ->
                                        if Platform.isCompatible rootPlatform package.outline.platform then
                                            Nothing

                                        else
                                            Just <| PackageInstallIncompatiblePlatform
                                                { package = package.outline.name
                                                , rootPlatform = rootPlatform
                                                , packagePlatform = package.outline.platform
                                                }
                            )
            in
            when SemanticVersionRange.intersect (SemanticVersionRange.fromExact Meta.version) rootCompiler is
                Nothing ->
                    Task.fail <| PackageInstallRootIncompatibleCompiler rootCompiler

                Just _ ->
                    when Dict.first incompatiblePackages is
                        Just { value = incompatibility } ->
                            Task.fail incompatibility

                        Nothing ->
                            Task.succeed
                                { projectPath = opts.projectPath
                                , outline = opts.outline
                                , rootSources = opts.projectSources
                                , dependencies = opts.loadedPackages
                                , didDownload = opts.startedDownload
                                }

        Compiler.Dependencies.Missing { name, version } ->
            let
                packageNameString =
                    PackageName.toString name
            in
            if opts.strictResolution && not (Array.any (\dep -> dep.name == name) opts.rootPackages) then
                Task.fail <| PackageInstallMissingIndirectDependency
                    { package = name
                    , version = version
                    }

            else when Dict.get packageNameString opts.loadedPackages is
                Just loadedPackage ->
                    let
                        localDependenciesCheck =
                            loadedPackage.outline.dependencies
                                |> Dict.foldl
                                    (\package constraint acc ->
                                        when constraint is
                                            Outline.Version _ ->
                                                acc

                                            Outline.LocalPath path ->
                                                when  Dict.get package opts.rootPackageConstraints is
                                                    Nothing ->
                                                        Task.fail <| PackageInstallBadLocalDependency
                                                            { package = loadedPackage.outline.name
                                                            , dependency =
                                                                PackageName.fromString package
                                                                    |> Maybe.withDefault PackageName.example
                                                            }

                                                    Just rootConstraint ->
                                                        acc
                                                            |> Task.andThen
                                                                (\_ ->
                                                                    FileSystem.realPath config.fsPermission path
                                                                        |> Task.mapError
                                                                            (\err ->
                                                                                PackageInstallFileSystemError
                                                                                    { package = loadedPackage.outline.name
                                                                                    , error = err
                                                                                    }
                                                                            )
                                                                )
                                                            |> Task.andThen
                                                                (\realPath ->
                                                                    if rootConstraint == Outline.LocalPath realPath then
                                                                        Task.succeed {}

                                                                    else
                                                                        Task.fail <| PackageInstallBadLocalDependency
                                                                            { package = loadedPackage.outline.name
                                                                            , dependency =
                                                                                PackageName.fromString package
                                                                                    |> Maybe.withDefault PackageName.example
                                                                            }
                                                                )
                                    )
                                    (Task.succeed {})
                    in
                    localDependenciesCheck
                        |> Task.andThen
                            (\_ ->
                                installStep config
                                    { opts
                                        | solvedPackages =
                                            Dict.set
                                                packageNameString
                                                { name = name
                                                , version = version
                                                , dependencies =
                                                    Dict.mapAndKeepJust
                                                        (\_ constraint ->
                                                            when constraint is
                                                                Outline.Version vsn ->
                                                                    Just vsn

                                                                Outline.LocalPath _ ->
                                                                    Nothing
                                                        )
                                                        loadedPackage.outline.dependencies
                                                }
                                                opts.solvedPackages
                                    }
                            )
                
                Nothing ->
                    let
                        lowerBound =
                            SemanticVersionRange.lowerBound version
                    in
                    loadPackageFromBundle config.fsPermission name lowerBound opts.projectPath
                        |> Task.map
                            (\pkg ->
                                { opts
                                    | loadedPackages =
                                        Dict.set
                                            (PackageName.toString name)
                                            { outline = pkg.outline, sources = pkg.sources }
                                            opts.loadedPackages
                                }
                            )
                        |> Task.onError
                            (\_loadError ->
                                {- TODO: Assuming bundle doesn't exist, creating...
                                -}
                                let
                                    bundlePath =
                                        packageBundlePath name lowerBound opts.projectPath

                                    packageReportTask =
                                        Stream.Log.string config.stdout ("    " ++ PackageName.toString name ++ " ")

                                    reportTask =
                                        if opts.startedDownload then
                                            packageReportTask

                                        else
                                            Stream.Log.line config.stdout "Starting downloads...\n"
                                                |> Task.andThen (\_ -> packageReportTask)
                                in
                                reportTask
                                    |> Task.andThen
                                        (\_ ->
                                            Git.clonePackageCached
                                                { childProcessPermission = config.cpPermission
                                                , fileSystemPermission = config.fsPermission
                                                , cacheRoot = config.cacheRoot
                                                , packageName = name
                                                , version = lowerBound
                                                }
                                                |> Task.mapError
                                                    (\err ->
                                                        PackageInstallGitError
                                                            { package = name
                                                            , error = err
                                                            }
                                                    )
                                        )
                                    |> Task.andThen (\repoPath ->
                                        (Path.append (Path.fromPosixString "gren.json") repoPath)
                                            |> readOutline config.fsPermission
                                            |> Task.mapError
                                                (\err ->
                                                    PackageInstallFileSystemError
                                                        { package = name
                                                        , error = err
                                                        }
                                                )
                                            |> Task.andThen
                                                (\decodeResult ->
                                                    when decodeResult is
                                                        Ok (Outline.Pkg packageOutline) ->
                                                            Outline.findSourceFiles config.fsPermission (Outline.Pkg packageOutline) repoPath
                                                                |> Task.mapError
                                                                    (\err ->
                                                                        PackageInstallFailedToFindSourceFiles
                                                                            { package = name
                                                                            , error = err
                                                                            }
                                                                    )
                                                                |> Task.map
                                                                    (\files ->
                                                                        let
                                                                            sources =
                                                                                Array.foldl
                                                                                    (\{ moduleName, source } dict ->
                                                                                        Dict.set moduleName source dict
                                                                                    )
                                                                                    Dict.empty
                                                                                    files
                                                                        in
                                                                        { name = name
                                                                        , outline = packageOutline
                                                                        , sources = sources
                                                                        , data =
                                                                            packageBundleEncoder packageOutline sources
                                                                                |> Json.encode 0
                                                                        }
                                                                    )

                                                        Ok (Outline.App _) ->
                                                            Task.fail <| PackageInstallInvalidOutline
                                                                { package = name
                                                                , message = "Expected package-type outline."
                                                                }

                                                        Err err ->
                                                            Task.fail <| PackageInstallInvalidOutline
                                                                { package = name
                                                                , message = Decode.errorToString err
                                                                }
                                                )
                                    )
                                    |> Task.andThen
                                        (\pkg ->
                                            let
                                                packagesDir =
                                                    Path.append (Path.fromPosixString "gren_packages") opts.projectPath
                                            in
                                            packagesDir
                                                |> FileSystem.makeDirectory config.fsPermission { recursive = False }
                                                |> Task.onError
                                                    (\err ->
                                                        if FileSystem.errorIsFileExists err then
                                                            Task.succeed packagesDir

                                                        else
                                                            Task.fail <| PackageInstallFileSystemError
                                                                { package = name
                                                                , error = err
                                                                }
                                                    )
                                                |> Task.andThen
                                                    (\_ ->
                                                        FileSystem.writeFileStream config.fsPermission bundlePath
                                                            |> Task.mapError
                                                                (\err ->
                                                                    PackageInstallFileSystemError
                                                                        { package = name
                                                                        , error = err
                                                                        }
                                                                )
                                                    )
                                                |> Task.andThen
                                                    (\stream ->
                                                        Stream.fromArray [ pkg.data ]
                                                            |> Task.andThen (Stream.awaitAndPipeThrough Stream.textEncoder)
                                                            |> Task.andThen (Stream.awaitAndPipeThrough Stream.gzipCompression)
                                                            |> Task.andThen (Stream.pipeTo stream)
                                                            |> Task.mapError
                                                                (\ err ->
                                                                    PackageInstallCreateBundleError
                                                                        { package = name
                                                                        , path = bundlePath
                                                                        , error = err
                                                                        }
                                                                )
                                                    )
                                                |> Task.andThen
                                                    (\_ ->
                                                        PP.text "âœ”"
                                                            |> PP.color PP.Green
                                                            |> PP.toString
                                                            |> Stream.Log.line config.stdout 
                                                    )
                                                |> Task.map (\_ -> pkg)
                                        )
                                    |> Task.map
                                        (\pkg ->
                                            { opts
                                                | startedDownload = True
                                                , loadedPackages =
                                                    Dict.set
                                                        (PackageName.toString name)
                                                        { outline = pkg.outline, sources = pkg.sources }
                                                        opts.loadedPackages
                                            }
                                        )
                            )
                        |> Task.andThen (installStep config)
                    

        Compiler.Dependencies.Conflict conflict ->
            Task.fail <| PackageInstallConflict
                { package = conflict.name
                , version1 = conflict.version1
                , version2 = conflict.version2
                }


prettifyError : PackageInstallError -> PP.Document
prettifyError error =
    when error is
        PackageInstallFailedToFindProjectSourceFiles fsErr ->
            Help.report
                "FAILED TO FIND PROJECT SOURCES"
                Nothing
                (PP.verticalBlock
                    [ PP.words "An error occured while I was searching for this project's source code."
                    , PP.empty
                    , PP.words "The error is:"
                    , PP.empty
                    , PP.words (FileSystem.errorToString fsErr)
                        |> PP.indent
                    ]
                )

        PackageInstallFailedToFindSourceFiles { package, error = fsErr} ->
            Help.report
                ("FAILED TO FIND SOURCES FOR PACKAGE " ++ PackageName.toString package)
                Nothing
                (PP.verticalBlock
                    [ PP.words "An error occured while I was searching for the package's source code."
                    , PP.empty
                    , PP.words "The error is:"
                    , PP.empty
                    , PP.words (FileSystem.errorToString fsErr)
                        |> PP.indent
                    ]
                )
        
        PackageInstallInvalidOutline { package, message } ->
            Help.report
                ("INVALID gren.json IN " ++ PackageName.toString package)
                Nothing
                (PP.verticalBlock
                    [ PP.words "An error occured while I was reading the gren.json file for this package."
                    , PP.empty
                    , PP.words "The error is:"
                    , PP.empty
                    , PP.words message
                        |> PP.indent
                    ]
                )

        PackageInstallFailedToLoadBundle { package, path, message } ->
            Help.report
                "FAILED TO LOAD PACKAGE BUNDLE"
                (Just path)
                (PP.verticalBlock
                    [ PP.block
                        [ PP.words "An error occured while I was loading the bundle for "
                        , PP.text (" " ++ PackageName.toString package)
                            |> PP.color PP.Green
                        , PP.text "."
                        ]
                    , PP.empty
                    , PP.words "The error is:"
                    , PP.empty
                    , PP.words message
                        |> PP.indent
                    , PP.empty
                    , PP.words "Try to delete it and re-run this command to re-generate the bundle."
                    ]
                )

        PackageInstallInvalidBundle { package, path, message } ->
            Help.report
                "FAILED TO LOAD PACKAGE BUNDLE"
                (Just path)
                (PP.verticalBlock
                    [ PP.block
                        [ PP.words "An error occured while I was loading the bundle for"
                        , PP.text (" " ++ PackageName.toString package)
                            |> PP.color PP.Green
                        , PP.text "."
                        ]
                    , PP.empty
                    , PP.words "The error is:"
                    , PP.empty
                    , PP.words message
                        |> PP.indent
                    , PP.empty
                    , PP.words "This is likely due to an error in how the package was published. Consider letting the package author know."
                    ]
                )

        PackageInstallConflict { package, version1, version2 } ->
            Help.report
                "CANNOT FIND COMPATIBLE VERSION"
                Nothing
                (PP.verticalBlock
                    [ PP.block
                        [ PP.words "I cannot find a version of"
                        , PP.text (" " ++ PackageName.toString package ++ " ")
                            |> PP.color PP.Green
                        , PP.words "that is compatible with your existing dependencies."
                        ]
                    , PP.empty
                    , PP.words "These are the confliction versions:"
                    , PP.empty
                    , PP.verticalBlock
                        [ PP.text (SemanticVersionRange.toString version1)
                        , PP.text (SemanticVersionRange.toString version2)
                        ]
                        |> PP.indent
                    ]
                )

        PackageInstallGitError { package, error = gitErr } ->
            Git.report
                "PROBLEM INSTALLING PACKAGE"
                ("I was trying to install " ++ PackageName.toString package)
                gitErr

        PackageInstallFileSystemError { package, error = fsErr } ->
            Help.report
                "FAILED TO LOAD PACKAGE"
                Nothing
                (PP.verticalBlock
                    [ PP.block
                        [ PP.words "An error occured while installing"
                        , PP.text (" " ++ PackageName.toString package)
                            |> PP.color PP.Green
                        , PP.text "."
                        ]
                    , PP.empty
                    , PP.words "The error is:"
                    , PP.empty
                    , PP.words (FileSystem.errorToString fsErr)
                        |> PP.indent
                    ]
                )

        PackageInstallCreateBundleError { package, path, error = streamErr } ->
            Help.report
                "FAILED TO CREATE PACKAGE BUNDLE"
                (Just path)
                (PP.verticalBlock
                    [ PP.block
                        [ PP.words "An error occured while I was creating the bundle for"
                        , PP.text (" " ++ PackageName.toString package)
                            |> PP.color PP.Green
                        , PP.text "."
                        ]
                    , PP.empty
                    , PP.words "The error is:"
                    , PP.empty
                    , PP.words (Stream.errorToString streamErr)
                        |> PP.indent
                    ]
                )

        PackageInstallMissingIndirectDependency { package, version } ->
            Help.report
                "MISSING INDIRECT DEPENDENCIES"
                (Just (Path.fromPosixString "gren.json"))
                (PP.verticalBlock
                    [ PP.words "I expected to find the following package as an indirect dependency in your gren.json file:"
                    , PP.empty
                    , PP.text (PackageName.toString package ++ " " ++ SemanticVersion.toString (SemanticVersionRange.lowerBound version))
                        |> PP.indent
                        |> PP.color PP.Green
                    , PP.empty
                    , PP.words "Try adding them to your gren.json file in the \"indirect\" dependencies object then try this operaton again."
                    ]
                )

        PackageInstallBadLocalDependency { package, dependency } ->
            Help.report
                "INDIRECT LOCAL DEPENDENCY"
                Nothing
                (PP.verticalBlock
                    [ PP.block
                        [ PP.text (PackageName.toString package ++ " ")
                            |> PP.color PP.Green
                        , PP.words "has defined a local dependency on"
                        , PP.text (" " ++ PackageName.toString dependency ++ " ")
                            |> PP.color PP.Green
                        , PP.words "with an incompatible source."
                        ]
                    , PP.empty
                    , PP.words
                        """
                        Dependencies are normally not allowed to define local dependencies themselves unless
                        they happen to point to the same local dependency as the root project.
                        """
                    ]
                )

        PackageInstallRootIncompatibleCompiler rootCompiler ->
            Help.report
                "INCOMPATIBLE COMPILER"
                Nothing
                (PP.verticalBlock
                    [ PP.words
                        ( "The gren.json file says this project is compatible with a Gren compiler in the "
                            ++ SemanticVersionRange.toString rootCompiler
                            ++ " version range."
                        )
                    , PP.empty
                    , PP.words
                        ( "However, you're currently using a Gren compiler with version "
                            ++ SemanticVersion.toString Meta.version
                            ++ ", which is not compatible."
                        )
                    ]
                )

        PackageInstallIncompatibleCompiler { package, rootCompiler, packageCompiler } ->
            Help.report
                "INCOMPATIBLE PACKAGE"
                Nothing
                (PP.verticalBlock
                    [ PP.words
                        ( PackageName.toString package
                            ++ " requires a Gren compiler in the "
                            ++ SemanticVersionRange.toString packageCompiler
                            ++ " version range."
                        )
                    , PP.empty
                    , PP.words
                        ( "However, the current project requires a compiler in the "
                            ++ SemanticVersionRange.toString rootCompiler
                            ++ ", which is not compatible."
                        )
                    ]
                )

        PackageInstallIncompatiblePlatform { package, rootPlatform, packagePlatform } ->
            Help.report
                "INCOMPATIBLE PACKAGE"
                Nothing
                (PP.verticalBlock
                    [ PP.words
                        ( PackageName.toString package
                            ++ " targets the "
                            ++ Platform.toString packagePlatform
                            ++ " platform."
                        )
                    , PP.empty
                    , PP.words
                        ( "However, the current project targets the "
                            ++ Platform.toString rootPlatform
                            ++ ", which is not compatible."
                        )
                    ]
                )

-- CLEAN


cleanPackageDirectory : FileSystem.Permission -> PackageResolution -> Task FileSystem.Error {}
cleanPackageDirectory fsPermission resolution =
    let
        bundlesToKeep =
            Dict.map
                (\_ package ->
                    { name = package.outline.name, version = package.outline.version }
                )
                resolution.dependencies
                |> Dict.values
                |> Array.map
                    (\{ name, version } ->
                        packageBundlePath name version resolution.projectPath
                    )

        packagesFolder =
            Path.append (Path.fromPosixString "gren_packages") resolution.projectPath
    in
    FileSystem.listDirectory fsPermission packagesFolder
        |> Task.andThen
            (\files ->
                Array.map .path files
                    |> Array.map (Path.prepend packagesFolder)
                    |> Array.keepIf
                        (\bundlePath ->
                            not (Array.member bundlePath bundlesToKeep)
                        )
                    |> Array.map (FileSystem.remove fsPermission { recursive = False, ignoreErrors = False })
                    |> Task.sequence
            )
        |> Task.map (\_ -> {})


-- ADD PACKAGE


type AddPackageError
    = AddPackageAlreadyInstalled
    | AddPackagePromptError Stream.Error
    | AddPackageUserCancelled
    | AddPackageWriteOutlineError FileSystem.Error
    | AddPackageGitError Git.Error
    | AddPackageInstallError PackageInstallError


addPackage : Config -> Options -> PackageName -> Task AddPackageError {}
addPackage config { projectPath, outline } requestedPackage =
    let
        packageNameStr =
            PackageName.toString requestedPackage

        grenJsonPath =
            Path.append (Path.fromPosixString "gren.json") projectPath
    in
    when outline is
        Outline.App appOutline ->
            when
                { direct = Dict.member packageNameStr appOutline.dependencies.direct
                , transitive = Dict.get packageNameStr appOutline.dependencies.indirect
                }
            is
                { direct = False, transitive = Nothing } ->
                    Git.fetchLatestVersion config.cpPermission requestedPackage
                        |> Task.mapError AddPackageGitError
                        |> Task.andThen
                            (\packageVersion ->
                                run
                                    config
                                    { projectPath = projectPath
                                    , outline =
                                        { appOutline
                                            | dependencies =
                                                { appOutline.dependencies | direct = Dict.set packageNameStr (Outline.Version packageVersion) appOutline.dependencies.direct
                                                }
                                        }
                                        |> Outline.App
                                    }
                                    |> Task.mapError AddPackageInstallError
                                    |> Task.map (\res -> { resolved = res, packageVersion = packageVersion })
                            )
                        |> Task.andThen
                            (\{ packageVersion, resolved } ->
                                let
                                    originalPackages =
                                        (Dict.keys appOutline.dependencies.direct)
                                            ++ (Dict.keys appOutline.dependencies.indirect)

                                    newPackages =
                                        resolved.dependencies
                                            |> Dict.keepIf (\k _ -> not <| Array.member k originalPackages)
                                            |> Dict.map (\_ value -> value.outline.version)

                                    finalOutline =
                                        Outline.App
                                            { appOutline
                                                | dependencies =
                                                    { appOutline.dependencies
                                                        | direct = Dict.set packageNameStr (Outline.Version packageVersion) appOutline.dependencies.direct
                                                        , indirect =
                                                            Dict.union
                                                                appOutline.dependencies.indirect
                                                                (newPackages |> Dict.remove packageNameStr |> Dict.map (\_ v -> Outline.Version v))
                                                    }
                                            }
                                in
                                promptUpdateOutline config grenJsonPath newPackages finalOutline
                                    |> Task.onError
                                        (\err ->
                                            when err is
                                                AddPackageUserCancelled ->
                                                    { resolved |
                                                        dependencies =
                                                            Dict.keepIf
                                                                (\depNameStr _ ->
                                                                    Array.member depNameStr originalPackages
                                                                )
                                                                resolved.dependencies
                                                    }
                                                        |> cleanPackageDirectory config.fsPermission
                                                        |> Task.mapError (\_ -> err)
                                                        |> Task.andThen (\_ -> Task.fail err)

                                                _ ->
                                                    Task.fail err
                                        )
                            )

                { direct = True } ->
                    Task.fail AddPackageAlreadyInstalled

                { transitive = Just packageVersion } ->
                    Help.confirm
                        { stdout = config.stdout
                        , stdin = config.stdin
                        , useColor = config.useColor
                        , interactive = config.interactive
                        , question = PP.words "Move to direct?"
                        , defaultValue = True
                        }
                        |> Task.mapError AddPackagePromptError
                        |> Task.andThen
                            (\answer ->
                                if answer then
                                    Task.succeed {}

                                else
                                    Task.fail AddPackageUserCancelled
                            )
                        |> Task.andThen
                            (\{} ->
                                { appOutline
                                    | dependencies =
                                        { direct = Dict.set packageNameStr packageVersion appOutline.dependencies.direct
                                        , indirect = Dict.remove packageNameStr appOutline.dependencies.indirect
                                        }
                                }
                                |> Outline.App
                                |> Outline.toJson
                                |> Json.encode 4
                                |> Task.succeed
                            )
                        |> Task.andThen
                            (\newOutline ->
                                FileSystem.writeFile config.fsPermission (Bytes.fromString newOutline) grenJsonPath
                                    |> Task.mapError AddPackageWriteOutlineError
                                    |> Task.map (\_ -> {})
                            )

        Outline.Pkg pkgOutline ->
            if Dict.member packageNameStr pkgOutline.dependencies then
                Task.fail AddPackageAlreadyInstalled

            else
                Git.fetchLatestVersion config.cpPermission requestedPackage
                    |> Task.mapError AddPackageGitError
                    |> Task.andThen
                        (\packageVersion ->
                            let
                                finalOutline =
                                    Outline.Pkg
                                        { pkgOutline
                                            | dependencies =
                                                Dict.set
                                                    packageNameStr
                                                    (Outline.Version <| SemanticVersionRange.compatibleWith packageVersion)
                                                    pkgOutline.dependencies
                                        }
                            in
                            run
                                config
                                { projectPath = projectPath
                                , outline = finalOutline
                                }
                                |> Task.mapError AddPackageInstallError
                                |> Task.andThen
                                    (\resolved ->
                                        let
                                            newPackages =
                                                Dict.singleton packageNameStr packageVersion
                                        in
                                        promptUpdateOutline config grenJsonPath newPackages finalOutline
                                            |> Task.onError
                                                (\err ->
                                                    when err is
                                                        AddPackageUserCancelled ->
                                                            { resolved |
                                                                dependencies =
                                                                    Dict.remove packageNameStr resolved.dependencies
                                                            }
                                                                |> cleanPackageDirectory config.fsPermission
                                                                |> Task.mapError (\_ -> err)
                                                                |> Task.andThen (\_ -> Task.fail err)

                                                        _ ->
                                                            Task.fail err
                                                )
                                    )
                        )


promptUpdateOutline : Config -> Path -> Dict String SemanticVersion -> Outline -> Task AddPackageError {}
promptUpdateOutline config grenJsonPath newPackages finalOutline =
    let
        plan =
            PP.verticalBlock
                [ PP.words "The plan is to add the following dependencies:"
                , PP.empty
                , Dict.foldl (\k v acc -> Array.pushLast (k ++ " " ++ SemanticVersion.toString v) acc) [] newPackages
                    |> Array.map PP.text
                    |> PP.verticalBlock
                    |> PP.indent
                , PP.empty
                , PP.words "Do you want me to update the gren.json file accordingly?"
                ]
    in
    Help.confirm
        { stdout = config.stdout
        , stdin = config.stdin
        , useColor = config.useColor
        , interactive = config.interactive
        , question = plan
        , defaultValue = True
        }
        |> Task.mapError AddPackagePromptError
        |> Task.andThen
            (\confirmed ->
                if confirmed then
                    finalOutline
                        |> Outline.toJson
                        |> Json.encode 4
                        |> Task.succeed

                else
                    Task.fail AddPackageUserCancelled
            )
        |> Task.andThen
            (\newOutline ->
                FileSystem.writeFile config.fsPermission (Bytes.fromString newOutline) grenJsonPath
                    |> Task.mapError AddPackageWriteOutlineError
                    |> Task.map (\_ -> {})
            )

prettifyAddPackageError : AddPackageError -> PP.Document
prettifyAddPackageError error =
    when error is
        AddPackageAlreadyInstalled ->
            PP.empty

        AddPackagePromptError streamErr ->
            Help.report
                "FAILED TO COMMUNICATE WITH USER"
                Nothing
                (PP.verticalBlock
                    [ PP.words "I wanted to ask you a question, but something seems to be wrong with the stdin stream."
                    , PP.empty
                    , PP.words "The error is:"
                    , PP.empty
                    , PP.words (Stream.errorToString streamErr)
                        |> PP.indent
                    , PP.empty
                    , PP.words "This is most definetly a bug. Please report it."
                    ]
                )

        AddPackageUserCancelled ->
            PP.empty

        AddPackageWriteOutlineError fsErr ->
            Help.report
                "FAILED TO UPDATE OUTLINE"
                Nothing
                (PP.verticalBlock
                    [ PP.words "An error occured while I was updating the gren.json file."
                    , PP.empty
                    , PP.words "The error is:"
                    , PP.empty
                    , PP.words (FileSystem.errorToString fsErr)
                        |> PP.indent
                    ]
                )

        AddPackageGitError gitErr ->
            Git.report
                "FAILED TO ADD PACKAGE"
                "I was trying to add a new package to the project"
                gitErr

        AddPackageInstallError installErr ->
            prettifyError installErr


packageBundlePath : PackageName -> SemanticVersion -> Path -> Path
packageBundlePath name version projectPath =
    let
        normalizedName =
            (PackageName.toString name ++ "__" ++ SemanticVersion.toString version)
                |> String.replace "-" "_"
                |> String.replace "." "_"
                |> String.replace "/" "_"
                |> String.append ".pkg.gz"
    in
    Path.join
        [ projectPath
        , Path.fromPosixString "gren_packages"
        , Path.fromPosixString normalizedName
        ]


localRepoPath : PackageName -> SemanticVersion -> Path -> Path
localRepoPath name version projectPath =
    let
        normalizedName =
            (PackageName.toString name ++ "__" ++ SemanticVersion.toString version)
                |> String.replace "-" "_"
                |> String.replace "." "_"
                |> String.replace "/" "_"
    in
    Path.join
        [ projectPath
        , Path.fromPosixString ".gren/git"
        , Path.fromPosixString normalizedName
        ]


type ReadProjectOutlineError
    = ReadProjectOutlineNoProject FileSystem.Error
    | ReadProjectOutlineInvalidGrenJson Decode.Error


readProjectOutline : FileSystem.Permission -> Task ReadProjectOutlineError { projectPath : Path, outline : Outline }
readProjectOutline fsPermission =
    Compiler.Paths.projectRoot fsPermission
        |> Task.mapError ReadProjectOutlineNoProject
        |> Task.andThen
            (\projectPath ->
                readOutline fsPermission (Path.append (Path.fromPosixString "gren.json") projectPath)
                    |> Task.mapError ReadProjectOutlineNoProject
                    |> Task.andThen
                        (\decodeResult ->
                            when decodeResult is
                                Ok outline ->
                                    Task.succeed
                                        { projectPath = projectPath
                                        , outline = outline
                                        }

                                Err err ->
                                    Task.fail (ReadProjectOutlineInvalidGrenJson err)
                        )
            )

prettifyProjectOutlineError : ReadProjectOutlineError -> PP.Document
prettifyProjectOutlineError error =
    when error is
        ReadProjectOutlineNoProject _ ->
            Help.report
                "COULDN'T FIND PROJECT"
                (Just (Path.fromPosixString "gren.json"))
                (PP.verticalBlock
                    [ PP.words "I couldn't find a Gren project."
                    , PP.empty
                    , PP.words "You can create new projects using"
                    , PP.empty
                    , PP.text "gren init"
                        |> PP.indent
                        |> PP.color PP.Green
                    ]
                )

        ReadProjectOutlineInvalidGrenJson jsonErr ->
            Help.report
                "FAILED TO READ OUTLINE"
                (Just (Path.fromPosixString "gren.json"))
                (PP.verticalBlock
                    [ PP.words "Something seems to be wrong with the gren.json file."
                    , PP.empty
                    , PP.words "The error I'm having is:"
                    , PP.empty
                    , PP.text (Decode.errorToString jsonErr)
                        |> PP.indent
                    ]
                )


readOutline : FileSystem.Permission -> Path -> Task FileSystem.Error (Result Decode.Error Outline)
readOutline fsPerm path =
    FileSystem.readFile fsPerm path
        |> Task.map (Bytes.toString >> Maybe.withDefault "")
        |> Task.map (Decode.decodeString Outline.jsonDecoder)


packageBundleEncoder : Outline.PkgOutline -> Dict String String -> Json.Value
packageBundleEncoder outline sources =
    Json.object
        [ { key = "outline", value = Outline.toJson (Outline.Pkg outline) }
        , { key = "sources", value = Json.dict identity Json.string sources }
        ]


packageBundleDecoder : Decoder { outline : Outline.PkgOutline, sources : Dict String String }
packageBundleDecoder =
    Decode.map2 (\outline sources -> { outline = outline, sources = sources })
        (Decode.field "outline" Outline.pkgJsonDecoder)
        (Decode.field "sources" (Decode.dict Decode.string))


type alias LoadedPackage =
    { name : PackageName
    , path : Path
    , outline : Outline.PkgOutline
    , sources : Dict String String
    }


-- TODO: extract to module
loadPackageFromPath : FileSystem.Permission -> PackageName -> Path -> Task PackageInstallError LoadedPackage
loadPackageFromPath fsPermission name path =
    FileSystem.realPath fsPermission path
        |> Task.mapError
            (\err ->
                PackageInstallInvalidOutline
                    { package = name
                    , message = FileSystem.errorToString err
                    }
            )
        |> Task.andThen
            (\realPath ->
                let
                    outlinePath =
                        Path.append (Path.fromPosixString "gren.json") realPath
                in
                FileSystem.readFile fsPermission outlinePath
                    |> Task.mapError
                        (\err ->
                            PackageInstallInvalidOutline
                                { package = name
                                , message = FileSystem.errorToString err
                                }
                        )
                    |> Task.andThen
                        (\outlineBytes ->
                            when Bytes.toString outlineBytes is
                                Just str ->
                                    Task.succeed str

                                Nothing ->
                                    Task.fail <| PackageInstallInvalidOutline
                                        { package = name
                                        , message = "gren.json is not a valid utf-8 string"
                                        }
                        )
                    |> Task.andThen
                        (\outlineStr ->
                            when Decode.decodeString Outline.pkgJsonDecoder outlineStr is
                                Ok outline ->
                                    Outline.findSourceFiles fsPermission (Outline.Pkg outline) realPath
                                        |> Task.mapError
                                            (\err ->
                                                PackageInstallFailedToFindSourceFiles
                                                    { package = name
                                                    , error = err
                                                    }
                                            )
                                        |> Task.andThen
                                            (\sourceFiles ->
                                                if name /= outline.name then
                                                    Task.fail <| PackageInstallInvalidOutline
                                                        { package = name
                                                        , message = "Name in gren.json was expected to be " ++ PackageName.toString name
                                                        }

                                                else
                                                    Task.succeed
                                                        { name = name
                                                        , path = realPath
                                                        , outline = outline
                                                        , sources =
                                                            Array.foldl
                                                                (\{ moduleName, source } acc ->
                                                                    Dict.set moduleName source acc
                                                                )
                                                                Dict.empty
                                                                sourceFiles
                                                        }
                                            )

                                Err jsonErr ->
                                    Task.fail <| PackageInstallInvalidOutline
                                        { package = name
                                        , message = Decode.errorToString jsonErr
                                        }
                        )
            )



loadPackageFromBundle : FileSystem.Permission -> PackageName -> SemanticVersion -> Path -> Task PackageInstallError LoadedPackage
loadPackageFromBundle fsPermission name vsn projectPath =
    let
        bundlePath =
            packageBundlePath name vsn projectPath
    in
    bundlePath
        |> FileSystem.readFileStream fsPermission
        |> Task.mapError
            (\fsErr ->
                PackageInstallFailedToLoadBundle
                    { package = name
                    , path = bundlePath
                    , message = FileSystem.errorToString fsErr
                    }
            )
        |> Task.andThen
            (\stream ->
                stream
                    |> Stream.awaitAndPipeThrough Stream.gzipDecompression
                    |> Task.andThen (Stream.awaitAndPipeThrough Stream.textDecoder)
                    |> Task.andThen Stream.Extra.consumeString
                    |> Task.mapError
                        (\err ->
                            PackageInstallFailedToLoadBundle
                                { package = name
                                , path = bundlePath
                                , message = Stream.errorToString err
                                }
                        )
                    |> Task.andThen
                        (\data ->
                            when Decode.decodeString packageBundleDecoder data is
                                Ok bundle ->
                                    if name /= bundle.outline.name then
                                        Task.fail <| PackageInstallInvalidBundle
                                            { package = name
                                            , path = bundlePath
                                            , message = "Package name mismatch. Expected " ++ PackageName.toString name 
                                            }

                                    else if vsn /= bundle.outline.version then
                                        Task.fail <| PackageInstallInvalidBundle
                                            { package = name
                                            , path = bundlePath
                                            , message = "Package version mismatch. Expected " ++ SemanticVersion.toString vsn
                                            }

                                    else
                                        Task.succeed
                                            { name = name
                                            , path = bundlePath
                                            , outline = bundle.outline
                                            , sources = bundle.sources
                                            }

                                Err jsonErr ->
                                    Task.fail <| PackageInstallInvalidBundle
                                        { package = name
                                        , path = bundlePath
                                        , message = Decode.errorToString jsonErr
                                        }
                        )
            )

