module Terminal.Run exposing
    ( Error
    , make
    , run
    )

{-| Support the `gren run ModuleName` command.
-}

import Compiler.Backend as Backend
import Bytes exposing (Bytes)
import ChildProcess
import Compiler.Backend
import Compiler.Outline as Outline exposing (Outline)
import Compiler.Platform as Platform
import FileSystem
import FileSystem.Path as Path exposing (Path)
import Compiler.ModuleName as ModuleName exposing (ModuleName)
import Node
import Process
import Stream
import Task exposing (Task)
import Terminal.PackageInstall as PackageInstall


type Error
    = TempPathError FileSystem.Error
    | PackageInstallError PackageInstall.PackageInstallError
    | NotAnApplication


type alias MakeConfig msg =
    { fsPermission : FileSystem.Permission
    , cpPermission : ChildProcess.Permission
    , useColor : Bool
    , compilerPath : Path
    , pathToString : Path -> String
    , moduleName : ModuleName
    , onBackendInitialized : { backendStreams : ChildProcess.StreamIO, encodedCommand : Bytes } -> msg
    , onCompiled : Path -> Int -> msg
    }


type alias RunConfig msg =
    { cpPermission : ChildProcess.Permission
    , fsPermission : FileSystem.Permission
    , path : String
    , onInit : { processId : Process.Id, streams : ChildProcess.StreamIO } -> msg
    , onExit : Int -> msg
    }


make : MakeConfig msg -> Task Error (Cmd msg)
make config =
    let
        installPackages nullStream projectOutline =
            PackageInstall.run
                { fsPermission = config.fsPermission
                , cpPermission = config.cpPermission
                , useColor = config.useColor
                , interactive = False
                , stdout = nullStream |> Stream.writable
                , stdin = nullStream |> Stream.readable
                }
                projectOutline
                    |> Task.mapError PackageInstallError

        backendCommand outputType outputPath packageResolution =
            let
                path =
                    config.pathToString outputPath
            in
            Compiler.Backend.encodeCommand
                { interactiveSession = False
                , pathToString = config.pathToString
                }
                ( Compiler.Backend.Make
                    { optimize = False
                    , sourcemaps = False
                    , output = Just (outputType path)
                    , report = Nothing
                    , projectPath = packageResolution.projectPath
                    , entryPoints = [ config.moduleName ]
                    , outline = packageResolution.outline
                    , rootSources = packageResolution.rootSources
                    , dependencies = packageResolution.dependencies
                    }
                )


        compile outputPath encodedCommand_ =
            Compiler.Backend.run
                config.cpPermission
                { useColor = config.useColor
                , compilerPath = config.compilerPath
                , pathToString = config.pathToString
                , connection = 
                    ChildProcess.External
                        (\cpOpts ->
                            config.onBackendInitialized
                                { backendStreams = cpOpts.streams
                                , encodedCommand = encodedCommand_
                                }
                        )
                , onComplete = config.onCompiled outputPath
                }
    in
    Task.await getNullStream <| \nullStream ->
    Task.await (getProjectOutline config.fsPermission) <| \projectOutline ->
    Task.await (getOutputPath config.fsPermission projectOutline.outline) <| \{ outputType, outputPath } ->
    Task.await (installPackages nullStream projectOutline) <| \packageResolution ->
        backendCommand outputType outputPath packageResolution
            |> compile outputPath
            |> Task.succeed


run : RunConfig msg -> Task Error (Cmd msg)
run config =
    Task.await Node.getPlatform <| \systemPlatform ->
    Task.await (getProjectOutline config.fsPermission) <| \projectOutline ->
        let
            projectPlatform =
                when projectOutline.outline is
                    Outline.Pkg outline_ ->
                        outline_.platform
                    Outline.App outline_ ->
                        outline_.platform
            
            runWith command =
                ChildProcess.defaultSpawnOptions (ChildProcess.External config.onInit) config.onExit
                    |> ChildProcess.spawn config.cpPermission command [ config.path ]
                    |> Task.succeed
        in
        when projectPlatform is
            Platform.Node ->
                runWith "node"

            Platform.Common ->
                Task.fail NotAnApplication

            Platform.Browser ->
                when systemPlatform is
                    Node.Win32 ->
                        runWith "start"

                    _ ->
                        runWith "open"


-- HELPERS


getNullStream : Task x (Stream.Transformation Bytes Bytes)
getNullStream =
    Stream.nullTransformation (Bytes.fromString "")


getProjectOutline : FileSystem.Permission -> Task Error { projectPath : Path, outline : Outline }
getProjectOutline fsPermission =
    PackageInstall.readProjectOutline fsPermission
        |> Task.mapError PackageInstallError


getOutputPath : FileSystem.Permission -> Outline -> Task Error { outputType : (String -> Backend.MakeOutput), outputPath : Path }
getOutputPath fsPermission outline =
    let
        platform =
            when outline is
                Outline.Pkg outline_ ->
                    outline_.platform
                Outline.App outline_ ->
                    outline_.platform

        getPath outputType fileName =
            FileSystem.makeTempDirectory fsPermission "gren-run"
                |> Task.map (Path.append (Path.fromPosixString fileName))
                |> Task.mapError TempPathError
                |> Task.map
                    (\path ->
                        { outputType = outputType
                        , outputPath = path
                        }
                    )
    in
    when platform is
        Platform.Node ->
            getPath Backend.Exe "app"
        Platform.Browser ->
            getPath Backend.Html "app.html"
        Platform.Common ->
            Task.fail NotAnApplication
