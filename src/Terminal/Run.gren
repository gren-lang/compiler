module Terminal.Run exposing
    ( Error
    , make
    , run
    )

{-| Support the `gren run ModuleName` command.
-}

import Bytes exposing (Bytes)
import ChildProcess
import Compiler.Backend
import Compiler.Outline as Outline exposing (Outline)
import Compiler.Platform as Platform
import FileSystem
import FileSystem.Path as Path exposing (Path)
import Compiler.ModuleName as ModuleName exposing (ModuleName)
import Node
import Process
import Stream
import Task exposing (Task)
import Terminal.PackageInstall as PackageInstall


type Error
    = TempPathError FileSystem.Error
    | PackageInstallError PackageInstall.PackageInstallError
    | NotAnApplication


type alias MakeConfig msg =
    { fsPermission : FileSystem.Permission
    , cpPermission : ChildProcess.Permission
    , useColor : Bool
    , compilerPath : Path
    , pathToString : Path -> String
    , moduleName : ModuleName
    , onBackendInitialized : { backendStreams : ChildProcess.StreamIO, encodedCommand : Bytes } -> msg
    , onCompiled : Path -> Int -> msg
    }


type alias RunConfig msg =
    { cpPermission : ChildProcess.Permission
    , path : String
    , onInit : { processId : Process.Id, streams : ChildProcess.StreamIO } -> msg
    , onExit : Int -> msg
    }


make : MakeConfig msg -> Task Error (Cmd msg)
make config =
    let
        installPackages nullStream projectOutline =
            PackageInstall.run
                { fsPermission = config.fsPermission
                , cpPermission = config.cpPermission
                , useColor = config.useColor
                , interactive = False
                , stdout = nullStream |> Stream.writable
                , stdin = nullStream |> Stream.readable
                }
                projectOutline
                    |> Task.mapError PackageInstallError

        backendCommand outputPath packageResolution =
            let
                path =
                    config.pathToString outputPath
            in
            Compiler.Backend.encodeCommand
                { interactiveSession = False
                , pathToString = config.pathToString
                }
                ( Compiler.Backend.Make
                    { optimize = False
                    , sourcemaps = False
                    , output = Just (Compiler.Backend.Exe path)
                    , report = Nothing
                    , projectPath = packageResolution.projectPath
                    , entryPoints = [ config.moduleName ]
                    , outline = packageResolution.outline
                    , rootSources = packageResolution.rootSources
                    , dependencies = packageResolution.dependencies
                    }
                )


        compile outputPath encodedCommand_ =
            Compiler.Backend.run
                config.cpPermission
                { useColor = config.useColor
                , compilerPath = config.compilerPath
                , pathToString = config.pathToString
                , connection = 
                    ChildProcess.External
                        (\cpOpts ->
                            config.onBackendInitialized
                                { backendStreams = cpOpts.streams
                                , encodedCommand = encodedCommand_
                                }
                        )
                , onComplete = config.onCompiled outputPath
                }
    in
    Task.await getNullStream <| \nullStream ->
    Task.await (getProjectOutline config.fsPermission) <| \projectOutline ->
    Task.await (getOutputPath config.fsPermission projectOutline.outline) <| \outputPath ->
    Task.await (installPackages nullStream projectOutline) <| \packageResolution ->
        backendCommand outputPath packageResolution
            |> compile outputPath
            |> Task.succeed


run : RunConfig msg -> Cmd msg
run config =
    ChildProcess.spawn config.cpPermission "node" [ config.path ] <|
        ChildProcess.defaultSpawnOptions (ChildProcess.External config.onInit) config.onExit


-- HELPERS


getNullStream : Task x (Stream.Transformation Bytes Bytes)
getNullStream =
    Stream.customTransformation
        (\_ _ -> Stream.UpdateState (Bytes.fromString ""))
        (Bytes.fromString "")


getProjectOutline : FileSystem.Permission -> Task Error { projectPath : Path, outline : Outline }
getProjectOutline fsPermission =
    PackageInstall.readProjectOutline fsPermission
        |> Task.mapError PackageInstallError


getOutputPath : FileSystem.Permission -> Outline -> Task Error Path
getOutputPath fsPermission outline =
    let
        platform =
            when outline is
                Outline.Pkg outline_ ->
                    outline_.platform
                Outline.App outline_ ->
                    outline_.platform

        getPath fileName =
            FileSystem.makeTempDirectory fsPermission "gren-run"
                |> Task.map (Path.append (Path.fromPosixString fileName))
                |> Task.mapError TempPathError
    in
    when platform is
        Platform.Node ->
            getPath "app"
        Platform.Browser ->
            -- TODO: handle browser apps
            -- getPath "app.html"
            Task.fail NotAnApplication
        Platform.Common ->
            Task.fail NotAnApplication
