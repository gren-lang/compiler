module Terminal.Package exposing
    ( PackageInstallError (..)
    , PackageResolution
    , install
    , readOutline
    , readProjectOutline
    )

import ChildProcess
import Compiler.PackageName as PackageName exposing (PackageName)
import Compiler.Paths
import Compiler.Outline as Outline exposing (Outline)
import Compiler.Dependencies
import Git
import Stream
import Stream.Log
import Task exposing (Task)
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import Bytes exposing (Bytes)
import SemanticVersion exposing (SemanticVersion)
import SemanticVersionRange exposing (SemanticVersionRange)
import Json.Encode as Json
import Json.Decode as Decode exposing (Decoder)
import Stream.Extra


type alias Config =
    { fsPermission : FileSystem.Permission
    , cpPermission : ChildProcess.Permission
    , stdout : Stream.Writable Bytes
    }


type alias Options =
    { projectPath : Path
    , outline : Outline
    }


type alias PackageResolution =
    { projectPath : Path
    , outline : Outline
    , rootSources : Dict String String
    , dependencies : Dict String { outline : Outline.PkgOutline, sources : Dict String String }
    }


type PackageInstallError
    = PackageInstallNoProject FileSystem.Error
    | PackageInstallNoGrenJson FileSystem.Error
    | PackageInstallInvalidGrenJson Decode.Error
    | PackageInstallDebug String


install : Config -> Options -> Task PackageInstallError PackageResolution
install config { projectPath, outline } =
    let
        rootDeps =
            when outline is
                Outline.App appOutline ->
                    Dict.union
                        appOutline.dependencies.direct
                        appOutline.dependencies.indirect
                        |> Dict.map
                            (\_ v ->
                                when v is
                                    Outline.Version vsn ->
                                        Outline.Version (SemanticVersionRange.fromExact vsn)

                                    Outline.LocalPath p ->
                                        Outline.LocalPath p
                            )

                Outline.Pkg pkgOutline ->
                    pkgOutline.dependencies
    in
    rootDeps
        |> Dict.foldl
            (\key value acc ->
                Array.pushLast
                    { name = PackageName.fromString key |> Maybe.withDefault PackageName.example
                    , constraint = value
                    }
                    acc
            )
            []
        |> Array.map
            (\{ name, constraint } ->
                when constraint is
                    Outline.Version vsn ->
                        loadPackageFromBundle config.fsPermission name (SemanticVersionRange.lowerBound vsn) projectPath

                    Outline.LocalPath path ->
                        loadPackageFromPath config.fsPermission name path
            )
        |> Task.concurrent
        |> Task.map (Array.mapAndKeepJust identity)
        |> Task.andThen
            (\pkgs ->
                let
                    loadedPackages =
                        Array.foldl
                            (\pkg dict ->
                                Dict.set
                                    (PackageName.toString pkg.name)
                                    { outline = pkg.outline
                                    , sources = pkg.sources
                                    }
                                    dict
                            )
                            Dict.empty
                            pkgs
                in
                Outline.findSourceFiles config.fsPermission outline projectPath
                    |> Task.mapError FileSystem.errorToString
                    |> Task.map
                        (\sourceFiles ->
                            { projectPath = projectPath
                            , outline = outline
                            , projectSources =
                                Array.foldl
                                    (\{ moduleName, source } dict -> Dict.set moduleName source dict)
                                    Dict.empty
                                    sourceFiles
                            , rootPackages =
                                Dict.foldl
                                    (\key value acc ->
                                        when value is
                                            Outline.Version vsn ->
                                                Array.pushLast
                                                    { name = PackageName.fromString key |> Maybe.withDefault PackageName.example
                                                    , version = vsn
                                                    }
                                                    acc

                                            Outline.LocalPath _ ->
                                                when Dict.get key loadedPackages is
                                                    Just { outline = pkgOutline } ->
                                                        Array.pushLast
                                                            { name = PackageName.fromString key |> Maybe.withDefault PackageName.example
                                                            , version = SemanticVersionRange.fromExact pkgOutline.version
                                                            }
                                                            acc

                                                    _ ->
                                                        acc
                                    )
                                    []
                                    rootDeps
                            , loadedPackages = loadedPackages
                            , solvedPackages = Dict.empty
                            }
                        )
            )
        |> Task.mapError PackageInstallDebug
        |> Task.andThen (installStep config)


type alias StepOptions =
    { projectPath : Path
    , outline : Outline
    , projectSources : Dict String String
    , rootPackages : Array { name : PackageName, version : SemanticVersionRange }
    , loadedPackages : Dict String { outline : Outline.PkgOutline, sources : Dict String String }
    , solvedPackages : Dict String Compiler.Dependencies.SimplifiedOutline
    }


installStep : Config -> StepOptions -> Task PackageInstallError PackageResolution
installStep config { projectPath, outline, projectSources, rootPackages, loadedPackages, solvedPackages } =
    when Compiler.Dependencies.solve rootPackages solvedPackages is
        Compiler.Dependencies.Complete ->
            Task.succeed
                { projectPath = projectPath
                , outline = outline
                , rootSources = projectSources
                , dependencies = loadedPackages
                }

        Compiler.Dependencies.Missing { name, version } ->
            let
                packageNameString =
                    PackageName.toString name
            in
            -- TODO: Check that the package is defined in the outline
            when Dict.get packageNameString loadedPackages is
                Just loadedPackage ->
                    Outline.findSourceFiles config.fsPermission outline projectPath
                        |> Task.mapError FileSystem.errorToString
                        |> Task.map
                            (\sourceFiles ->
                                { projectPath = projectPath
                                , outline = outline
                                , projectSources =
                                    Array.foldl
                                        (\{ moduleName, source } dict -> Dict.set moduleName source dict)
                                        Dict.empty
                                        sourceFiles
                                , rootPackages = rootPackages
                                , loadedPackages = loadedPackages
                                , solvedPackages =
                                    Dict.set
                                        packageNameString
                                        { name = name
                                        , version = version
                                        , dependencies =
                                            Dict.mapAndKeepJust
                                                (\_ constraint ->
                                                    when constraint is
                                                        -- TODO: Error
                                                        Outline.Version vsn ->
                                                            Just vsn

                                                        Outline.LocalPath _ ->
                                                            Nothing
                                                )
                                                loadedPackage.outline.dependencies
                                        }
                                        solvedPackages
                                }
                            )
                            |> Task.mapError PackageInstallDebug
                            |> Task.andThen (installStep config)
                
                Nothing ->
                    let
                        lowerBound =
                            SemanticVersionRange.lowerBound version

                        bundlePath =
                            packageBundlePath name lowerBound projectPath

                        repoPath =
                            localRepoPath name lowerBound projectPath
                    in
                    FileSystem.remove config.fsPermission { recursive = True, ignoreErrors = False } repoPath
                        |> Task.onError (\_ -> Task.succeed repoPath) -- Probably because directory doesn't exist, that's fine
                        |> Task.andThen (\_ -> Git.clonePackage config.cpPermission repoPath name lowerBound)
                        |> Task.mapError (\{ stderr } -> Maybe.withDefault "" <| Bytes.toString stderr)
                        |> Task.andThen (\{} ->
                            (Path.append (Path.fromPosixString "gren.json") repoPath)
                                |> readOutline config.fsPermission
                                |> Task.mapError FileSystem.errorToString
                                |> Task.andThen
                                    (\decodeResult ->
                                        when decodeResult is
                                            Ok (Outline.Pkg packageOutline) ->
                                                Outline.findSourceFiles config.fsPermission (Outline.Pkg packageOutline) repoPath
                                                    |> Task.mapError FileSystem.errorToString
                                                    |> Task.map
                                                        (\files ->
                                                            let
                                                                sources =
                                                                    Array.foldl
                                                                        (\{ moduleName, source } dict ->
                                                                            Dict.set moduleName source dict
                                                                        )
                                                                        Dict.empty
                                                                        files
                                                            in
                                                            { name = name
                                                            , outline = packageOutline
                                                            , sources = sources
                                                            , data =
                                                                packageBundleEncoder packageOutline sources
                                                                    |> Json.encode 0
                                                            }
                                                        )

                                            Ok (Outline.App _) ->
                                                Task.fail "Expected package-type outline."

                                            Err err ->
                                                Task.fail <| Debug.toString err
                                    )
                        )
                        |> Task.andThen
                            (\pkg ->
                                let
                                    packagesDir =
                                        Path.append (Path.fromPosixString "gren_packages") projectPath
                                in
                                packagesDir
                                    |> FileSystem.makeDirectory config.fsPermission { recursive = False }
                                    |> Task.onError
                                        (\err ->
                                            if FileSystem.errorIsFileExists err then
                                                Task.succeed packagesDir

                                            else
                                                Task.fail err
                                        )
                                    |> Task.andThen (\_ -> FileSystem.writeFileStream config.fsPermission bundlePath)
                                    |> Task.mapError FileSystem.errorToString
                                    |> Task.andThen
                                        (\stream ->
                                            Stream.fromArray [ pkg.data ]
                                                |> Task.andThen (Stream.awaitAndPipeThrough Stream.textEncoder)
                                                |> Task.andThen (Stream.awaitAndPipeThrough Stream.gzipCompression)
                                                |> Task.andThen (Stream.pipeTo stream)
                                                |> Task.mapError Stream.errorToString
                                        )
                                    |> Task.map (\_ -> pkg)
                            )
                        |> Task.andThen
                            (\pkg ->
                                Outline.findSourceFiles config.fsPermission outline projectPath
                                    |> Task.mapError FileSystem.errorToString
                                    |> Task.map
                                        (\sourceFiles ->
                                            { projectPath = projectPath
                                            , outline = outline
                                            , projectSources =
                                                Array.foldl
                                                    (\{ moduleName, source } dict -> Dict.set moduleName source dict)
                                                    Dict.empty
                                                    sourceFiles
                                            , rootPackages = rootPackages
                                            , loadedPackages =
                                                Dict.set
                                                    (PackageName.toString name)
                                                    { outline = pkg.outline, sources = pkg.sources }
                                                    loadedPackages
                                            , solvedPackages = solvedPackages
                                            }
                                        )
                            )
                        -- TODO: Print progress
                        |> Task.mapError PackageInstallDebug
                        |> Task.andThen (installStep config)

        Compiler.Dependencies.Conflict _ ->
            Task.fail (PackageInstallDebug "TODO: CONFLICT")


packageBundlePath : PackageName -> SemanticVersion -> Path -> Path
packageBundlePath name version projectPath =
    let
        normalizedName =
            (PackageName.toString name ++ "__" ++ SemanticVersion.toString version)
                |> String.replace "-" "_"
                |> String.replace "." "_"
                |> String.replace "/" "_"
                |> String.append ".pkg.gz"
    in
    Path.join
        [ projectPath
        , Path.fromPosixString "gren_packages"
        , Path.fromPosixString normalizedName
        ]


localRepoPath : PackageName -> SemanticVersion -> Path -> Path
localRepoPath name version projectPath =
    let
        normalizedName =
            (PackageName.toString name ++ "__" ++ SemanticVersion.toString version)
                |> String.replace "-" "_"
                |> String.replace "." "_"
                |> String.replace "/" "_"
    in
    Path.join
        [ projectPath
        , Path.fromPosixString ".gren/git"
        , Path.fromPosixString normalizedName
        ]


readOutline : FileSystem.Permission -> Path -> Task FileSystem.Error (Result Decode.Error Outline)
readOutline fsPerm path =
    FileSystem.readFile fsPerm path
        |> Task.map (Bytes.toString >> Maybe.withDefault "")
        |> Task.map (Decode.decodeString Outline.jsonDecoder)

readProjectOutline : FileSystem.Permission -> Task PackageInstallError { grenJsonPath : Path, outline : Outline }
readProjectOutline fsPermission =
    Compiler.Paths.projectRoot fsPermission
        |> Task.mapError PackageInstallNoProject
        |> Task.map (Path.append (Path.fromPosixString "gren.json"))
        |> Task.andThen
            (\grenJsonPath ->
                readOutline fsPermission grenJsonPath
                    |> Task.mapError PackageInstallNoGrenJson
                    |> Task.andThen
                        (\decodeResult ->
                            when decodeResult is
                                Ok outline ->
                                    Task.succeed
                                        { grenJsonPath = grenJsonPath
                                        , outline = outline
                                        }

                                Err err ->
                                    Task.fail (PackageInstallInvalidGrenJson err)
                        )
            )


packageBundleEncoder : Outline.PkgOutline -> Dict String String -> Json.Value
packageBundleEncoder outline sources =
    Json.object
        [ { key = "outline", value = Outline.toJson (Outline.Pkg outline) }
        , { key = "sources", value = Json.dict identity Json.string sources }
        ]


packageBundleDecoder : Decoder { outline : Outline.PkgOutline, sources : Dict String String }
packageBundleDecoder =
    Decode.map2 (\outline sources -> { outline = outline, sources = sources })
        (Decode.field "outline" Outline.pkgJsonDecoder)
        (Decode.field "sources" (Decode.dict Decode.string))
type alias LoadedPackage =
    { name : PackageName
    , outline : Outline.PkgOutline
    , sources : Dict String String
    }


-- TODO: extract to module
loadPackageFromPath : FileSystem.Permission -> PackageName -> Path -> Task String (Maybe LoadedPackage)
loadPackageFromPath fsPermission name path =
    let
        outlinePath =
            Path.append (Path.fromPosixString "gren.json") path
    in
    FileSystem.readFile fsPermission outlinePath
        |> Task.mapError FileSystem.errorToString
        |> Task.andThen
            (\outlineBytes ->
                when Bytes.toString outlineBytes is
                    Just str ->
                        Task.succeed str

                    Nothing ->
                        Task.fail "gren.json not valid utf-8"
            )
        |> Task.andThen
            (\outlineStr ->
                when Decode.decodeString Outline.pkgJsonDecoder outlineStr is
                    Ok outline ->
                        Outline.findSourceFiles fsPermission (Outline.Pkg outline) path
                            |> Task.mapError FileSystem.errorToString
                            |> Task.andThen
                                (\sourceFiles ->
                                    if name /= outline.name then
                                        Task.fail ("Name in outline was expected to be " ++ PackageName.toString name)

                                    else
                                        Task.succeed
                                            (Just
                                                { name = name
                                                , outline = outline
                                                , sources =
                                                    Array.foldl
                                                        (\{ moduleName, source } acc ->
                                                            Dict.set moduleName source acc
                                                        )
                                                        Dict.empty
                                                        sourceFiles
                                                }
                                            )
                                )

                    Err jsonErr ->
                        Task.fail <| Decode.errorToString jsonErr
            )

loadPackageFromBundle : FileSystem.Permission -> PackageName -> SemanticVersion -> Path -> Task String (Maybe LoadedPackage)
loadPackageFromBundle fsPermission name vsn projectPath =
    packageBundlePath name vsn projectPath
        |> FileSystem.readFileStream fsPermission
        |> Task.mapError FileSystem.errorToString
        |> Task.andThen
            (\stream ->
                stream
                    |> Stream.awaitAndPipeThrough Stream.gzipDecompression
                    |> Task.andThen (Stream.awaitAndPipeThrough Stream.textDecoder)
                    |> Task.andThen Stream.Extra.consumeString
                    |> Task.mapError Stream.errorToString
                    |> Task.andThen
                        (\data ->
                            when Decode.decodeString packageBundleDecoder data is
                                Ok bundle ->
                                    if name /= bundle.outline.name then
                                        Task.fail ("Package name mismatch. Expected " ++ PackageName.toString name)

                                    else if vsn /= bundle.outline.version then
                                        Task.fail ("Package version mismatch. Expected " ++ SemanticVersion.toString vsn)

                                    else
                                        Task.succeed
                                            (Just
                                                { name = name
                                                , outline = bundle.outline
                                                , sources = bundle.sources
                                                }
                                            )

                                Err jsonErr ->
                                    Task.fail <| Decode.errorToString jsonErr
                        )
                    |> Task.onError (\_ -> Task.succeed Nothing)
            )
